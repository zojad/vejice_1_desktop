"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestUtil = void 0;
const ajv_draft_04_1 = __importDefault(require("ajv-draft-04"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const _2020_1 = __importDefault(require("ajv/dist/2020"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const generated_types_1 = require("./generated-types");
__exportStar(require("./declarativeCopilotManifest"), exports);
__exportStar(require("./generated-types"), exports);
__exportStar(require("./manifest"), exports);
__exportStar(require("./pluginManifest"), exports);
class ManifestUtil {
    /**
     * Loads the manifest from the given path with basic type check.
     *
     * @deprecated use `AppManifestUtils.read()` instead
     * @param path - The path to the manifest file.
     * @throws Will propagate any error thrown by the fs-extra#readJson or type check failure.
     *
     * @returns The Manifest Object.
     */
    static async loadFromPath(path) {
        const jsonString = await fs_extra_1.default.readFile(path, "utf8");
        const manifest = generated_types_1.TeamsManifestConverter.jsonToManifest(jsonString);
        return manifest;
    }
    /**
     * Loads the manifest from the given path with validation
     *
     * @deprecated use `AppManifestUtils.readAndValidate()` instead
     * @param path - The path to the manifest file.
     * @throws Will propagate any error thrown by the fs-extra#readJson or type check failure.
     *
     * @returns The Manifest Object and schema validation results
     */
    static async loadAndValidateFromPath(path) {
        const manifest = await this.loadFromPath(path);
        const validateRes = await generated_types_1.AppManifestUtils.validateAgainstSchema(manifest);
        return [manifest, validateRes];
    }
    /**
     * Writes the manifest object to the given path.
     *
     * @deprecated use `AppManifestUtils.writeTeamsManifest()` instead
     * @param path - Where to write
     * @param manifest - Manifest object to be saved
     * @throws Will propagate any error thrown by the fs-extra#writeJson.
     *
     */
    static async writeToPath(path, manifest) {
        return fs_extra_1.default.writeJson(path, manifest, { spaces: 4 });
    }
    /**
     * Validate manifest against json schema.
     * @deprecated use `AppManifestUtils.validateAgainstSchema(manifest, schema)` instead
     * @param manifest - Manifest object to be validated
     * @param schema - teams-app-manifest schema
     * @returns An empty array if it passes validation, or an array of error string otherwise.
     */
    static validateManifestAgainstSchema(manifest, schema) {
        var _a, _b;
        let validate;
        if ((_a = schema.$schema) === null || _a === void 0 ? void 0 : _a.includes("2020-12")) {
            const ajv = new _2020_1.default({
                //formats: { uri: true, email: true },
                allErrors: true,
                strictTypes: false,
            });
            (0, ajv_formats_1.default)(ajv, ["uri", "email", "regex"]);
            validate = ajv.compile(schema);
        }
        else {
            const ajv = new ajv_draft_04_1.default({
                allErrors: true,
                strictTypes: false,
            });
            (0, ajv_formats_1.default)(ajv, ["uri", "email", "regex"]);
            validate = ajv.compile(schema);
        }
        const valid = validate(manifest);
        if (!valid && validate.errors) {
            return Promise.resolve((_b = validate.errors) === null || _b === void 0 ? void 0 : _b.map((error) => `${error.instancePath} ${error.message || ""}. Details: ${error.params ? JSON.stringify(error.params) : ""}`));
        }
        else {
            return Promise.resolve([]);
        }
    }
    /**
     * @deprecated
     * @param manifest
     * @returns
     */
    static async fetchSchema(manifest) {
        const schemaUrl = (manifest.$schema || manifest.schema);
        if (!schemaUrl) {
            throw new Error("Manifest does not have a $schema property or schema url is not provided.");
        }
        let result;
        try {
            const res = await (0, node_fetch_1.default)(schemaUrl);
            // workaround for invalid regex expression https://github.com/OfficeDev/microsoft-teams-app-schema/issues/190
            const text = await res.text();
            const cleanedText = text.replace(/\\a/g, "\\x07");
            result = JSON.parse(cleanedText);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error(`Failed to get manifest at url ${schemaUrl} due to: ${e.message}`);
            }
            else {
                throw new Error(`Failed to get manifest at url ${schemaUrl} due to: unknown error`);
            }
        }
        return result;
    }
    /**
     * Validate manifest against {@link TeamsAppManifest#$schema}.
     *
     * @deprecated use `AppManifestUtils.validateAgainstSchema(manifest: T)` instead
     * @param manifest - Manifest object to be validated
     * @throws Will throw if {@link TeamsAppManifest#$schema} is undefined, not valid
     *         or there is any network failure when getting the schema.
     *
     * @returns An empty array if schema validation passes, or an array of error string otherwise.
     */
    static async validateManifest(manifest) {
        const schema = await this.fetchSchema(manifest);
        return ManifestUtil.validateManifestAgainstSchema(manifest, schema);
    }
}
exports.ManifestUtil = ManifestUtil;
//# sourceMappingURL=index.js.map