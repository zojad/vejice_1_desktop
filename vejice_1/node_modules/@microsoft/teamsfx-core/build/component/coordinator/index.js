"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.openUrl = exports.showAadResourceLink = exports.coordinator = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const glob_1 = require("glob");
const jsonschema = tslib_1.__importStar(require("jsonschema"));
const lodash_1 = require("lodash");
const os_1 = require("os");
const path = tslib_1.__importStar(require("path"));
const uuid = tslib_1.__importStar(require("uuid"));
const xml2js = tslib_1.__importStar(require("xml2js"));
const constants_1 = require("../../common/constants");
const featureFlags_1 = require("../../common/featureFlags");
const globalVars_1 = require("../../common/globalVars");
const localizeUtils_1 = require("../../common/localizeUtils");
const stringUtils_1 = require("../../common/stringUtils");
const telemetry_1 = require("../../common/telemetry");
const environmentName_1 = require("../../core/environmentName");
const azure_1 = require("../../error/azure");
const common_1 = require("../../error/common");
const yml_1 = require("../../error/yml");
const constants_2 = require("../../question/constants");
const CapabilityOptions_1 = require("../../question/scaffold/vsc/CapabilityOptions");
const ProjectTypeOptions_1 = require("../../question/scaffold/vsc/ProjectTypeOptions");
const teamsProjectTypeNode_1 = require("../../question/scaffold/vsc/teamsProjectTypeNode");
const constants_3 = require("../constants");
const deployUtils_1 = require("../deployUtils");
const appStudio_1 = require("../driver/teamsApp/appStudio");
const constants_4 = require("../driver/teamsApp/constants");
const ManifestUtils_1 = require("../driver/teamsApp/utils/ManifestUtils");
const generator_1 = require("../generator/generator");
const generatorProvider_1 = require("../generator/generatorProvider");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const provisionUtils_1 = require("../provisionUtils");
const ResourceGroupHelper_1 = require("../utils/ResourceGroupHelper");
const envUtil_1 = require("../utils/envUtil");
const metadataUtil_1 = require("../utils/metadataUtil");
const pathUtils_1 = require("../utils/pathUtils");
const settingsUtil_1 = require("../utils/settingsUtil");
const summary_1 = require("./summary");
const M365Actions = [
    "botAadApp/create",
    "teamsApp/create",
    "teamsApp/update",
    "aadApp/create",
    "aadApp/update",
    "botFramework/create",
    "teamsApp/extendToM365",
];
const AzureActions = ["arm/deploy"];
const needTenantCheckActions = ["botAadApp/create", "aadApp/create", "botFramework/create"];
class Coordinator {
    async create(context, inputs, actionContext) {
        var _a, _b, _c;
        // Handle command redirect to Kiota. Only happens in vscode.
        if (inputs.platform === teamsfx_api_1.Platform.VSCode &&
            featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
            inputs[constants_2.QuestionNames.ActionType] === constants_2.ActionStartOptions.apiSpec().id &&
            !inputs[constants_2.QuestionNames.ActionManifestPath] &&
            inputs[constants_2.QuestionNames.Capabilities] === CapabilityOptions_1.DACapabilityOptions.declarativeAgent().id) {
            const lastCommand = constants_3.KiotaLastCommands.createDeclarativeCopilotWithManifest;
            return (0, teamsfx_api_1.ok)({ projectPath: "", lastCommand: lastCommand });
        }
        let folder = inputs["folder"];
        if (!folder) {
            return (0, teamsfx_api_1.err)(new common_1.MissingRequiredInputError("folder"));
        }
        folder = path.resolve(folder);
        const scratch = inputs[constants_2.QuestionNames.Scratch];
        let projectPath = "";
        let warnings = undefined;
        if (scratch === constants_2.ScratchOptions.no().id) {
            // create from sample
            const sampleId = inputs[constants_2.QuestionNames.Samples];
            if (!sampleId) {
                throw new common_1.MissingRequiredInputError(constants_2.QuestionNames.Samples);
            }
            projectPath = path.join(folder, sampleId);
            let suffix = 1;
            while ((await fs_extra_1.default.pathExists(projectPath)) && (await fs_extra_1.default.readdir(projectPath)).length > 0) {
                projectPath = path.join(folder, `${sampleId}_${suffix++}`);
            }
            inputs.projectPath = projectPath;
            await fs_extra_1.default.ensureDir(projectPath);
            const res = await generator_1.Generator.generateSample(context, projectPath, sampleId);
            if (res.isErr())
                return (0, teamsfx_api_1.err)(res.error);
            downloadSampleHook(sampleId, projectPath);
        }
        else if (!scratch || scratch === constants_2.ScratchOptions.yes().id) {
            // create from new
            const appName = inputs[constants_2.QuestionNames.AppName];
            if (undefined === appName)
                return (0, teamsfx_api_1.err)(new common_1.MissingRequiredInputError(constants_2.QuestionNames.AppName));
            const validateResult = jsonschema.validate(appName, {
                pattern: constants_2.AppNamePattern,
            });
            if (validateResult.errors && validateResult.errors.length > 0) {
                return (0, teamsfx_api_1.err)(new common_1.InputValidationError(constants_2.QuestionNames.AppName, validateResult.errors[0].message));
            }
            projectPath = path.join(folder, appName);
            inputs.projectPath = projectPath;
            await fs_extra_1.default.ensureDir(projectPath);
            // set isVS global var when creating project
            const language = inputs[constants_2.QuestionNames.ProgrammingLanguage];
            globalVars_1.globalVars.isVS = language === "csharp";
            const capability = inputs.capabilities;
            const projectType = inputs[constants_2.QuestionNames.ProjectType];
            const teamsAppType = inputs[constants_2.QuestionNames.TeamsAppType];
            delete inputs.folder;
            (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
                [telemetry_1.TelemetryProperty.Capabilities]: capability,
                [telemetry_1.TelemetryProperty.IsFromTdp]: (!!inputs.teamsAppFromTdp).toString(),
            });
            if (projectType === ProjectTypeOptions_1.ProjectTypeOptions.customEngineAgentOptionId ||
                (teamsAppType === teamsProjectTypeNode_1.TeamsProjectTypeOptions.botOptionId && inputs.platform === teamsfx_api_1.Platform.VS)) {
                (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
                    [telemetry_1.TelemetryProperty.CustomCopilotRAG]: (_a = inputs["custom-copilot-rag"]) !== null && _a !== void 0 ? _a : "",
                    [telemetry_1.TelemetryProperty.CustomCopilotAgent]: (_b = inputs["custom-copilot-agent"]) !== null && _b !== void 0 ? _b : "",
                    [telemetry_1.TelemetryProperty.LlmService]: (_c = inputs["llm-service"]) !== null && _c !== void 0 ? _c : "",
                    [telemetry_1.TelemetryProperty.HasAzureOpenAIKey]: inputs["azure-openai-key"] ? "true" : "false",
                    [telemetry_1.TelemetryProperty.HasAzureOpenAIEndpoint]: inputs["azure-openai-endpoint"]
                        ? "true"
                        : "false",
                    [telemetry_1.TelemetryProperty.HasAzureOpenAIDeploymentName]: inputs["azure-openai-deployment-name"]
                        ? "true"
                        : "false",
                    [telemetry_1.TelemetryProperty.HasOpenAIKey]: inputs["openai-key"] ? "true" : "false",
                });
            }
            // refactored generator
            const generator = generatorProvider_1.Generators.find((g) => g.activate(context, inputs));
            if (!generator) {
                return (0, teamsfx_api_1.err)(new teamsfx_api_1.SystemError("coordinator", "NoActivatedGeneratorError", `No activated generator by inputs: ${JSON.stringify(inputs)}`));
            }
            const res = await generator.run(context, inputs, projectPath);
            if (res.isErr())
                return (0, teamsfx_api_1.err)(res.error);
            else {
                warnings = res.value.warnings;
            }
        }
        // generate unique projectId in teamsapp.yaml (optional)
        const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, "dev", true);
        if (await fs_extra_1.default.pathExists(ymlPath)) {
            const ensureRes = await this.ensureTrackingId(projectPath, inputs.projectId);
            if (ensureRes.isErr())
                return (0, teamsfx_api_1.err)(ensureRes.error);
            inputs.projectId = ensureRes.value;
        }
        const trimRes = await ManifestUtils_1.manifestUtils.trimManifestShortName(projectPath);
        if (trimRes.isErr())
            return (0, teamsfx_api_1.err)(trimRes.error);
        return (0, teamsfx_api_1.ok)({ projectPath: projectPath, warnings });
    }
    async ensureTeamsFxInCsproj(projectPath) {
        const list = await fs_extra_1.default.readdir(projectPath);
        const csprojFiles = list.filter((fileName) => fileName.endsWith(".csproj"));
        if (csprojFiles.length === 0)
            return (0, teamsfx_api_1.ok)(undefined);
        const filePath = csprojFiles[0];
        const xmlStringOld = (await fs_extra_1.default.readFile(filePath, { encoding: "utf8" })).toString();
        const jsonObj = await xml2js.parseStringPromise(xmlStringOld);
        let ItemGroup = jsonObj.Project.ItemGroup;
        if (!ItemGroup) {
            ItemGroup = [];
            jsonObj.Project.ItemGroup = ItemGroup;
        }
        const existItems = ItemGroup.filter((item) => {
            var _a;
            if (item.ProjectCapability && item.ProjectCapability[0])
                if (((_a = item.ProjectCapability[0]["$"]) === null || _a === void 0 ? void 0 : _a.Include) === "TeamsFx")
                    return true;
            return false;
        });
        if (existItems.length === 0) {
            const toAdd = {
                ProjectCapability: [
                    {
                        $: {
                            Include: "TeamsFx",
                        },
                    },
                ],
            };
            ItemGroup.push(toAdd);
            const builder = new xml2js.Builder();
            const xmlStringNew = builder.buildObject(jsonObj);
            await fs_extra_1.default.writeFile(filePath, xmlStringNew, { encoding: "utf8" });
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    async ensureTrackingId(projectPath, trackingId = undefined) {
        // generate unique trackingId in settings.json
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath, false);
        if (settingsRes.isErr())
            return (0, teamsfx_api_1.err)(settingsRes.error);
        const settings = settingsRes.value;
        if (settings.trackingId && !trackingId)
            return (0, teamsfx_api_1.ok)(settings.trackingId); // do nothing
        settings.trackingId = trackingId || uuid.v4();
        await settingsUtil_1.settingsUtil.writeSettings(projectPath, settings);
        return (0, teamsfx_api_1.ok)(settings.trackingId);
    }
    async preProvisionForVS(ctx, inputs) {
        const res = {
            needAzureLogin: false,
            needM365Login: false,
        };
        // 1. parse yml to cycles
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath);
        if (maybeProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const cycles = [
            projectModel.registerApp,
            projectModel.provision,
            projectModel.configureApp,
        ].filter((c) => c !== undefined);
        // 2. check each cycle
        for (const cycle of cycles) {
            const unresolvedPlaceholders = cycle.resolvePlaceholders();
            let firstArmDriver;
            for (const driver of cycle.driverDefs) {
                if (AzureActions.includes(driver.uses)) {
                    res.needAzureLogin = true;
                    if (!firstArmDriver) {
                        firstArmDriver = driver;
                    }
                }
                if (M365Actions.includes(driver.uses)) {
                    res.needM365Login = true;
                }
            }
            if (firstArmDriver) {
                const withObj = firstArmDriver.with;
                res.resolvedAzureSubscriptionId = unresolvedPlaceholders.includes("AZURE_SUBSCRIPTION_ID")
                    ? undefined
                    : withObj["subscriptionId"];
                res.resolvedAzureResourceGroupName = unresolvedPlaceholders.includes("AZURE_RESOURCE_GROUP_NAME")
                    ? undefined
                    : withObj["resourceGroupName"];
            }
        }
        return (0, teamsfx_api_1.ok)(res);
    }
    async preCheckYmlAndEnvForVS(ctx, inputs) {
        var _a, _b, _c;
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath);
        if (maybeProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const cycles = [projectModel.provision].filter((c) => c !== undefined);
        let unresolvedPlaceholders = [];
        // 2. check each cycle
        for (const cycle of cycles) {
            unresolvedPlaceholders = unresolvedPlaceholders.concat(cycle.resolvePlaceholders());
        }
        if (unresolvedPlaceholders.length > 0) {
            return (0, teamsfx_api_1.err)(new common_1.MissingEnvironmentVariablesError("coordinator", unresolvedPlaceholders.join(",")));
        }
        for (const action of (_b = (_a = projectModel.provision) === null || _a === void 0 ? void 0 : _a.driverDefs) !== null && _b !== void 0 ? _b : []) {
            if (action.uses === "teamsApp/create") {
                const teamsAppIdKeyName = ((_c = action.writeToEnvironmentFile) === null || _c === void 0 ? void 0 : _c.teamsAppId) || "TEAMS_APP_ID";
                if (!process.env[teamsAppIdKeyName]) {
                    return (0, teamsfx_api_1.err)(new common_1.MissingEnvironmentVariablesError("coordinator", teamsAppIdKeyName));
                }
                break;
            }
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    async provision(ctx, inputs) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const output = {};
        if (process.env.APP_NAME_SUFFIX === undefined && process.env.TEAMSFX_ENV) {
            process.env.APP_NAME_SUFFIX = process.env.TEAMSFX_ENV;
            output.APP_NAME_SUFFIX = process.env.TEAMSFX_ENV;
        }
        const folderName = path.parse(ctx.projectPath).name;
        // 1. parse yml
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath);
        if (maybeProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const cycles = [
            // projectModel.registerApp,
            projectModel.provision,
            // projectModel.configureApp,
        ].filter((c) => c !== undefined);
        if (cycles.length === 0) {
            return (0, teamsfx_api_1.err)(new yml_1.LifeCycleUndefinedError("provision"));
        }
        // 2. M365 sign in and tenant check if needed.
        let containsM365 = false;
        let containsAzure = false;
        let containsUpdateAad = false;
        const tenantSwitchCheckActions = [];
        cycles.forEach((cycle) => {
            var _a;
            (_a = cycle.driverDefs) === null || _a === void 0 ? void 0 : _a.forEach((def) => {
                if (M365Actions.includes(def.uses)) {
                    containsM365 = true;
                }
                else if (AzureActions.includes(def.uses)) {
                    containsAzure = true;
                }
                if (def.uses === "aadApp/update") {
                    containsUpdateAad = true;
                }
                if (needTenantCheckActions.includes(def.uses)) {
                    tenantSwitchCheckActions.push(def.uses);
                }
            });
        });
        let m365tenantInfo = undefined;
        if (containsM365) {
            const tenantInfoInTokenRes = await provisionUtils_1.provisionUtils.getM365TenantId(ctx.m365TokenProvider);
            if (tenantInfoInTokenRes.isErr()) {
                return (0, teamsfx_api_1.err)(tenantInfoInTokenRes.error);
            }
            m365tenantInfo = tenantInfoInTokenRes.value;
            const checkM365TenatRes = provisionUtils_1.provisionUtils.ensureM365TenantMatchesV3(tenantSwitchCheckActions, m365tenantInfo.tenantIdInToken);
            if (checkM365TenatRes.isErr()) {
                const msg = (0, localizeUtils_1.getLocalizedString)("core.provision.switchAccount");
                const continueItem = (0, localizeUtils_1.getLocalizedString)("core.provision.switchAccount.continue");
                const userCofirmRes = await ((_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.showMessage("warn", msg, true, continueItem));
                if ((userCofirmRes === null || userCofirmRes === void 0 ? void 0 : userCofirmRes.isOk()) && userCofirmRes.value === continueItem) {
                    await ctx.m365TokenProvider.signout();
                    const tenantInfoInTokenRes1 = await provisionUtils_1.provisionUtils.getM365TenantId(ctx.m365TokenProvider);
                    if (tenantInfoInTokenRes1.isErr()) {
                        return (0, teamsfx_api_1.err)(tenantInfoInTokenRes1.error);
                    }
                    m365tenantInfo = tenantInfoInTokenRes1.value;
                    const checkM365TenatRes1 = provisionUtils_1.provisionUtils.ensureM365TenantMatchesV3(tenantSwitchCheckActions, m365tenantInfo.tenantIdInToken);
                    if (checkM365TenatRes1.isErr()) {
                        return (0, teamsfx_api_1.err)(checkM365TenatRes1.error);
                    }
                }
                else {
                    return (0, teamsfx_api_1.err)(new common_1.UserCancelError("coordinator"));
                }
            }
        }
        // We will update targetResourceGroupInfo if creating resource group is needed and create the resource group later after confirming with the user
        let targetResourceGroupInfo = {
            createNewResourceGroup: false,
            name: "",
            location: "",
        };
        let resolvedSubscriptionId;
        let resolvedResourceGroupName;
        let azureSubInfo = undefined;
        if (containsAzure) {
            //ensure RESOURCE_SUFFIX
            if (!process.env.RESOURCE_SUFFIX) {
                const suffix = process.env.RESOURCE_SUFFIX || uuid.v4().slice(0, 6);
                process.env.RESOURCE_SUFFIX = suffix;
                output.RESOURCE_SUFFIX = suffix;
            }
            // check whether placeholders are resolved
            let subscriptionUnresolved = false;
            let resourceGroupUnresolved = false;
            for (const cycle of cycles) {
                const unresolvedPlaceHolders = cycle.resolvePlaceholders();
                if (unresolvedPlaceHolders.includes("AZURE_SUBSCRIPTION_ID"))
                    subscriptionUnresolved = true;
                else {
                    (_b = cycle.driverDefs) === null || _b === void 0 ? void 0 : _b.forEach((driver) => {
                        const withObj = driver.with;
                        if (withObj && withObj.subscriptionId && resolvedSubscriptionId === undefined)
                            resolvedSubscriptionId = withObj.subscriptionId;
                    });
                }
                if (unresolvedPlaceHolders.includes("AZURE_RESOURCE_GROUP_NAME"))
                    resourceGroupUnresolved = true;
                else {
                    (_c = cycle.driverDefs) === null || _c === void 0 ? void 0 : _c.forEach((driver) => {
                        const withObj = driver.with;
                        if (withObj && withObj.resourceGroupName && resolvedResourceGroupName === undefined)
                            resolvedResourceGroupName = withObj.resourceGroupName;
                    });
                }
            }
            // ensure subscription, pop up UI to select if necessary
            if (subscriptionUnresolved) {
                if (inputs["targetSubscriptionId"]) {
                    process.env.AZURE_SUBSCRIPTION_ID = inputs["targetSubscriptionId"];
                    output.AZURE_SUBSCRIPTION_ID = inputs["targetSubscriptionId"];
                }
                else {
                    const ensureRes = await provisionUtils_1.provisionUtils.ensureSubscription(ctx.azureAccountProvider, undefined);
                    if (ensureRes.isErr())
                        return (0, teamsfx_api_1.err)(ensureRes.error);
                    const subInfo = ensureRes.value;
                    if (subInfo && subInfo.subscriptionId) {
                        process.env.AZURE_SUBSCRIPTION_ID = subInfo.subscriptionId;
                        output.AZURE_SUBSCRIPTION_ID = subInfo.subscriptionId;
                    }
                }
                resolvedSubscriptionId = process.env.AZURE_SUBSCRIPTION_ID;
            }
            // ensure resource group
            if (resourceGroupUnresolved) {
                const inputRG = inputs["targetResourceGroupName"];
                const inputLocation = inputs["targetResourceLocationName"];
                if (inputRG && inputLocation) {
                    // targetResourceGroupName is from VS inputs, which means create resource group if not exists
                    targetResourceGroupInfo.name = inputRG;
                    targetResourceGroupInfo.location = inputLocation;
                    targetResourceGroupInfo.createNewResourceGroup = true; // create resource group if not exists
                }
                else {
                    const defaultRg = `rg-${(0, stringUtils_1.convertToAlphanumericOnly)(folderName)}${process.env.RESOURCE_SUFFIX}-${inputs.env}`;
                    const ensureRes = await provisionUtils_1.provisionUtils.ensureResourceGroup(inputs, ctx.azureAccountProvider, resolvedSubscriptionId, undefined, defaultRg);
                    if (ensureRes.isErr())
                        return (0, teamsfx_api_1.err)(ensureRes.error);
                    targetResourceGroupInfo = ensureRes.value;
                    if (!targetResourceGroupInfo.createNewResourceGroup) {
                        process.env.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
                        output.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
                    }
                }
                resolvedResourceGroupName = targetResourceGroupInfo.name;
            }
            // consent user
            await ctx.azureAccountProvider.getIdentityCredentialAsync(true); // make sure login if ensureSubScription() is not called.
            try {
                await ctx.azureAccountProvider.setSubscription(resolvedSubscriptionId); //make sure sub is correctly set if ensureSubscription() is not called.
            }
            catch (e) {
                return (0, teamsfx_api_1.err)((0, common_1.assembleError)(e));
            }
            azureSubInfo = await ctx.azureAccountProvider.getSelectedSubscription(false);
            if (!azureSubInfo) {
                return (0, teamsfx_api_1.err)(new azure_1.SelectSubscriptionError());
            }
            const consentRes = await provisionUtils_1.provisionUtils.askForProvisionConsentV3(ctx, m365tenantInfo, azureSubInfo, inputs.env);
            if (consentRes.isErr())
                return (0, teamsfx_api_1.err)(consentRes.error);
            // create resource group if necessary
            if (targetResourceGroupInfo.createNewResourceGroup) {
                const createRgRes = await ResourceGroupHelper_1.resourceGroupHelper.createNewResourceGroup(targetResourceGroupInfo.name, ctx.azureAccountProvider, resolvedSubscriptionId, targetResourceGroupInfo.location);
                if (createRgRes.isErr()) {
                    const error = createRgRes.error;
                    if (!(error instanceof azure_1.ResourceGroupConflictError)) {
                        return (0, teamsfx_api_1.err)(error);
                    }
                }
                process.env.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
                output.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
            }
        }
        // execute
        const summaryReporter = new summary_1.SummaryReporter(cycles, ctx.logProvider);
        const steps = cycles.reduce((acc, cur) => acc + cur.driverDefs.length, 0);
        let hasError = false;
        try {
            ctx.progressBar = (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.createProgressBar((0, localizeUtils_1.getLocalizedString)("core.progress.provision"), steps);
            await ((_e = ctx.progressBar) === null || _e === void 0 ? void 0 : _e.start());
            const maybeDescription = summaryReporter.getLifecycleDescriptions();
            if (maybeDescription.isErr()) {
                hasError = true;
                return (0, teamsfx_api_1.err)(maybeDescription.error);
            }
            ctx.logProvider.info(`Executing provision ${os_1.EOL}${os_1.EOL}${maybeDescription.value}${os_1.EOL}`);
            for (const [index, cycle] of cycles.entries()) {
                const execRes = await cycle.execute(ctx);
                summaryReporter.updateLifecycleState(index, execRes);
                const result = this.convertExecuteResult(execRes.result, templatePath);
                (0, lodash_1.merge)(output, result[0]);
                if (result[1]) {
                    hasError = true;
                    inputs.envVars = output;
                    return (0, teamsfx_api_1.err)(result[1]);
                }
            }
        }
        finally {
            const summary = summaryReporter.getLifecycleSummary(inputs.createdEnvFile);
            ctx.logProvider.info(`Execution summary:${os_1.EOL}${os_1.EOL}${summary}${os_1.EOL}`);
            await ((_f = ctx.progressBar) === null || _f === void 0 ? void 0 : _f.end(!hasError));
        }
        // show provisioned resources
        const msg = (0, localizeUtils_1.getLocalizedString)("core.common.LifecycleComplete.provision", steps, steps);
        if (azureSubInfo) {
            const url = (0, constants_1.getResourceGroupInPortal)(azureSubInfo.subscriptionId, azureSubInfo.tenantId, resolvedResourceGroupName);
            if (url && ctx.platform !== teamsfx_api_1.Platform.CLI) {
                const title = (0, localizeUtils_1.getLocalizedString)("core.provision.viewResources");
                (_g = ctx.ui) === null || _g === void 0 ? void 0 : _g.showMessage("info", msg, false, title).then((result) => {
                    var _a;
                    const userSelected = result.isOk() ? result.value : undefined;
                    if (userSelected === title) {
                        (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.openUrl(url);
                    }
                });
                showAadResourceLink(ctx, containsUpdateAad, projectModel, process.env.AAD_APP_CLIENT_ID);
            }
            else {
                if (url && ctx.platform === teamsfx_api_1.Platform.CLI) {
                    (_h = ctx.ui) === null || _h === void 0 ? void 0 : _h.showMessage("info", [
                        {
                            content: `${msg} View the provisioned resources from `,
                            color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                        },
                        {
                            content: url,
                            color: teamsfx_api_1.Colors.BRIGHT_CYAN,
                        },
                    ], false);
                }
                else {
                    (_j = ctx.ui) === null || _j === void 0 ? void 0 : _j.showMessage("info", msg, false);
                }
            }
        }
        else {
            if (ctx.platform === teamsfx_api_1.Platform.VS) {
                void ctx.logProvider.info((0, localizeUtils_1.getLocalizedString)("core.common.LifecycleComplete.prepareTeamsApp"));
            }
            else {
                void ctx.ui.showMessage("info", msg, false);
            }
        }
        if (ctx.platform !== teamsfx_api_1.Platform.CLI) {
            ctx.logProvider.info(msg);
        }
        return (0, teamsfx_api_1.ok)(output);
    }
    convertExecuteResult(execRes, templatePath) {
        var _a;
        const output = {};
        let error = undefined;
        if (execRes.isErr()) {
            const execError = execRes.error;
            if (execError.kind === "Failure") {
                error = execError.error;
            }
            else {
                const partialOutput = execError.env;
                const newOutput = envUtil_1.envUtil.map2object(partialOutput);
                (0, lodash_1.merge)(output, newOutput);
                const reason = execError.reason;
                if (reason.kind === "DriverError") {
                    error = reason.error;
                }
                else if (reason.kind === "UnresolvedPlaceholders") {
                    const placeholders = ((_a = reason.unresolvedPlaceHolders) === null || _a === void 0 ? void 0 : _a.join(",")) || "";
                    error = new common_1.MissingEnvironmentVariablesError((0, lodash_1.camelCase)(reason.failedDriver.uses), placeholders, templatePath);
                }
            }
        }
        else {
            const newOutput = envUtil_1.envUtil.map2object(execRes.value);
            (0, lodash_1.merge)(output, newOutput);
        }
        return [output, error];
    }
    async deploy(ctx, inputs) {
        var _a, _b, _c, _d;
        const output = {};
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath);
        if (maybeProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        if (projectModel.deploy) {
            if (inputs.env !== environmentName_1.environmentNameManager.getLocalEnvName() &&
                inputs.env !== environmentName_1.environmentNameManager.getTestToolEnvName() &&
                inputs.env !== environmentName_1.environmentNameManager.getPlaygroundEnvName() &&
                inputs.env !== environmentName_1.environmentNameManager.getSandboxEnvName()) {
                const consent = await deployUtils_1.deployUtils.askForDeployConsentV3(ctx);
                if (consent.isErr()) {
                    return (0, teamsfx_api_1.err)(consent.error);
                }
            }
            const summaryReporter = new summary_1.SummaryReporter([projectModel.deploy], ctx.logProvider);
            let hasError = false;
            try {
                const steps = projectModel.deploy.driverDefs.length;
                if (inputs.platform !== teamsfx_api_1.Platform.CLI) {
                    ctx.progressBar = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar((0, localizeUtils_1.getLocalizedString)("core.progress.deploy"), steps);
                    await ((_b = ctx.progressBar) === null || _b === void 0 ? void 0 : _b.start());
                }
                const maybeDescription = summaryReporter.getLifecycleDescriptions();
                if (maybeDescription.isErr()) {
                    return (0, teamsfx_api_1.err)(maybeDescription.error);
                }
                ctx.logProvider.info(`Executing deploy ${os_1.EOL}${os_1.EOL}${maybeDescription.value}${os_1.EOL}`);
                const execRes = await projectModel.deploy.execute(ctx);
                summaryReporter.updateLifecycleState(0, execRes);
                const result = this.convertExecuteResult(execRes.result, templatePath);
                (0, lodash_1.merge)(output, result[0]);
                if (result[1]) {
                    hasError = true;
                    inputs.envVars = output;
                    return (0, teamsfx_api_1.err)(result[1]);
                }
                // show message box after deploy
                const botTroubleShootMsg = getBotTroubleShootMessage(false);
                const msg = (0, localizeUtils_1.getLocalizedString)("core.common.LifecycleComplete.deploy", steps, steps) +
                    botTroubleShootMsg.textForLogging;
                if (ctx.platform !== teamsfx_api_1.Platform.VS) {
                    (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", msg, false);
                }
            }
            finally {
                const summary = summaryReporter.getLifecycleSummary();
                ctx.logProvider.info(`Execution summary:${os_1.EOL}${os_1.EOL}${summary}${os_1.EOL}`);
                if (inputs.platform !== teamsfx_api_1.Platform.CLI) {
                    await ((_d = ctx.progressBar) === null || _d === void 0 ? void 0 : _d.end(!hasError));
                }
            }
        }
        else {
            return (0, teamsfx_api_1.err)(new yml_1.LifeCycleUndefinedError("deploy"));
        }
        return (0, teamsfx_api_1.ok)(output);
    }
    async publish(ctx, inputs) {
        var _a, _b, _c, _d, _e;
        const output = {};
        const templatePath = pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath);
        if (maybeProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        let hasError = false;
        if (projectModel.publish) {
            const summaryReporter = new summary_1.SummaryReporter([projectModel.publish], ctx.logProvider);
            try {
                const steps = projectModel.publish.driverDefs.length;
                ctx.progressBar = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar((0, localizeUtils_1.getLocalizedString)("core.progress.publish"), steps);
                await ((_b = ctx.progressBar) === null || _b === void 0 ? void 0 : _b.start());
                const maybeDescription = summaryReporter.getLifecycleDescriptions();
                if (maybeDescription.isErr()) {
                    hasError = true;
                    return (0, teamsfx_api_1.err)(maybeDescription.error);
                }
                ctx.logProvider.info(`Executing publish ${os_1.EOL}${os_1.EOL}${maybeDescription.value}${os_1.EOL}`);
                const execRes = await projectModel.publish.execute(ctx);
                const result = this.convertExecuteResult(execRes.result, templatePath);
                (0, lodash_1.merge)(output, result[0]);
                summaryReporter.updateLifecycleState(0, execRes);
                if (result[1]) {
                    hasError = true;
                    inputs.envVars = output;
                    return (0, teamsfx_api_1.err)(result[1]);
                }
                else {
                    const msg = (0, localizeUtils_1.getLocalizedString)("core.common.LifecycleComplete.publish", steps, steps);
                    const adminPortal = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.adminPortal");
                    if (ctx.platform !== teamsfx_api_1.Platform.CLI) {
                        (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", msg, false, adminPortal).then((value) => {
                            if (value.isOk() && value.value === adminPortal) {
                                void ctx.ui.openUrl(constants_4.Constants.TEAMS_ADMIN_PORTAL);
                            }
                        });
                    }
                    else {
                        (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", msg, false);
                    }
                }
            }
            finally {
                const summary = summaryReporter.getLifecycleSummary();
                ctx.logProvider.info(`Execution summary:${os_1.EOL}${os_1.EOL}${summary}${os_1.EOL}`);
                await ((_e = ctx.progressBar) === null || _e === void 0 ? void 0 : _e.end(!hasError));
            }
        }
        else {
            return (0, teamsfx_api_1.err)(new yml_1.LifeCycleUndefinedError("publish"));
        }
        return (0, teamsfx_api_1.ok)(output);
    }
    // @hooks([ErrorContextMW({ component: "Coordinator" })])
    // async share(
    //   ctx: DriverContext,
    //   inputs: InputsWithProjectPath
    // ): Promise<Result<DotenvParseOutput, FxError>> {
    //   const output: DotenvParseOutput = {};
    //   const templatePath = pathUtils.getYmlFilePath(ctx.projectPath, inputs.env) as string;
    //   const maybeProjectModel = await metadataUtil.parse(templatePath);
    //   if (maybeProjectModel.isErr()) {
    //     return err(maybeProjectModel.error);
    //   }
    //   const projectModel = maybeProjectModel.value;
    //   let hasError = false;
    //   if (projectModel.share) {
    //     const summaryReporter = new SummaryReporter([projectModel.share], ctx.logProvider);
    //     try {
    //       const steps = projectModel.share.driverDefs.length;
    //       ctx.progressBar = ctx.ui?.createProgressBar(
    //         getLocalizedString("core.progress.share"),
    //         steps
    //       );
    //       await ctx.progressBar?.start();
    //       const maybeDescription = summaryReporter.getLifecycleDescriptions();
    //       if (maybeDescription.isErr()) {
    //         hasError = true;
    //         return err(maybeDescription.error);
    //       }
    //       ctx.logProvider.info(`Executing share ${EOL}${EOL}${maybeDescription.value}${EOL}`);
    //       const execRes = await projectModel.share.execute(ctx);
    //       const result = this.convertExecuteResult(execRes.result, templatePath);
    //       merge(output, result[0]);
    //       summaryReporter.updateLifecycleState(0, execRes);
    //       if (result[1]) {
    //         hasError = true;
    //         inputs.envVars = output;
    //         return err(result[1]);
    //       } else {
    //         const msg = getLocalizedString("core.common.LifecycleComplete.share", steps, steps);
    //         ctx.ui?.showMessage("info", msg, false);
    //       }
    //     } finally {
    //       const summary = summaryReporter.getLifecycleSummary();
    //       ctx.logProvider.info(`Execution summary:${EOL}${EOL}${summary}${EOL}`);
    //       await ctx.progressBar?.end(!hasError);
    //     }
    //   } else {
    //     return err(new LifeCycleUndefinedError("share"));
    //   }
    //   return ok(output);
    // }
    async publishInDeveloperPortal(ctx, inputs) {
        // update teams app
        if (!ctx.tokenProvider) {
            return (0, teamsfx_api_1.err)(new common_1.InputValidationError("tokenProvider", "undefined"));
        }
        if (!inputs[constants_2.QuestionNames.AppPackagePath]) {
            return (0, teamsfx_api_1.err)(new common_1.InputValidationError("appPackagePath", "undefined"));
        }
        const updateRes = await (0, appStudio_1.updateTeamsAppV3ForPublish)(ctx, inputs);
        if (updateRes.isErr()) {
            return (0, teamsfx_api_1.err)(updateRes.error);
        }
        let loginHint = "";
        const accountRes = await ctx.tokenProvider.m365TokenProvider.getJsonObject({
            scopes: constants_1.AppStudioScopes,
        });
        if (accountRes.isOk()) {
            loginHint = accountRes.value.unique_name;
        }
        await ctx.userInteraction.openUrl(`https://dev.teams.cloud.microsoft/apps/${updateRes.value}/distributions/app-catalog?login_hint=${loginHint}&referrer=teamstoolkit_${inputs.platform}&client-preference=classic`);
        return (0, teamsfx_api_1.ok)(undefined);
    }
}
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "Coordinator" }),
        (0, actionExecutionMW_1.ActionExecutionMW)({
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.CreateProject,
            telemetryComponentName: "coordinator",
            errorSource: constants_3.CoordinatorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "create", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "preProvisionForVS", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "preCheckYmlAndEnvForVS", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "provision", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "deploy", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "publish", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "publishInDeveloperPortal", null);
exports.coordinator = new Coordinator();
function showAadResourceLink(ctx, isAadUpdateAction, projectModel, clientId) {
    var _a, _b;
    const gcPermission = "ExternalConnection.ReadWrite.OwnedBy";
    if (isAadUpdateAction &&
        clientId &&
        ((_a = projectModel.aadPermission) === null || _a === void 0 ? void 0 : _a.graphPermission.roles.includes(gcPermission))) {
        const aadUrl = `https://entra.microsoft.com/#view/Microsoft_AAD_RegisteredApps/ApplicationMenuBlade/~/CallAnAPI/appId/${clientId}/isMSAApp~/false`;
        const aadMsg = "You need to grant tenant-wide admin consent to the application in Entra ID. Click the button to provide consent.";
        const aadTitle = "View provisioned Entra ID";
        (_b = ctx.ui) === null || _b === void 0 ? void 0 : _b.showMessage("info", aadMsg, false, aadTitle).then((result) => {
            const userSelected = result.isOk() ? result.value : undefined;
            if (userSelected === aadTitle) {
                openUrl(ctx, aadUrl);
            }
        });
        ctx.logProvider.info(`You need to grant tenant-wide admin consent to the application in Entra ID. Use the link to provide the consent. ${aadUrl}`);
    }
    return;
}
exports.showAadResourceLink = showAadResourceLink;
function openUrl(ctx, url) {
    var _a;
    (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.openUrl(url);
}
exports.openUrl = openUrl;
function getBotTroubleShootMessage(isBot) {
    const botTroubleShootLink = "https://aka.ms/teamsfx-bot-help#how-can-i-troubleshoot-issues-when-teams-bot-isnt-responding-on-azure";
    const botTroubleShootDesc = (0, localizeUtils_1.getLocalizedString)("core.deploy.botTroubleShoot");
    const botTroubleShootLearnMore = (0, localizeUtils_1.getLocalizedString)("core.deploy.botTroubleShoot.learnMore");
    const botTroubleShootMsg = `${botTroubleShootDesc} ${botTroubleShootLearnMore}: ${botTroubleShootLink}.`;
    return {
        troubleShootLink: botTroubleShootLink,
        textForLogging: isBot ? botTroubleShootMsg : "",
        textForMsgBox: botTroubleShootDesc,
        textForActionButton: botTroubleShootLearnMore,
    };
}
function downloadSampleHook(sampleId, sampleAppPath) {
    // A temporary solution to aundefined duplicate componentId
    if (sampleId === "todo-list-SPFx") {
        const originalId = "c314487b-f51c-474d-823e-a2c3ec82b1ff";
        const componentId = uuid.v4();
        glob_1.glob.glob(`${sampleAppPath}/**/*.json`, { nodir: true, dot: true }, (err, files) => {
            void Promise.all(files.map(async (file) => {
                let content = (await fs_extra_1.default.readFile(file)).toString();
                const reg = new RegExp(originalId, "g");
                content = content.replace(reg, componentId);
                await fs_extra_1.default.writeFile(file, content);
            }));
        });
    }
}
//# sourceMappingURL=index.js.map