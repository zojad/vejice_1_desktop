"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeclarativeAgentGenerator = void 0;
const tslib_1 = require("tslib");
/**
 * @author yuqzho@microsoft.com
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const path_1 = tslib_1.__importDefault(require("path"));
const question_1 = require("../../../question");
const CopilotGptManifestUtils_1 = require("../../driver/teamsApp/utils/CopilotGptManifestUtils");
const common_1 = require("../../utils/common");
const defaultGenerator_1 = require("../defaultGenerator");
const generator_1 = require("../generator");
const templateNames_1 = require("../templates/templateNames");
const helper_1 = require("./helper");
const constants_1 = require("../../driver/teamsApp/constants");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const featureFlags_1 = require("../../../common/featureFlags");
const stringUtils_1 = require("../../../common/stringUtils");
const utils_1 = require("../utils");
/**
 * Generator for copilot extensions including declarative copilot with no plugin,
 * declarative copilot with API plugin from scratch, declarative copilot with existing plugin,
 * and API plugin from scratch.
 */
class DeclarativeAgentGenerator extends defaultGenerator_1.DefaultTemplateGenerator {
    constructor() {
        super(...arguments);
        this.componentName = "declarative-agent-from-scratch-generator";
    }
    activate(context, inputs) {
        return [
            templateNames_1.TemplateNames.DeclarativeAgentBasic,
            templateNames_1.TemplateNames.DeclarativeAgentWithActionFromScratch,
            templateNames_1.TemplateNames.DeclarativeAgentWithActionFromScratchBearer,
            templateNames_1.TemplateNames.DeclarativeAgentWithActionFromScratchOAuth,
            templateNames_1.TemplateNames.DeclarativeAgentWithExistingAction,
            templateNames_1.TemplateNames.DeclarativeAgentWithTypeSpec,
        ].includes(inputs[question_1.QuestionNames.TemplateName]);
    }
    async getTemplateInfos(context, inputs, destinationPath, actionContext) {
        const auth = inputs[question_1.QuestionNames.ApiAuth];
        const appName = inputs[question_1.QuestionNames.AppName];
        const language = inputs[question_1.QuestionNames.ProgrammingLanguage];
        const safeProjectNameFromVS = language === "csharp" ? inputs[question_1.QuestionNames.SafeProjectName] : undefined;
        const solutionNameFromVS = language === "csharp" ? inputs[question_1.QuestionNames.SolutionName] : undefined;
        const replaceMap = Object.assign(Object.assign({}, generator_1.Generator.getDefaultVariables(inputs[question_1.QuestionNames.TemplateName] === templateNames_1.TemplateNames.DeclarativeAgentWithTypeSpec
            ? (0, stringUtils_1.convertToAlphanumericOnly)(appName)
            : appName, safeProjectNameFromVS, solutionNameFromVS, inputs.targetFramework, inputs.placeProjectFileInSolutionDir === "true")), { DeclarativeCopilot: "true", MicrosoftEntra: auth === question_1.ApiAuthOptions.microsoftEntra().id ? "true" : "" });
        const templateName = inputs[question_1.QuestionNames.TemplateName];
        (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            ["template-name" /* telemetryProperties.templateName */]: templateName,
            ["is-microsoft-entra" /* telemetryProperties.isMicrosoftEntra */]: auth === question_1.ApiAuthOptions.microsoftEntra().id ? "true" : "",
            ["need-add-plugin-from-existing" /* telemetryProperties.needAddPluginFromExisting */]: inputs[question_1.QuestionNames.ActionType] === question_1.ActionStartOptions.existingPlugin().id.toString(),
        });
        return Promise.resolve((0, teamsfx_api_1.ok)([
            {
                templateName,
                language: language,
                replaceMap,
            },
        ]));
    }
    async post(context, inputs, destinationPath, actionContext) {
        const teamsManifestPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName);
        const declarativeCopilotManifestPathRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.getManifestPath(teamsManifestPath);
        if (declarativeCopilotManifestPathRes.isErr()) {
            // only return error in da existing action case
            if (templateNames_1.TemplateNames.DeclarativeAgentWithExistingAction === inputs[question_1.QuestionNames.TemplateName]) {
                return (0, teamsfx_api_1.err)(declarativeCopilotManifestPathRes.error);
            }
            return (0, teamsfx_api_1.ok)({});
        }
        if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.SensitivityLabelEnabled)) {
            // best-effort
            await (0, utils_1.setGeneralSensitivityLabel)(context, declarativeCopilotManifestPathRes.value);
        }
        if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.EmbeddedKnowledgeEnabled) &&
            (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VSCode)) {
            // ensure EmbeddedKnwoledge folder exists
            const embeddedKnowledgeFolderPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, constants_1.EmbeddedKnowledgeLocalDirectoryName);
            await fs_extra_1.default.ensureDir(embeddedKnowledgeFolderPath);
        }
        if (templateNames_1.TemplateNames.DeclarativeAgentWithExistingAction === inputs[question_1.QuestionNames.TemplateName]) {
            const addPluginRes = await (0, helper_1.addExistingPlugin)(declarativeCopilotManifestPathRes.value, inputs[question_1.QuestionNames.PluginManifestFilePath], inputs[question_1.QuestionNames.PluginOpenApiSpecFilePath], "action_1", context, this.componentName);
            if (addPluginRes.isErr()) {
                return (0, teamsfx_api_1.err)(addPluginRes.error);
            }
            else {
                if (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VS) {
                    const warningMessage = (0, common_1.outputScaffoldingWarningMessage)(addPluginRes.value.warnings);
                    if (warningMessage) {
                        context.logProvider.info(warningMessage);
                    }
                }
                return (0, teamsfx_api_1.ok)({ warnings: addPluginRes.value.warnings });
            }
        }
        else {
            return (0, teamsfx_api_1.ok)({});
        }
    }
}
exports.DeclarativeAgentGenerator = DeclarativeAgentGenerator;
//# sourceMappingURL=generator.js.map