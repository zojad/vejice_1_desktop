"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGraphConnectors = exports.getODSPItemInfo = exports.validateSourcePluginManifest = exports.addExistingPlugin = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const CopilotGptManifestUtils_1 = require("../../driver/teamsApp/utils/CopilotGptManifestUtils");
const PluginManifestUtils_1 = require("../../driver/teamsApp/utils/PluginManifestUtils");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const utils_1 = require("../../driver/teamsApp/utils/utils");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../utils/common");
const telemetry_1 = require("../../../common/telemetry");
const error_1 = require("../../../error");
const axios_1 = tslib_1.__importStar(require("axios"));
const constants_1 = require("../../../common/constants");
const oneDriveSharePointHandler_1 = require("./oneDriveSharePointHandler");
const globalVars_1 = require("../../../common/globalVars");
const logMessageKeys = {
    failValidateOneDriveSharePointItem: "core.createProjectQuestion.log.fail.validateOneDriveSharePointItem",
    invalidOneDriveSharePointURL: "core.createProjectQuestion.log.fail.invalidOneDriveSharePointURL",
};
const pluginManifestPlaceholderWarning = "add-exsiting-plugin-manifest-placehoder";
const apiSpecPlaceholderWarning = "add-exsiting-plugin-api-spec-placehoder";
const readApiSpecErrorTelemetry = "read-api-spec-error";
async function addExistingPlugin(declarativeCopilotManifestPath, fromPluginManifestPath, fromApiSpecPath, actionId, context, source) {
    var _a;
    const pluginManifestRes = await PluginManifestUtils_1.pluginManifestUtils.readPluginManifestFile(fromPluginManifestPath);
    if (pluginManifestRes.isErr()) {
        return (0, teamsfx_api_1.err)(pluginManifestRes.error);
    }
    const pluginManifest = pluginManifestRes.value;
    // prerequiste check
    const checkRes = validateSourcePluginManifest(pluginManifest, source);
    if (checkRes.isErr()) {
        return (0, teamsfx_api_1.err)(checkRes.error);
    }
    const runtimes = pluginManifest.runtimes; // have validated that the value exists.
    const destinationApiSpecRelativePath = runtimes.find((runtime) => runtime.type === "OpenApi")
        .spec.url; // have validated that the value exists.
    const outputFolder = path_1.default.dirname(declarativeCopilotManifestPath);
    // Copy OpenAPI spec
    const originalDestApiSPecRelativePath = path_1.default.resolve(outputFolder, destinationApiSpecRelativePath);
    let destinationApiSpecPath = originalDestApiSPecRelativePath;
    const needUpdatePluginManifest = (await fs_extra_1.default.pathExists(originalDestApiSPecRelativePath)) ||
        path_1.default.relative(outputFolder, originalDestApiSPecRelativePath).startsWith("..");
    if (needUpdatePluginManifest) {
        destinationApiSpecPath = await PluginManifestUtils_1.pluginManifestUtils.getDefaultNextAvailableApiSpecPath(fromApiSpecPath, path_1.default.join(outputFolder, teamsfx_api_1.DefaultApiSpecFolderName));
    }
    await fs_extra_1.default.ensureFile(destinationApiSpecPath);
    await fs_extra_1.default.copyFile(fromApiSpecPath, destinationApiSpecPath);
    // Save plugin manifest
    if (needUpdatePluginManifest) {
        const runtimeSpecUrl = (0, utils_1.normalizePath)(path_1.default.relative(outputFolder, destinationApiSpecPath), true);
        for (const runtime of runtimes) {
            if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
                runtime.spec.url = runtimeSpecUrl;
            }
        }
    }
    const destinationPluginManifestPath = await CopilotGptManifestUtils_1.copilotGptManifestUtils.getDefaultNextAvailablePluginManifestPath(outputFolder);
    await fs_extra_1.default.ensureFile(destinationPluginManifestPath);
    const pluginManifestContent = JSON.stringify(pluginManifest, undefined, 4);
    await fs_extra_1.default.writeFile(destinationPluginManifestPath, pluginManifestContent);
    // Update declarative copilot plugin manifest
    const addActionRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.addAction(declarativeCopilotManifestPath, actionId, (0, utils_1.normalizePath)(path_1.default.relative(outputFolder, destinationPluginManifestPath), true));
    if (addActionRes.isErr()) {
        return (0, teamsfx_api_1.err)(addActionRes.error);
    }
    const warnings = [];
    const pluginManifestVariables = (0, common_1.getEnvironmentVariables)(JSON.stringify(pluginManifest));
    if (pluginManifestVariables.length > 0) {
        warnings.push({
            type: pluginManifestPlaceholderWarning,
            content: (0, localizeUtils_1.getLocalizedString)("core.addPlugin.warning.manifestVariables", pluginManifestVariables.join(", ")),
        });
    }
    try {
        const apiSpecContent = await fs_extra_1.default.readFile(destinationApiSpecPath, "utf8");
        const apiSpecVariables = (0, common_1.getEnvironmentVariables)(apiSpecContent);
        if (apiSpecVariables.length > 0) {
            warnings.push({
                type: apiSpecPlaceholderWarning,
                content: (0, localizeUtils_1.getLocalizedString)("core.addPlugin.warning.apiSpecVariables", apiSpecVariables.join(", ")),
            });
        }
    }
    catch (e) {
        (0, telemetry_1.sendTelemetryErrorEvent)(source, readApiSpecErrorTelemetry, (0, error_1.assembleError)(e));
    }
    return (0, teamsfx_api_1.ok)({
        destinationPluginManifestPath,
        warnings,
    });
}
exports.addExistingPlugin = addExistingPlugin;
function validateSourcePluginManifest(manifest, source) {
    var _a;
    if (!manifest.schema_version) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MissingSchemaVersion", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "schema_version"), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "schema_version")));
    }
    if (!manifest.runtimes) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MissingRuntimes", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "runtimes"), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "runtimes")));
    }
    const apiSpecPaths = new Set();
    for (const runtime of manifest.runtimes) {
        if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
            apiSpecPaths.add(runtime.spec.url);
        }
    }
    if (apiSpecPaths.size === 0) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MissingApiSpec", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.pluginManifestMissingApiSpec", "OpenApi"), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.pluginManifestMissingApiSpec", "OpenApi")));
    }
    if (apiSpecPaths.size > 1) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MultipleApiSpecInPluginManifest", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.pluginManifestMultipleApiSpec", Array.from(apiSpecPaths).join(", ")), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.pluginManifestMultipleApiSpec", Array.from(apiSpecPaths).join(", "))));
    }
    return (0, teamsfx_api_1.ok)(undefined);
}
exports.validateSourcePluginManifest = validateSourcePluginManifest;
async function getODSPItemInfo(context, itemUrl) {
    var _a, _b;
    if (!itemUrl) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError("validateOneDriveSharePointItem", "InvalidInput", "Item URL is required"));
    }
    try {
        const graphClientResult = await (0, oneDriveSharePointHandler_1.createGraphClientWithToken)(context);
        if (graphClientResult.isErr()) {
            return (0, teamsfx_api_1.err)(graphClientResult.error);
        }
        const graphClient = graphClientResult.value;
        const siteResult = await (0, oneDriveSharePointHandler_1.getSharePointSiteByRelativePath)(graphClient, itemUrl);
        if (siteResult.isOk()) {
            const site = siteResult.value;
            return (0, teamsfx_api_1.ok)([
                {
                    id: site.id,
                    name: site.name,
                    webId: site.webId,
                    siteId: site.siteId,
                },
            ]);
        }
        const encodedUrl = (0, oneDriveSharePointHandler_1.encodeSharePointUrl)(itemUrl);
        const driveItem = await (0, oneDriveSharePointHandler_1.getDriveItemInfo)(graphClient, encodedUrl);
        return (0, teamsfx_api_1.ok)([
            {
                id: driveItem.id,
                name: driveItem.name,
                uniqueId: driveItem.uniqueId,
                listId: driveItem.listId,
                webId: driveItem.webId,
                siteId: driveItem.siteId,
                itemType: driveItem.itemType,
            },
        ]);
    }
    catch (error) {
        if ((0, axios_1.isAxiosError)(error) && error.response) {
            if (error.response.status >= 400 && error.response.status < 510) {
                (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.error((0, localizeUtils_1.getLocalizedString)(logMessageKeys.failValidateOneDriveSharePointItem, error.message));
                return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError("ValidateOneDriveSharePointURL", "GraphApiError", error.message, error.message));
            }
        }
        const message = JSON.stringify(error);
        (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.error((0, localizeUtils_1.getLocalizedString)(logMessageKeys.failValidateOneDriveSharePointItem, message));
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.SystemError("ValidateOneDriveSharePointURL", "GraphApiError", message, message));
    }
}
exports.getODSPItemInfo = getODSPItemInfo;
async function getGraphConnectors() {
    var _a;
    const context = (0, globalVars_1.createContext)();
    const graphTokenRes = await context.tokenProvider.m365TokenProvider.getAccessToken({
        scopes: constants_1.GCScopes,
    });
    if (graphTokenRes.isErr()) {
        throw graphTokenRes.error;
    }
    const graphToken = graphTokenRes.value;
    const instance = axios_1.default.create({
        baseURL: "https://graph.microsoft.com/v1.0",
        headers: { Authorization: `Bearer ${graphToken}` },
    });
    try {
        const res = await instance.get(`/external/connections`);
        const data = res.data;
        const result = data.value.map((item) => {
            return { id: item.id, label: item.id };
        });
        return result;
    }
    catch (error) {
        if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 403) {
            const err = new teamsfx_api_1.UserError("getCopilotConnectors", "GraphApiError", (0, localizeUtils_1.getDefaultString)("core.GCList.insufficientPermission"), (0, localizeUtils_1.getDefaultString)("core.GCList.insufficientPermission"));
            throw err;
        }
        else {
            const message = `Failed to get Copilot connector item: ${error instanceof Error ? error.message : String(error)}`;
            const err = new teamsfx_api_1.UserError("copilotConnectors", "GraphApiError", message, message);
            throw err;
        }
    }
}
exports.getGraphConnectors = getGraphConnectors;
//# sourceMappingURL=helper.js.map