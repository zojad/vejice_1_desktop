"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfficeAddinGeneratorNew = exports.getHost = exports.OfficeAddinGenerator = void 0;
/**
 * @author yefuwang@microsoft.com
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const office_addin_project_1 = require("office-addin-project");
const localizeUtils_1 = require("../../../common/localizeUtils");
const stringUtils_1 = require("../../../common/stringUtils");
const error_1 = require("../../../error");
const constants_1 = require("../../../question/constants");
const envUtil_1 = require("../../utils/envUtil");
const defaultGenerator_1 = require("../defaultGenerator");
const templateNames_1 = require("../templates/templateNames");
const helperMethods_1 = require("./helperMethods");
const metaOSHelper_1 = require("./metaOSHelper");
/**
 * case 1: project-type=office-xml-addin-type AND addin-host=outlook
 * case 2: project-type=office-addin-type (addin-host=undefined)
 * case 3: project-type=outlook-addin-type (addin-host=undefined)
 */
class OfficeAddinGenerator {
    static async doScaffolding(context, inputs, destinationPath) {
        const addinRoot = destinationPath;
        const fromFolder = inputs[constants_1.QuestionNames.OfficeAddinFolder];
        const workingDir = process.cwd();
        const importProgressStr = (0, localizeUtils_1.getLocalizedString)("core.generator.officeAddin.importOfficeProject.title");
        const importProgress = context.userInteraction.createProgressBar(importProgressStr, 3);
        process.chdir(addinRoot);
        try {
            if (fromFolder) {
                await importProgress.start();
                // from existing project
                await importProgress.next((0, localizeUtils_1.getLocalizedString)("core.generator.officeAddin.importProject.copyFiles"));
                helperMethods_1.HelperMethods.copyAddinFiles(fromFolder, addinRoot);
                const sourceManifestFile = inputs[constants_1.QuestionNames.OfficeAddinManifest];
                let manifestFile = sourceManifestFile.replace(fromFolder, addinRoot);
                await importProgress.next((0, localizeUtils_1.getLocalizedString)("core.generator.officeAddin.importProject.convertProject"));
                if (manifestFile.endsWith(".xml")) {
                    // Need to convert to json project first
                    await (0, office_addin_project_1.convertProject)(manifestFile, "./backup.zip", addinRoot, true);
                    manifestFile = manifestFile.replace(/\.xml$/, ".json");
                }
                inputs[constants_1.QuestionNames.OfficeAddinHost] = await getHost(manifestFile);
                await importProgress.next((0, localizeUtils_1.getLocalizedString)("core.generator.officeAddin.importProject.updateManifest"));
                await helperMethods_1.HelperMethods.updateManifest(destinationPath, manifestFile);
            }
            process.chdir(workingDir);
            await importProgress.end(true, true);
            return (0, teamsfx_api_1.ok)(undefined);
        }
        catch (e) {
            process.chdir(workingDir);
            await importProgress.end(false, true);
            return (0, teamsfx_api_1.err)((0, error_1.assembleError)(e));
        }
    }
}
exports.OfficeAddinGenerator = OfficeAddinGenerator;
async function getHost(addinManifestPath) {
    var _a, _b, _c;
    // Read add-in manifest file
    const addinManifest = (await teamsfx_api_1.ManifestUtil.loadFromPath(addinManifestPath));
    let host = "Outlook";
    switch ((_c = (_b = (_a = addinManifest.extensions) === null || _a === void 0 ? void 0 : _a[0].requirements) === null || _b === void 0 ? void 0 : _b.scopes) === null || _c === void 0 ? void 0 : _c[0]) {
        case "document":
            host = "Word";
            break;
        case "mail":
            host = "Outlook";
            break;
        // case "notebook":
        //   host = "OneNote";
        case "presentation":
            host = "PowerPoint";
            break;
        // case "project":
        //   host = "Project";
        case "workbook":
            host = "Excel";
            break;
    }
    return host;
}
exports.getHost = getHost;
class OfficeAddinGeneratorNew extends defaultGenerator_1.DefaultTemplateGenerator {
    constructor() {
        super(...arguments);
        this.componentName = "office-addin-generator";
    }
    // activation condition
    activate(context, inputs) {
        const templateName = inputs[constants_1.QuestionNames.TemplateName];
        return [
            templateNames_1.TemplateNames.OutlookTaskpane,
            templateNames_1.TemplateNames.WXPTaskpane,
            templateNames_1.TemplateNames.OfficeAddinCommon,
            templateNames_1.TemplateNames.DeclarativeAgentMetaOSNewProject,
            templateNames_1.TemplateNames.DeclarativeAgentMetaOSUpgradeProject,
        ].includes(templateName);
    }
    async getTemplateInfos(context, inputs, destinationPath, actionContext) {
        const templateName = inputs[constants_1.QuestionNames.TemplateName];
        // Handle the Declarative Agent MetaOS project
        if ([
            templateNames_1.TemplateNames.DeclarativeAgentMetaOSNewProject,
            templateNames_1.TemplateNames.DeclarativeAgentMetaOSUpgradeProject,
        ].includes(templateName)) {
            return Promise.resolve((0, teamsfx_api_1.ok)([
                {
                    templateName: templateName,
                    language: inputs[constants_1.QuestionNames.ProgrammingLanguage],
                },
            ]));
        }
        // Hanlde the MetaOS Project
        const res = await OfficeAddinGenerator.doScaffolding(context, inputs, destinationPath);
        if (res.isErr())
            return (0, teamsfx_api_1.err)(res.error);
        return Promise.resolve((0, teamsfx_api_1.ok)([
            {
                templateName: templateName,
                language: constants_1.ProgrammingLanguage.TS,
                replaceMap: { manifestId: (0, stringUtils_1.getUuid)() },
            },
        ]));
    }
    async post(context, inputs, destinationPath, actionContext) {
        // Handle the Declarative Agent MetaOS project
        if (templateNames_1.TemplateNames.DeclarativeAgentMetaOSUpgradeProject === inputs[constants_1.QuestionNames.TemplateName]) {
            try {
                await metaOSHelper_1.MetaOSHelper.copyExistMetaOSProject(inputs[constants_1.QuestionNames.OfficeAddinFolder], destinationPath);
                await metaOSHelper_1.MetaOSHelper.extendToDA(destinationPath, inputs[constants_1.QuestionNames.AppName]);
                await metaOSHelper_1.MetaOSHelper.unifyProjectID(destinationPath);
                return (0, teamsfx_api_1.ok)({});
            }
            catch (e) {
                return (0, teamsfx_api_1.err)(e.message);
            }
        }
        else if (templateNames_1.TemplateNames.DeclarativeAgentMetaOSNewProject === inputs[constants_1.QuestionNames.TemplateName]) {
            await metaOSHelper_1.MetaOSHelper.unifyProjectID(destinationPath);
            return (0, teamsfx_api_1.ok)({});
        }
        // Hanlde the MetaOS Project import
        const fromFolder = inputs[constants_1.QuestionNames.OfficeAddinFolder];
        if (fromFolder) {
            // reset all env files
            const envRes = await envUtil_1.envUtil.listEnv(destinationPath);
            if (envRes.isOk()) {
                const envs = envRes.value;
                for (const env of envs) {
                    await envUtil_1.envUtil.resetEnv(destinationPath, env, ["TEAMSFX_ENV", "APP_NAME_SUFFIX"]);
                }
            }
        }
        return (0, teamsfx_api_1.ok)({});
    }
}
exports.OfficeAddinGeneratorNew = OfficeAddinGeneratorNew;
//# sourceMappingURL=generator.js.map