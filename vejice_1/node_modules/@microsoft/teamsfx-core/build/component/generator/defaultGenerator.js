"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultGenerator = exports.DefaultTemplateGenerator = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
const featureFlags_1 = require("../../common/featureFlags");
const telemetry_1 = require("../../common/telemetry");
const versionMetadata_1 = require("../../common/versionMetadata");
const constants_1 = require("../../question/constants");
const messages_1 = require("../messages");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const constant_1 = require("./constant");
const generator_1 = require("./generator");
const generatorAction_1 = require("./generatorAction");
const metadata_1 = require("./templates/metadata");
const templateReplaceMap_1 = require("./templates/templateReplaceMap");
const utils_1 = require("./utils");
class DefaultTemplateGenerator {
    constructor() {
        // override this property to send telemetry event with different component name
        this.componentName = constant_1.componentName;
    }
    // override this method to determine whether to run this generator
    activate(context, inputs) {
        const templateName = inputs[constants_1.QuestionNames.TemplateName];
        const platform = inputs.platform;
        const templates = (0, metadata_1.getDefaultTemplatesOnPlatform)(platform);
        return templates.some((t) => t.name === templateName);
    }
    // The main entry of the generator. Do not override this method.
    async run(context, inputs, destinationPath, actionContext) {
        const preResult = await this.getTemplateInfos(context, inputs, destinationPath, actionContext);
        if (preResult.isErr())
            return (0, teamsfx_api_1.err)(preResult.error);
        const templateInfos = preResult.value;
        for (const templateInfo of templateInfos) {
            templateInfo.replaceMap = Object.assign(Object.assign({}, (0, templateReplaceMap_1.getTemplateReplaceMap)(inputs)), templateInfo.replaceMap);
            const templatePath = templateInfo.subFolder
                ? path.join(destinationPath, templateInfo.subFolder)
                : destinationPath;
            await this.scaffolding(context, inputs, templateInfo, templatePath, actionContext);
        }
        const postRes = await this.post(context, inputs, destinationPath, actionContext);
        return postRes;
    }
    // override this method to 1) do pre-step before template download and 2) provide information of templates to be downloaded
    getTemplateInfos(context, inputs, destinationPath, actionContext) {
        const templateName = inputs[constants_1.QuestionNames.TemplateName];
        const language = inputs[constants_1.QuestionNames.ProgrammingLanguage];
        return Promise.resolve((0, teamsfx_api_1.ok)([{ templateName, language }]));
    }
    // override this method to do post-step after template download
    post(context, inputs, destinationPath, actionContext) {
        return Promise.resolve((0, teamsfx_api_1.ok)({}));
    }
    async scaffolding(context, inputs, templateInfo, destinationPath, actionContext) {
        var _a, _b, _c;
        const name = templateInfo.templateName;
        const language = (_a = (0, utils_1.convertToLangKey)(templateInfo.language)) !== null && _a !== void 0 ? _a : constant_1.commonTemplateName;
        const replaceMap = templateInfo.replaceMap;
        const sandboxFilterFn = (fileName) => {
            if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.SandBoxedTeam)) {
                return true;
            }
            const sandboxFileList = [
                `${versionMetadata_1.MetadataV3.sandboxConfigFile}.tpl`,
                `${versionMetadata_1.MetadataV4.sandboxConfigFile}.tpl`,
                ".env.sandbox",
                ".env.sandbox.user.tpl",
            ];
            const parts = fileName.split("/");
            const extractedFileName = parts[parts.length - 1];
            return !sandboxFileList.includes(extractedFileName);
        };
        const filterFn = templateInfo.filterFn
            ? (fileName) => templateInfo.filterFn(fileName) && sandboxFilterFn(fileName)
            : sandboxFilterFn;
        const templateName = `${name}-${language}`;
        (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.TemplateName]: templateName,
        });
        const templateMetadata = (0, metadata_1.getAllTemplatesOnPlatform)(inputs.platform).find((t) => t.name === name);
        const folderName = (templateMetadata === null || templateMetadata === void 0 ? void 0 : templateMetadata.language) === "common" || (templateMetadata === null || templateMetadata === void 0 ? void 0 : templateMetadata.language) === "none"
            ? templateMetadata.id
            : (_b = templateMetadata === null || templateMetadata === void 0 ? void 0 : templateMetadata.id.substring(0, templateMetadata.id.lastIndexOf("-"))) !== null && _b !== void 0 ? _b : "";
        const generatorContext = {
            name: folderName,
            language: language,
            destination: destinationPath,
            logProvider: context.logProvider,
            platform: inputs.platform,
            fileNameReplaceFn: (fileName, fileData) => (0, utils_1.renderTemplateFileName)(fileName, fileData, replaceMap)
                .replace(/\\/g, "/")
                .replace(`${folderName}/`, ""),
            fileDataReplaceFn: (fileName, fileData) => (0, utils_1.renderTemplateFileData)(fileName, fileData, replaceMap),
            filterFn: (fileName) => fileName.replace(/\\/g, "/").startsWith(`${folderName}/`) && filterFn(fileName),
            onActionError: generator_1.templateDefaultOnActionError,
        };
        await ((_c = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _c === void 0 ? void 0 : _c.next(messages_1.ProgressMessages.generateTemplate));
        context.logProvider.debug(`Downloading app template "${templateName}" to ${destinationPath}`);
        await generator_1.Generator.generate(generatorContext, generatorAction_1.TemplateActionSeq);
        (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.Fallback]: generatorContext.fallback ? "true" : "false", // Track fallback cases.
        });
    }
}
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, actionExecutionMW_1.ActionExecutionMW)({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.create,
            progressSteps: 1,
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.GenerateTemplate,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], DefaultTemplateGenerator.prototype, "run", null);
exports.DefaultTemplateGenerator = DefaultTemplateGenerator;
exports.defaultGenerator = new DefaultTemplateGenerator();
//# sourceMappingURL=defaultGenerator.js.map