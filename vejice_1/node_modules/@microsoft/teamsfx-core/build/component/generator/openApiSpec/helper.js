"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAdaptiveCardInPluginManifestForKiota = exports.copyKiotaFolder = exports.getEnvName = exports.updateForCustomApi = exports.formatValidationErrors = exports.convertSpecParserErrorToFxError = exports.generateScaffoldingSummary = exports.injectAuthAction = exports.logValidationResults = exports.generateFromApiSpec = exports.listPluginExistingOperations = exports.listOperations = exports.invalidApiSpecErrorName = exports.specParserGenerateResultWarningsTelemetryProperty = exports.specParserGenerateResultAllSuccessTelemetryProperty = exports.specParserGenerateResultTelemetryEvent = exports.getParserOptions = void 0;
const tslib_1 = require("tslib");
/**
 * @author yuqzho@microsoft.com
 */
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const os_1 = require("os");
const path_1 = tslib_1.__importDefault(require("path"));
const util = tslib_1.__importStar(require("util"));
const constants_1 = require("../../../common/constants");
const featureFlags_1 = require("../../../common/featureFlags");
const localizeUtils_1 = require("../../../common/localizeUtils");
const telemetry_1 = require("../../../common/telemetry");
const error_1 = require("../../../error");
const constants_2 = require("../../../question/constants");
const actionInjector_1 = require("../../configManager/actionInjector");
const constant_1 = require("../../configManager/constant");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const PluginManifestUtils_1 = require("../../driver/teamsApp/utils/PluginManifestUtils");
const daSpecParser_1 = require("../../../common/daSpecParser");
const pathUtils_1 = require("../../utils/pathUtils");
function getParserOptions(type, isDeclarativeAgent, platform) {
    return type === m365_spec_parser_1.ProjectType.Copilot
        ? {
            isGptPlugin: isDeclarativeAgent,
            allowAPIKeyAuth: false,
            allowBearerTokenAuth: !!platform && platform === teamsfx_api_1.Platform.VS ? false : true,
            allowMultipleParameters: true,
            allowOauth2: !!platform && platform === teamsfx_api_1.Platform.VS ? false : true,
            projectType: m365_spec_parser_1.ProjectType.Copilot,
            allowMissingId: true,
            allowSwagger: true,
            allowMethods: [
                "get",
                "post",
                "put",
                "delete",
                "patch",
                "head",
                "connect",
                "options",
                "trace",
            ],
            allowResponseSemantics: true,
            allowConversationStarters: false,
            allowConfirmation: false, // confirmation is not stable for public preview in Sydney, so it's temporarily set to false
        }
        : type === m365_spec_parser_1.ProjectType.TeamsAi
            ? {
                allowAPIKeyAuth: true,
                allowBearerTokenAuth: true,
                allowMultipleParameters: true,
                allowOauth2: true,
                projectType: m365_spec_parser_1.ProjectType.TeamsAi,
                allowMethods: [
                    "get",
                    "post",
                    "put",
                    "delete",
                    "patch",
                    "head",
                    "connect",
                    "options",
                    "trace",
                ],
            }
            : {
                projectType: type,
                allowBearerTokenAuth: !!platform && platform === teamsfx_api_1.Platform.VS ? false : true,
                allowMultipleParameters: true,
                allowOauth2: featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.SMEOAuth),
            };
}
exports.getParserOptions = getParserOptions;
exports.specParserGenerateResultTelemetryEvent = "spec-parser-generate-result";
exports.specParserGenerateResultAllSuccessTelemetryProperty = "all-success";
exports.specParserGenerateResultWarningsTelemetryProperty = "warnings";
exports.invalidApiSpecErrorName = "invalid-api-spec";
const apiSpecNotUsedInPlugin = "api-spec-not-used-in-plugin";
async function listOperations(context, apiSpecUrl, inputs, includeExistingAPIs = true, shouldLogWarning = true, existingCorrelationId) {
    const isPlugin = inputs[constants_2.QuestionNames.ActionType] === constants_2.DeclarativeAgentApiSpecOptionId;
    const isCustomApi = inputs[constants_2.QuestionNames.CustomCopilotRag] === constants_2.CustomCopilotRagOptions.customApi().id;
    const projectType = isPlugin
        ? m365_spec_parser_1.ProjectType.Copilot
        : isCustomApi
            ? m365_spec_parser_1.ProjectType.TeamsAi
            : m365_spec_parser_1.ProjectType.SME;
    try {
        const specParser = new m365_spec_parser_1.SpecParser(apiSpecUrl, getParserOptions(projectType, undefined, inputs.platform));
        let validationRes;
        if (projectType === m365_spec_parser_1.ProjectType.Copilot) {
            validationRes = await (0, daSpecParser_1.validateOpenAPISpec)(apiSpecUrl, inputs.platform);
        }
        else {
            validationRes = await specParser.validate();
        }
        validationRes.errors = formatValidationErrors(validationRes.errors, inputs);
        logValidationResults(projectType, validationRes.errors, validationRes.warnings, context, shouldLogWarning, false, validationRes.specHash, existingCorrelationId);
        if (validationRes.status === m365_spec_parser_1.ValidationStatus.Error) {
            return (0, teamsfx_api_1.err)(validationRes.errors);
        }
        let listResult;
        if (projectType === m365_spec_parser_1.ProjectType.Copilot) {
            listResult = await (0, daSpecParser_1.listAPIInfo)(apiSpecUrl, inputs.platform);
        }
        else {
            listResult = await specParser.list();
        }
        const invalidAPIs = listResult.APIs.filter((value) => !value.isValid);
        for (const invalidAPI of invalidAPIs) {
            context.logProvider.warning(`${invalidAPI.api} ${(0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.list.unsupportedBecause")} ${invalidAPI.reason.map(mapInvalidReasonToMessage).join(", ")}`);
        }
        const bearerTokenAuthAPIs = listResult.APIs.filter((api) => api.auth && m365_spec_parser_1.Utils.isBearerTokenAuth(api.auth.authScheme));
        const oauth2AuthAPIs = listResult.APIs.filter((api) => api.auth && m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(api.auth.authScheme));
        const apiKeyAuthAPIs = listResult.APIs.filter((api) => api.auth && m365_spec_parser_1.Utils.isAPIKeyAuthButNotInCookie(api.auth.authScheme));
        const multipleAuthAPIs = listResult.APIs.filter((api) => { var _a; return api.auth && ((_a = api.auth.authScheme) === null || _a === void 0 ? void 0 : _a.type) === "multipleAuth"; });
        const noneAuthAPIs = listResult.APIs.filter((api) => !api.auth);
        const otherAuthAPIs = listResult.APIs.filter((api) => api.auth &&
            !m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(api.auth.authScheme) &&
            !m365_spec_parser_1.Utils.isBearerTokenAuth(api.auth.authScheme) &&
            !m365_spec_parser_1.Utils.isAPIKeyAuthButNotInCookie(api.auth.authScheme));
        let operations = listResult.APIs.filter((value) => value.isValid);
        context.telemetryReporter.sendTelemetryEvent("spec-parser-list-apis-result" /* telemetryEvents.listApis */, {
            ["generate-type" /* telemetryProperties.generateType */]: projectType.toString(),
            ["valid-apis-count" /* telemetryProperties.validApisCount */]: listResult.validAPICount.toString(),
            ["all-apis-count" /* telemetryProperties.allApisCount */]: listResult.allAPICount.toString(),
            ["is-from-adding-api" /* telemetryProperties.isFromAddingApi */]: (!includeExistingAPIs).toString(),
            ["bearer-token-auth-count" /* telemetryProperties.bearerTokenAuthCount */]: bearerTokenAuthAPIs.length.toString(),
            ["none-auth-count" /* telemetryProperties.noneAuthCount */]: noneAuthAPIs.length.toString(),
            ["multiple-auth-count" /* telemetryProperties.multipleAuthCount */]: multipleAuthAPIs.length.toString(),
            ["api-key-auth-count" /* telemetryProperties.apiKeyAuthCount */]: apiKeyAuthAPIs.length.toString(),
            ["oauth2-auth-count" /* telemetryProperties.oauth2AuthCount */]: oauth2AuthAPIs.length.toString(),
            ["other-auth-count" /* telemetryProperties.otherAuthCount */]: otherAuthAPIs.length.toString(),
            ["spec-hash" /* telemetryProperties.specHash */]: validationRes.specHash,
            [telemetry_1.TelemetryProperty.IsKiotaNPMIntegrationEnabled]: featureFlags_1.featureFlagManager
                .getBooleanValue(featureFlags_1.FeatureFlags.KiotaNPMIntegration)
                .toString(),
        });
        // Filter out exsiting APIs
        if (!includeExistingAPIs) {
            const teamsManifestPath = inputs[constants_2.QuestionNames.ManifestPath];
            if (!teamsManifestPath) {
                throw new error_1.MissingRequiredInputError("teamsManifestPath", "inputs");
            }
            const manifest = await ManifestUtils_1.manifestUtils._readAppManifest(teamsManifestPath);
            let existingOperations = [];
            if (manifest.isOk()) {
                let isOriginalSpec;
                if (isPlugin) {
                    existingOperations = await listPluginExistingOperations(manifest.value, teamsManifestPath, inputs[constants_2.QuestionNames.DestinationApiSpecFilePath]);
                    const operationAPIs = operations.map((operation) => operation.api);
                    isOriginalSpec = existingOperations.every((operation) => operationAPIs.includes(operation));
                }
                else {
                    const existingOperationIds = ManifestUtils_1.manifestUtils.getOperationIds(manifest.value);
                    existingOperations = operations
                        .filter((operation) => existingOperationIds.includes(operation.operationId))
                        .map((operation) => operation.api);
                    isOriginalSpec = existingOperations.length === existingOperationIds.length;
                }
                if (!isOriginalSpec) {
                    const errors = formatValidationErrors([
                        {
                            type: m365_spec_parser_1.ErrorType.AddedAPINotInOriginalSpec,
                            content: "",
                        },
                    ], inputs);
                    logValidationResults(projectType, errors, [], context, true, false, validationRes.specHash, existingCorrelationId);
                    return (0, teamsfx_api_1.err)(errors);
                }
                operations = operations.filter((operation) => !existingOperations.includes(operation.api));
                // No extra API can be added
                if (operations.length == 0) {
                    const errors = formatValidationErrors([
                        {
                            type: m365_spec_parser_1.ErrorType.NoExtraAPICanBeAdded,
                            content: "",
                        },
                    ], inputs);
                    logValidationResults(projectType, errors, [], context, true, false, validationRes.specHash, existingCorrelationId);
                    return (0, teamsfx_api_1.err)(errors);
                }
            }
            else {
                throw manifest.error;
            }
        }
        const sortedOperations = sortOperations(operations);
        return (0, teamsfx_api_1.ok)(sortedOperations);
    }
    catch (e) {
        if (e instanceof m365_spec_parser_1.SpecParserError) {
            throw convertSpecParserErrorToFxError(e);
        }
        else {
            throw e;
        }
    }
}
exports.listOperations = listOperations;
function sortOperations(operations) {
    const operationsWithSeparator = [];
    for (const operation of operations) {
        const arr = operation.api.toUpperCase().split(" ");
        const result = {
            id: operation.api,
            label: operation.api,
            groupName: arr[0],
            detail: !operation.auth
                ? (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.api.noAuth")
                : m365_spec_parser_1.Utils.isBearerTokenAuth(operation.auth.authScheme)
                    ? (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.api.apiKeyAuth")
                    : m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(operation.auth.authScheme)
                        ? (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.api.oauth")
                        : m365_spec_parser_1.Utils.isAPIKeyAuthButNotInCookie(operation.auth.authScheme)
                            ? (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.api.apiKeyWithHeaderOrQuery")
                            : (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.api.notSupportedAuth"),
            data: {
                serverUrl: operation.server,
            },
        };
        if (operation.auth) {
            if (m365_spec_parser_1.Utils.isBearerTokenAuth(operation.auth.authScheme) ||
                m365_spec_parser_1.Utils.isAPIKeyAuthButNotInCookie(operation.auth.authScheme)) {
                result.data.authType = "apiKey";
                result.data.authName = operation.auth.name;
            }
            else if (m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(operation.auth.authScheme)) {
                result.data.authType = "oauth2";
                result.data.authName = operation.auth.name;
            }
        }
        operationsWithSeparator.push(result);
    }
    return operationsWithSeparator.sort((operation1, operation2) => {
        const arr1 = operation1.id.toLowerCase().split(" ");
        const arr2 = operation2.id.toLowerCase().split(" ");
        return arr1[0] < arr2[0] ? -1 : arr1[0] > arr2[0] ? 1 : arr1[1].localeCompare(arr2[1]);
    });
}
function formatTelemetryValidationProperty(result) {
    return result.type.toString();
}
async function listPluginExistingOperations(manifest, teamsManifestPath, destinationApiSpecFilePath) {
    const getApiSPecFileRes = await PluginManifestUtils_1.pluginManifestUtils.getApiSpecFilePathFromTeamsManifest(manifest, teamsManifestPath);
    if (getApiSPecFileRes.isErr()) {
        throw getApiSPecFileRes.error;
    }
    let apiSpecFilePath;
    const apiSpecFiles = getApiSPecFileRes.value;
    for (const file of apiSpecFiles) {
        if (path_1.default.resolve(file) === path_1.default.resolve(destinationApiSpecFilePath)) {
            apiSpecFilePath = file;
            break;
        }
    }
    if (!apiSpecFilePath) {
        throw new teamsfx_api_1.UserError("listPluginExistingOperations", apiSpecNotUsedInPlugin, (0, localizeUtils_1.getLocalizedString)("error.copilotPlugin.apiSpecNotUsedInPlugin", destinationApiSpecFilePath), (0, localizeUtils_1.getLocalizedString)("error.copilotPlugin.apiSpecNotUsedInPlugin", destinationApiSpecFilePath));
    }
    const listResult = await (0, daSpecParser_1.listAPIInfo)(apiSpecFilePath);
    return listResult.APIs.map((o) => o.api);
}
exports.listPluginExistingOperations = listPluginExistingOperations;
async function generateFromApiSpec(specParser, teamsManifestPath, inputs, context, sourceComponent, projectType, outputFilePath, specPath, updateExistingPlugin = false) {
    const operations = inputs[constants_2.QuestionNames.ApiOperation];
    let validationRes;
    if (projectType === m365_spec_parser_1.ProjectType.Copilot) {
        validationRes = await (0, daSpecParser_1.validateOpenAPISpec)(specPath, inputs.platform);
    }
    else {
        validationRes = await specParser.validate();
    }
    const warnings = validationRes.warnings;
    const operationIdWarning = warnings.find((w) => w.type === m365_spec_parser_1.WarningType.OperationIdMissing);
    if (operationIdWarning && operationIdWarning.data) {
        const apisMissingOperationId = operationIdWarning.data.filter((api) => operations.includes(api));
        if (apisMissingOperationId.length > 0) {
            operationIdWarning.content = util.format((0, localizeUtils_1.getLocalizedString)("core.common.MissingOperationId"), apisMissingOperationId.join(", "));
            delete operationIdWarning.data;
        }
        else {
            warnings.splice(warnings.indexOf(operationIdWarning), 1);
        }
    }
    const specVersionWarning = warnings.find((w) => w.type === m365_spec_parser_1.WarningType.ConvertSwaggerToOpenAPI);
    if (specVersionWarning) {
        specVersionWarning.content = ""; // We don't care content of this warning
    }
    if (validationRes.status === m365_spec_parser_1.ValidationStatus.Error) {
        logValidationResults(projectType, validationRes.errors, warnings, context, false, true, validationRes.specHash);
        const errorMessage = inputs.platform === teamsfx_api_1.Platform.VSCode
            ? (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.multipleValidationErrors.vscode.message")
            : (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.multipleValidationErrors.message");
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(sourceComponent, exports.invalidApiSpecErrorName, errorMessage, errorMessage));
    }
    try {
        let adaptiveCardUpdateStrategy = m365_spec_parser_1.AdaptiveCardUpdateStrategy.CreateNew;
        if (sourceComponent === teamsfx_api_1.Stage.kiotaRegenerate) {
            adaptiveCardUpdateStrategy = m365_spec_parser_1.AdaptiveCardUpdateStrategy.KeepExisting;
        }
        const generateResult = projectType === m365_spec_parser_1.ProjectType.Copilot
            ? await (0, daSpecParser_1.generatePlugin)(specPath, teamsManifestPath, outputFilePath.destinationApiSpecFilePath, outputFilePath.pluginManifestFilePath, operations, adaptiveCardUpdateStrategy, inputs.platform, updateExistingPlugin)
            : await specParser.generate(teamsManifestPath, operations, outputFilePath.destinationApiSpecFilePath, projectType === m365_spec_parser_1.ProjectType.TeamsAi ? undefined : outputFilePath.responseTemplateFolder);
        // Send SpecParser.generate() warnings
        context.telemetryReporter.sendTelemetryEvent(exports.specParserGenerateResultTelemetryEvent, {
            ["generate-type" /* telemetryProperties.generateType */]: projectType.toString(),
            [exports.specParserGenerateResultAllSuccessTelemetryProperty]: generateResult.allSuccess.toString(),
            [exports.specParserGenerateResultWarningsTelemetryProperty]: generateResult.warnings
                .map((w) => `${w.type.toString()}: ${w.content}`)
                .join(";"),
            [telemetry_1.TelemetryProperty.Component]: sourceComponent,
            [telemetry_1.TelemetryProperty.IsKiotaNPMIntegrationEnabled]: featureFlags_1.featureFlagManager
                .getBooleanValue(featureFlags_1.FeatureFlags.KiotaNPMIntegration)
                .toString(),
        });
        if (generateResult.warnings && generateResult.warnings.length > 0) {
            generateResult.warnings.find((o) => {
                if (o.type === m365_spec_parser_1.WarningType.OperationOnlyContainsOptionalParam) {
                    o.content = ""; // We don't care content of this warning
                }
            });
            warnings.push(...generateResult.warnings);
        }
        return (0, teamsfx_api_1.ok)({ warnings });
    }
    catch (e) {
        let error;
        if (e instanceof m365_spec_parser_1.SpecParserError) {
            error = convertSpecParserErrorToFxError(e);
        }
        else {
            error = (0, error_1.assembleError)(e, sourceComponent);
        }
        return (0, teamsfx_api_1.err)(error);
    }
}
exports.generateFromApiSpec = generateFromApiSpec;
function logValidationResults(projectType, errors, warnings, context, shouldLogWarning, shouldSkipTelemetry, specHash, existingCorrelationId) {
    if (!shouldSkipTelemetry) {
        const properties = {
            ["validation-status" /* telemetryProperties.validationStatus */]: errors.length !== 0 ? "error" : warnings.length !== 0 ? "warning" : "success",
            ["validation-errors" /* telemetryProperties.validationErrors */]: errors
                .map((error) => formatTelemetryValidationProperty(error))
                .join(";"),
            ["validation-warnings" /* telemetryProperties.validationWarnings */]: warnings
                .map((warn) => formatTelemetryValidationProperty(warn))
                .join(";"),
            ["project-type" /* telemetryProperties.projectType */]: projectType.toString(),
        };
        if (specHash) {
            properties["spec-hash" /* telemetryProperties.specHash */] = specHash;
        }
        properties[telemetry_1.TelemetryProperty.IsKiotaNPMIntegrationEnabled] = featureFlags_1.featureFlagManager
            .getBooleanValue(featureFlags_1.FeatureFlags.KiotaNPMIntegration)
            .toString();
        const specNotValidError = errors.find((error) => error.type === m365_spec_parser_1.ErrorType.SpecNotValid);
        if (specNotValidError) {
            properties[telemetry_1.ApiSpecTelemetryPropertis.SpecNotValidDetails] = specNotValidError.content;
        }
        if (existingCorrelationId) {
            properties["correlation-id"] = existingCorrelationId;
        }
        context.telemetryReporter.sendTelemetryEvent("validate-api-spec" /* telemetryEvents.validateApiSpec */, properties);
    }
    if (errors.length === 0 && (warnings.length === 0 || !shouldLogWarning)) {
        return;
    }
    // errors > 0 || (warnings > 0 && shouldLogWarning)
    const errorMessage = errors
        .map((error) => {
        return `${constant_1.SummaryConstant.Failed} ${error.content}`;
    })
        .join(os_1.EOL);
    const warningMessage = shouldLogWarning
        ? warnings
            .map((warning) => {
            return `${constant_1.SummaryConstant.NotExecuted} ${warning.content}`;
        })
            .join(os_1.EOL)
        : "";
    const failed = errors.length;
    const warns = warnings.length;
    const summaryStr = [];
    if (failed > 0) {
        summaryStr.push((0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.validate.summary.validate.failed", failed));
    }
    if (warns > 0 && shouldLogWarning) {
        summaryStr.push((0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.validate.summary.validate.warning", warns));
    }
    const outputMessage = os_1.EOL +
        (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.validate.apiSpec.summary", summaryStr.join(", "), errorMessage, warningMessage);
    void context.logProvider.info(outputMessage);
}
exports.logValidationResults = logValidationResults;
async function injectAuthAction(projectPath, authName, authScheme, outputApiSpecPath, forceToAddNew, authType, enablePKCE, registrationId) {
    const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath);
    const localYamlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, "local", true);
    const relativeSpecPath = `./${path_1.default.relative(projectPath, outputApiSpecPath).replace(/\\/g, "/")}`;
    if ((!!authScheme &&
        (m365_spec_parser_1.Utils.isBearerTokenAuth(authScheme) || m365_spec_parser_1.Utils.isAPIKeyAuthButNotInCookie(authScheme))) ||
        authType === constant_1.APIKeyAuthType) {
        const res = await actionInjector_1.ActionInjector.injectCreateAPIKeyAction(ymlPath, authName, relativeSpecPath, forceToAddNew, registrationId);
        if (!!localYamlPath && (await fs_extra_1.default.pathExists(localYamlPath))) {
            await actionInjector_1.ActionInjector.injectCreateAPIKeyAction(localYamlPath, authName, relativeSpecPath, forceToAddNew, registrationId);
        }
        return res;
    }
    else if ((!!authScheme && m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(authScheme)) ||
        authType === constant_1.OAuthAuthType ||
        authType === constant_1.MicrosoftEntraAuthType) {
        const res = await actionInjector_1.ActionInjector.injectCreateOAuthAction(ymlPath, authName, relativeSpecPath, forceToAddNew, authType === constant_1.MicrosoftEntraAuthType, enablePKCE, registrationId);
        if (!!localYamlPath && (await fs_extra_1.default.pathExists(localYamlPath))) {
            await actionInjector_1.ActionInjector.injectCreateOAuthAction(localYamlPath, authName, relativeSpecPath, forceToAddNew, authType === constant_1.MicrosoftEntraAuthType, enablePKCE, registrationId);
        }
        return res;
    }
}
exports.injectAuthAction = injectAuthAction;
/**
 * Generate scaffolding warning summary.
 * @param warnings warnings returned from spec-parser.
 * @param teamsManifest Teams manifest.
 * @param apiSpecFilePath API spec path relative of project path.
 * @param pluginManifestPath Plugin manifest path relative of project path.
 * @param projectPath Project path.
 * @returns Warning message.
 */
async function generateScaffoldingSummary(warnings, teamsManifest, apiSpecFilePath, pluginManifestPath, projectPath) {
    const apiSpecWarningMessage = formatApiSpecValidationWarningMessage(warnings, apiSpecFilePath, teamsManifest);
    const manifestWarningResult = validateTeamsManifestLength(teamsManifest, warnings);
    const manifestWarningMessage = manifestWarningResult.map((warn) => {
        return `${constant_1.SummaryConstant.NotExecuted} ${warn}`;
    });
    let pluginWarningMessage = [];
    if (pluginManifestPath) {
        const pluginManifestWarningResult = await validatePluginManifestLength(pluginManifestPath, projectPath);
        pluginWarningMessage = pluginManifestWarningResult.map((warn) => {
            return `${constant_1.SummaryConstant.NotExecuted} ${warn}`;
        });
    }
    if (apiSpecWarningMessage.length ||
        manifestWarningMessage.length ||
        pluginWarningMessage.length) {
        let details = "";
        if (apiSpecWarningMessage.length) {
            details += os_1.EOL + apiSpecWarningMessage.join(os_1.EOL);
        }
        if (manifestWarningMessage.length) {
            details += os_1.EOL + manifestWarningMessage.join(os_1.EOL);
        }
        if (pluginWarningMessage.length) {
            details += os_1.EOL + pluginWarningMessage.join(os_1.EOL);
        }
        return (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary", details);
    }
    else {
        return "";
    }
}
exports.generateScaffoldingSummary = generateScaffoldingSummary;
function formatApiSpecValidationWarningMessage(specWarnings, apiSpecFileName, teamsManifest) {
    const resultWarnings = [];
    const operationIdWarning = specWarnings.find((w) => w.type === m365_spec_parser_1.WarningType.OperationIdMissing);
    if (operationIdWarning) {
        const isApiMe = ManifestUtils_1.manifestUtils.parseCommonProperties(teamsManifest).isApiME;
        resultWarnings.push((0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.operationId", `${constant_1.SummaryConstant.Info} ${operationIdWarning.content}`, isApiMe ? teamsfx_api_1.ManifestTemplateFileName : apiSpecFileName));
    }
    const swaggerWarning = specWarnings.find((w) => w.type === m365_spec_parser_1.WarningType.ConvertSwaggerToOpenAPI);
    if (swaggerWarning) {
        resultWarnings.push(`${constant_1.SummaryConstant.Info} ` +
            (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.swaggerVersion", apiSpecFileName));
    }
    const spec31Warning = specWarnings.find((w) => w.type === m365_spec_parser_1.WarningType.OpenAPI31ConvertTo30);
    if (spec31Warning) {
        resultWarnings.push(`${constant_1.SummaryConstant.Info} ` +
            (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.spec31ConvertTo30", apiSpecFileName));
    }
    const specialCharactersWarnings = specWarnings.filter((w) => w.type === m365_spec_parser_1.WarningType.OperationIdContainsSpecialCharacters);
    specialCharactersWarnings.forEach((warning) => {
        resultWarnings.push(`${constant_1.SummaryConstant.Info} ` +
            (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.operationIdContainsSpecialCharacters", warning.data, warning.data.replace(/[^a-zA-Z0-9]/g, "_")));
    });
    return resultWarnings;
}
function validateTeamsManifestLength(teamsManifest, warnings) {
    var _a, _b, _c, _d;
    const nameShortLimit = 30;
    const nameFullLimit = 100;
    const descriptionShortLimit = 80;
    const descriptionFullLimit = 4000;
    const appnameSuffixPlaceholder = "${{APP_NAME_SUFFIX}}";
    const devEnv = "dev";
    const resultWarnings = [];
    // validate name
    const shortNameLength = teamsManifest.name.short.includes(appnameSuffixPlaceholder)
        ? teamsManifest.name.short.length - appnameSuffixPlaceholder.length + devEnv.length
        : teamsManifest.name.short.length;
    if (shortNameLength > nameShortLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/name/short", nameShortLimit));
    }
    if (!!teamsManifest.name.full && ((_a = teamsManifest.name.full) === null || _a === void 0 ? void 0 : _a.length) > nameFullLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/name/full", nameFullLimit));
    }
    // validate description
    if (teamsManifest.description.short.length > descriptionShortLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/description/short", descriptionShortLimit));
    }
    if (!((_b = teamsManifest.description.full) === null || _b === void 0 ? void 0 : _b.length)) {
        resultWarnings.push((0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.teamsManifest.missingFullDescription") +
            (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.teamsManifest.mitigation", "full/description", path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName)));
    }
    if (teamsManifest.description.full.length > descriptionFullLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/description/full", descriptionFullLimit));
    }
    // validate command
    if (ManifestUtils_1.manifestUtils.parseCommonProperties(teamsManifest).isApiME) {
        const optionalParamsOnlyWarnings = warnings.filter((o) => o.type === m365_spec_parser_1.WarningType.OperationOnlyContainsOptionalParam);
        if (optionalParamsOnlyWarnings) {
            for (const optionalParamsOnlyWarning of optionalParamsOnlyWarnings) {
                resultWarnings.push((0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.api.optionalParametersOnly", optionalParamsOnlyWarning.data.commandId, optionalParamsOnlyWarning.data.commandId) +
                    (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.api.optionalParametersOnly.mitigation", optionalParamsOnlyWarning.data.parameterName, optionalParamsOnlyWarning.data.commandId, path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName), path_1.default.join(teamsfx_api_1.AppPackageFolderName, (_c = teamsManifest.composeExtensions[0].apiSpecificationFile) !== null && _c !== void 0 ? _c : "")));
            }
        }
        const commands = teamsManifest.composeExtensions[0].commands;
        for (const command of commands) {
            if (command.type === "query") {
                if (!command.apiResponseRenderingTemplateFile) {
                    const errorDetail = (_d = warnings.find((w) => w.type === m365_spec_parser_1.WarningType.GenerateCardFailed && w.data === command.id)) === null || _d === void 0 ? void 0 : _d.content;
                    resultWarnings.push((0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.teamsManifest.missingCardTemlate", "apiResponseRenderingTemplateFile", command.id) +
                        (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.teamsManifest.missingCardTemlate.mitigation", teamsfx_api_1.AppPackageFolderName, `composeExtensions/commands/${command.id}/apiResponseRenderingTemplateFile`, path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName)) +
                        (errorDetail ? os_1.EOL + errorDetail : ""));
                }
            }
        }
    }
    return resultWarnings;
}
async function validatePluginManifestLength(pluginManifestPath, projectPath) {
    const resultWarnings = [];
    const manifestRes = await PluginManifestUtils_1.pluginManifestUtils.readPluginManifestFile(path_1.default.join(projectPath, pluginManifestPath));
    if (manifestRes.isErr()) {
        (0, telemetry_1.sendTelemetryErrorEvent)("spec-generator", "failed-to-get-generate-warning" /* telemetryEvents.failedToGetGenerateWarning */, manifestRes.error);
        return [];
    }
    // validate function description
    const functions = manifestRes.value.functions;
    if (functions) {
        functions.forEach((func) => {
            if (!func.description) {
                resultWarnings.push((0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.pluginManifest.missingFunctionDescription", func.name) +
                    (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.pluginManifest.missingFunctionDescription.mitigation", func.name, pluginManifestPath));
            }
        });
    }
    return resultWarnings;
}
function formatLengthExceedingErrorMessage(field, limit) {
    return ((0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.teamsManifest.lengthExceeding", field, limit.toString()) +
        (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.teamsManifest.mitigation", field, path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName)));
}
function convertSpecParserErrorToFxError(error) {
    return new teamsfx_api_1.SystemError(constants_1.SpecParserSource, error.errorType.toString(), error.message, error.message);
}
exports.convertSpecParserErrorToFxError = convertSpecParserErrorToFxError;
function formatValidationErrors(errors, inputs) {
    return errors.map((error) => {
        return {
            type: error.type,
            content: formatValidationErrorContent(error, inputs),
            data: error.data,
        };
    });
}
exports.formatValidationErrors = formatValidationErrors;
function mapInvalidReasonToMessage(reason) {
    switch (reason) {
        case m365_spec_parser_1.ErrorType.AuthTypeIsNotSupported:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.AuthTypeIsNotSupported");
        case m365_spec_parser_1.ErrorType.MissingOperationId:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.MissingOperationId");
        case m365_spec_parser_1.ErrorType.PostBodyContainMultipleMediaTypes:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.PostBodyContainMultipleMediaTypes");
        case m365_spec_parser_1.ErrorType.ResponseContainMultipleMediaTypes:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.ResponseContainMultipleMediaTypes");
        case m365_spec_parser_1.ErrorType.ResponseJsonIsEmpty:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.ResponseJsonIsEmpty");
        case m365_spec_parser_1.ErrorType.PostBodyContainsRequiredUnsupportedSchema:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.PostBodyContainsRequiredUnsupportedSchema");
        case m365_spec_parser_1.ErrorType.ParamsContainRequiredUnsupportedSchema:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.ParamsContainRequiredUnsupportedSchema");
        case m365_spec_parser_1.ErrorType.ExceededRequiredParamsLimit:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.ExceededRequiredParamsLimit");
        case m365_spec_parser_1.ErrorType.NoParameter:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.NoParameter");
        case m365_spec_parser_1.ErrorType.NoAPIInfo:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.NoAPIInfo");
        case m365_spec_parser_1.ErrorType.MethodNotAllowed:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.MethodNotAllowed");
        case m365_spec_parser_1.ErrorType.UrlPathNotExist:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.UrlPathNotExist");
        case m365_spec_parser_1.ErrorType.CircularReferenceNotSupported:
            return (0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.CircularReference");
        default:
            return reason.toString();
    }
}
function formatValidationErrorContent(error, inputs) {
    const isPlugin = inputs[constants_2.QuestionNames.ActionType] === constants_2.DeclarativeAgentApiSpecOptionId;
    try {
        switch (error.type) {
            case m365_spec_parser_1.ErrorType.SpecNotValid: {
                let content = error.content;
                if (error.content.startsWith("ResolverError: Error downloading")) {
                    content = error.content
                        .split("\n")
                        .map((o) => o.trim())
                        .join(". ");
                    content = `${content}. ${(0, localizeUtils_1.getLocalizedString)("core.common.ErrorFetchApiSpec")}`;
                }
                return content;
            }
            case m365_spec_parser_1.ErrorType.RemoteRefNotSupported:
                return (0, localizeUtils_1.getLocalizedString)("core.common.RemoteRefNotSupported", error.data.join(", "));
            case m365_spec_parser_1.ErrorType.NoServerInformation:
                return (0, localizeUtils_1.getLocalizedString)("core.common.NoServerInformation");
            case m365_spec_parser_1.ErrorType.UrlProtocolNotSupported:
                return (0, localizeUtils_1.getLocalizedString)("core.common.UrlProtocolNotSupported", error.data);
            case m365_spec_parser_1.ErrorType.RelativeServerUrlNotSupported:
                return (0, localizeUtils_1.getLocalizedString)("core.common.RelativeServerUrlNotSupported");
            case m365_spec_parser_1.ErrorType.NoSupportedApi:
                const messages = [];
                const invalidAPIInfo = error.data;
                for (const info of invalidAPIInfo) {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    const mes = `${info.api}: ${info.reason.map(mapInvalidReasonToMessage).join(", ")}`;
                    messages.push(mes);
                }
                if (messages.length === 0) {
                    messages.push((0, localizeUtils_1.getLocalizedString)("core.common.invalidReason.NoAPIs"));
                }
                return isPlugin
                    ? (0, localizeUtils_1.getLocalizedString)("core.common.NoSupportedApiCopilot", messages.join("\n"))
                    : (0, localizeUtils_1.getLocalizedString)("core.common.NoSupportedApi", messages.join("\n"));
            case m365_spec_parser_1.ErrorType.NoExtraAPICanBeAdded:
                return isPlugin
                    ? (0, localizeUtils_1.getLocalizedString)("error.copilot.noExtraAPICanBeAdded")
                    : (0, localizeUtils_1.getLocalizedString)("error.apime.noExtraAPICanBeAdded");
            case m365_spec_parser_1.ErrorType.ResolveServerUrlFailed:
                return error.content;
            case m365_spec_parser_1.ErrorType.Cancelled:
                return (0, localizeUtils_1.getLocalizedString)("core.common.CancelledMessage");
            case m365_spec_parser_1.ErrorType.SwaggerNotSupported:
                return (0, localizeUtils_1.getLocalizedString)("core.common.SwaggerNotSupported");
            case m365_spec_parser_1.ErrorType.SpecVersionNotSupported:
                return (0, localizeUtils_1.getLocalizedString)("core.common.SpecVersionNotSupported", error.data);
            case m365_spec_parser_1.ErrorType.AddedAPINotInOriginalSpec:
                return (0, localizeUtils_1.getLocalizedString)("core.common.AddedAPINotInOriginalSpec");
            default:
                return error.content;
        }
    }
    catch (e) {
        return error.content;
    }
}
function parseSpec(spec) {
    const res = [];
    let needAuth = false;
    const paths = spec.paths;
    if (paths) {
        for (const pathUrl in paths) {
            const pathItem = paths[pathUrl];
            if (pathItem) {
                const operations = pathItem;
                for (const method in operations) {
                    if (m365_spec_parser_1.ConstantString.AllOperationMethods.includes(method)) {
                        const operationItem = operations[method];
                        if (operationItem) {
                            const authResult = m365_spec_parser_1.Utils.getAuthArray(operationItem.security, spec);
                            const hasAuth = authResult.length != 0;
                            if (hasAuth) {
                                needAuth = true;
                            }
                            res.push({
                                item: operationItem,
                                method: method,
                                pathUrl: pathUrl,
                                auth: hasAuth,
                            });
                        }
                    }
                }
            }
        }
    }
    return [res, needAuth];
}
const commonLanguages = [
    constants_2.ProgrammingLanguage.TS,
    constants_2.ProgrammingLanguage.JS,
    constants_2.ProgrammingLanguage.PY,
    constants_2.ProgrammingLanguage.CSharp,
];
async function updatePromptForCustomApi(spec, language, chatFolder, promptFileName) {
    if (commonLanguages.includes(language)) {
        const object = `{ "path": null, "body": null, "query": null }`;
        const cSharpObject = `{ "path": {}, "body": {}, "query": {} }`;
        const promptFilePath = path_1.default.join(chatFolder, promptFileName);
        const prompt = `The following is a conversation with an AI assistant.\nThe assistant can help to call APIs for the open api spec file${spec.info.description ? ". " + spec.info.description : "."}\nIf the API doesn't require parameters, invoke it with default JSON object ${language === constants_2.ProgrammingLanguage.CSharp ? cSharpObject : object}.\n\n${shouldGenerateTeamsAIV2Code(language) ? "context:\nAvailable actions: {{getAction}}." : ""}`;
        await fs_extra_1.default.writeFile(promptFilePath, prompt, { encoding: "utf-8", flag: "w" });
    }
}
async function updateAdaptiveCardForCustomApi(specItems, language, destinationPath) {
    const warnings = [];
    if (commonLanguages.includes(language)) {
        let adaptiveCardsFolderPath = path_1.default.join(destinationPath, "src", "adaptiveCards");
        if (language === constants_2.ProgrammingLanguage.CSharp) {
            adaptiveCardsFolderPath = path_1.default.join(destinationPath, "adaptiveCards");
        }
        await fs_extra_1.default.ensureDir(adaptiveCardsFolderPath);
        for (const item of specItems) {
            const name = item.item.operationId.replace(/[^a-zA-Z0-9]/g, "_");
            try {
                const [card, jsonPath, jsonData, generateWarnings] = m365_spec_parser_1.AdaptiveCardGenerator.generateAdaptiveCard(item.item, true, 5);
                if (jsonPath !== "$" && card.body && card.body[0] && card.body[0].$data) {
                    card.body[0].$data = `\${${jsonPath}}`;
                }
                const cardFilePath = path_1.default.join(adaptiveCardsFolderPath, `${name}.json`);
                const jsonDataPath = path_1.default.join(adaptiveCardsFolderPath, `${name}.data.json`);
                await fs_extra_1.default.writeFile(cardFilePath, JSON.stringify(card, null, 2));
                await fs_extra_1.default.writeFile(jsonDataPath, JSON.stringify(jsonData, null, 2));
                generateWarnings.forEach((w) => {
                    warnings.push({
                        type: m365_spec_parser_1.WarningType.GenerateJsonDataFailed,
                        // TODO: move message to package.nls.json file
                        content: util.format("Failed to create the adaptive card mock data for API '%s': %s. Mitigation: Not required but you can manually add it to the adaptiveCards folder.", item.item.operationId, w.content),
                        data: item.item.operationId,
                    });
                });
            }
            catch (err) {
                warnings.push({
                    type: m365_spec_parser_1.WarningType.GenerateCardFailed,
                    content: (0, localizeUtils_1.getLocalizedString)("core.copilotPlugin.scaffold.summary.warning.generate.ac.failed", item.item.operationId, err.message),
                    data: item.item.operationId,
                });
            }
        }
    }
    return warnings;
}
function filterSchema(schema) {
    const filteredSchema = { type: schema.type };
    if (schema.description) {
        filteredSchema.description = schema.description;
    }
    if (schema.type === "object" && schema.properties) {
        filteredSchema.properties = {};
        filteredSchema.required = schema.required;
        for (const key in schema.properties) {
            const property = schema.properties[key];
            if (property.type === "object") {
                filteredSchema.properties[key] = filterSchema(property);
                filteredSchema.required = schema.required;
            }
            else if (property.type === "array") {
                filteredSchema.properties[key] = {
                    type: "array",
                    items: filterSchema(property.items),
                    description: property.description,
                };
            }
            else {
                filteredSchema.properties[key] = {
                    type: property.type,
                    description: property.description,
                };
            }
        }
    }
    else if (schema.type === "array" && schema.items) {
        filteredSchema.items = filterSchema(schema.items);
    }
    return filteredSchema;
}
function shouldGenerateTeamsAIV2Code(language) {
    return language === constants_2.ProgrammingLanguage.JS || language === constants_2.ProgrammingLanguage.TS;
}
async function updateActionForCustomApi(specItems, language, chatFolder) {
    var _a, _b, _c;
    if (commonLanguages.includes(language)) {
        const actionsFilePath = path_1.default.join(chatFolder, shouldGenerateTeamsAIV2Code(language) ? "functions.json" : "actions.json");
        const actions = [];
        for (const item of specItems) {
            const parameters = {
                type: "object",
                properties: {},
                required: [],
            };
            const paramObject = item.item.parameters;
            if (paramObject) {
                for (let i = 0; i < paramObject.length; i++) {
                    const param = paramObject[i];
                    const schema = param.schema;
                    const paramType = param.in;
                    if (!parameters.properties[paramType]) {
                        parameters.properties[paramType] = {
                            type: "object",
                            properties: {},
                            required: [],
                        };
                    }
                    parameters.properties[paramType].properties[param.name] = filterSchema(schema);
                    parameters.properties[paramType].properties[param.name].description =
                        (_a = param.description) !== null && _a !== void 0 ? _a : "";
                    if (param.required) {
                        parameters.properties[paramType].required.push(param.name);
                        if (!parameters.required.includes(paramType)) {
                            parameters.required.push(paramType);
                        }
                    }
                }
            }
            const requestBody = item.item.requestBody;
            if (requestBody) {
                const content = requestBody.content;
                if (content) {
                    const contentSchema = content["application/json"].schema;
                    if (Object.keys(contentSchema).length !== 0) {
                        parameters.properties["body"] = filterSchema(contentSchema);
                        parameters.properties["body"].description = (_b = requestBody.description) !== null && _b !== void 0 ? _b : "";
                        if (requestBody.required) {
                            parameters.required.push("body");
                        }
                    }
                }
            }
            actions.push({
                name: item.item.operationId,
                description: (_c = item.item.description) !== null && _c !== void 0 ? _c : item.item.summary,
                parameters: parameters,
            });
        }
        if (shouldGenerateTeamsAIV2Code(language)) {
            // Convert actions array to object format for Teams AI v2
            const actionsObject = {};
            for (const action of actions) {
                if (action.name) {
                    actionsObject[action.name] = {
                        name: action.name,
                        description: action.description,
                        parameters: action.parameters,
                    };
                }
            }
            await fs_extra_1.default.writeFile(actionsFilePath, JSON.stringify(actionsObject, null, 2));
        }
        else {
            await fs_extra_1.default.writeFile(actionsFilePath, JSON.stringify(actions, null, 2));
        }
    }
}
const ActionCode = {
    python: `
@bot_app.ai.action("{{operationId}}")
async def {{operationId}}(
  context: ActionTurnContext[Dict[str, Any]],
  state: AppTurnState,
):
  parameters = context.data
  path = parameters.get("path", {})
  body = parameters.get("body", None)
  query = parameters.get("query", {})
  resp = client.{{operationId}}(**path, json=body, _headers={}, _params=query, _cookies={})

  if resp.status_code != 200:
    await context.send_activity(resp.reason)
  else:
    card_template_path = os.path.join(current_dir, 'adaptiveCards/{{operationId}}.json')
    if not os.path.exists(card_template_path):
      json_resoponse_str = resp.text
      await context.send_activity(json_resoponse_str)
    else:
      with open(card_template_path) as card_template_file:
        adaptive_card_template = card_template_file.read()

      renderer = AdaptiveCardRenderer(adaptive_card_template)

      json_resoponse_str = resp.text
      rendered_card_str = renderer.render(json_resoponse_str)
      rendered_card_json = json.loads(rendered_card_str)
      card = CardFactory.adaptive_card(rendered_card_json)
      isTeamsChannel = context.activity.channel_id == "msteams"
      message = MessageFactory.attachment(card)
      message.entities = [
        {
          "type": "https://schema.org/Message",
          "@type": "Message",
          "@context": "https://schema.org",
          "additionalType": ["AIGeneratedContent"],
        },
      ]
      message.channel_data = {
        "feedbackLoopEnabled": isTeamsChannel
      }
      
      await context.send_activity(message)
  return "success"
  `,
    cs: `
        [Action("{{operationId}}")]
        public async Task<string> {{functionName}}Async([ActionTurnContext] ITurnContext turnContext, [ActionTurnState] TurnState turnState, [ActionParameters] Dictionary<string, object> args)
        {
            try
            {
                RequestParams requestParam = ParseRequestParams(args);

                var response = await Client.CallAsync("{{apiPath}}", Method.{{apiMethod}}, requestParam);
                var data = response.Content;

                var cardTemplatePath = "./adaptiveCards/{{operationId}}.json";
                if (File.Exists(cardTemplatePath)) {
                    var message = RenderCardToMessage(cardTemplatePath, data);
                    await turnContext.SendActivityAsync(message);
                }
                else
                {
                    await turnContext.SendActivityAsync(data);
                }
            }
            catch (Exception ex) {
                await turnContext.SendActivityAsync("Failed to call API with error:  " + ex.Message);
            }

            return "complete";
        }`,
};
const functionDefinitionCode = {
    javascript: `.function(
      functionDefs.{{operationId}}.name,
      functionDefs.{{operationId}}.description,
      functionDefs.{{operationId}}.parameters,
      async (parameter) => {
        const result = await functionHandlers.{{operationId}}Handler(parameter);
        if(result) {
          await send(result);
          return "result showed";
        } else {
          return "no result";
        }
      }
  )`,
    typescript: `.function(
      functionDefs.{{operationId}}.name,
      functionDefs.{{operationId}}.description,
      functionDefs.{{operationId}}.parameters,
      async (parameter) => {
        const result = await functionHandlers.{{operationId}}Handler(parameter);
        if(result) {
          await send(result);
          return "result showed";
        } else {
          return "no result";
        }
      }
  )`,
};
const functionHandlerCode = {
    javascript: `const {{operationId}}Handler = async (
  parameters
) => {
  const client = await api.getClient();
  // Add authentication configuration for the client
  const apiPath = client.paths["{{pathUrl}}"];
  if (apiPath && apiPath.{{method}}) {
    const result = await apiPath.{{method}}(parameters.path, parameters.body, {
      params: parameters.query,
    });
    if (!result || !result.data) {
      throw new Error("Get empty result from api call.");
    }
    const cardName = "{{operationId}}".replace(/[^a-zA-Z0-9]/g, "_");
    const cardTemplatePath = path.join(__dirname, '../adaptiveCards', cardName + '.json');
    if (await fs.exists(cardTemplatePath)){
      const card = generateAdaptiveCard(cardTemplatePath, result);
      return card;
    } else {
      return JSON.stringify(result.data);
    }
  } else {
    return "";
  }

};

module.exports = { {{operationId}}Handler };`,
    typescript: `export const {{operationId}}Handler = async (
  parameter: any
) => {
  const client = await api.getClient();
  // Add authentication configuration for the client
  const apiPath = client.paths["{{pathUrl}}"];
  if (apiPath && apiPath.{{method}}) {
    const result = await apiPath.{{method}}(parameter.path, parameter.body, {
      params: parameter.query,
    });
    if (!result || !result.data) {
      throw new Error("Get empty result from api call.");
    }
    const cardName = "{{operationId}}".replace(/[^a-zA-Z0-9]/g, "_");
    const cardTemplatePath = path.join(__dirname, '../adaptiveCards', cardName + '.json');
    if (await fs.exists(cardTemplatePath)){
      const card = generateAdaptiveCard(cardTemplatePath, result);
      return card;
    } else {
      return JSON.stringify(result.data);
    }
  } else {
    return "";
  }
    
};`,
};
const AuthCode = {
    javascript: {
        actionCode: `addAuthConfig(client);`,
        actionPlaceholder: `// Add authentication configuration for the client`,
    },
    typescript: {
        actionCode: `addAuthConfig(client);`,
        actionPlaceholder: `// Add authentication configuration for the client`,
    },
};
async function updateCodeForCustomApi(specItems, language, destinationPath, openapiSpecFileName) {
    if (language === constants_2.ProgrammingLanguage.JS || language === constants_2.ProgrammingLanguage.TS) {
        const appFolderPath = path_1.default.join(destinationPath, "src", "app");
        const functionDefinitionTemplate = functionDefinitionCode[language === constants_2.ProgrammingLanguage.JS ? "javascript" : "typescript"];
        const functionHandlerTemplate = functionHandlerCode[language === constants_2.ProgrammingLanguage.JS ? "javascript" : "typescript"];
        const authCodeTemplate = AuthCode[language === constants_2.ProgrammingLanguage.JS ? "javascript" : "typescript"];
        const appFilePath = path_1.default.join(appFolderPath, language === constants_2.ProgrammingLanguage.JS ? "app.js" : "app.ts");
        const handlerFilePath = path_1.default.join(appFolderPath, language === constants_2.ProgrammingLanguage.JS ? "handlers.js" : "handlers.ts");
        const functionDefinitionsCode = [];
        const functionHandlersCode = [];
        for (const item of specItems) {
            const auth = item.auth;
            functionDefinitionsCode.push(functionDefinitionTemplate.replace(/{{operationId}}/g, item.item.operationId));
            functionHandlersCode.push(functionHandlerTemplate
                .replace(authCodeTemplate.actionPlaceholder, auth ? authCodeTemplate.actionCode : "")
                .replace(/{{operationId}}/g, item.item.operationId)
                .replace(/{{pathUrl}}/g, item.pathUrl)
                .replace(/{{method}}/g, item.method));
        }
        const appFileContent = (await fs_extra_1.default.readFile(appFilePath)).toString();
        const updatedAppFileContent = appFileContent.replace("// Replace with function definition code", `${functionDefinitionsCode.join("\n")};`);
        await fs_extra_1.default.writeFile(appFilePath, updatedAppFileContent);
        const handlerFileContent = (await fs_extra_1.default.readFile(handlerFilePath)).toString();
        const updatedHandlerFileContent = handlerFileContent
            .replace("{{OPENAPI_SPEC_PATH}}", openapiSpecFileName)
            .replace("// Replace with function handler code", functionHandlersCode.join("\t\t\n"));
        await fs_extra_1.default.writeFile(handlerFilePath, updatedHandlerFileContent);
    }
    else if (language === constants_2.ProgrammingLanguage.PY) {
        // Update code in bot.py
        const actionsCode = [];
        const codeTemplate = ActionCode["python"];
        for (const item of specItems) {
            const code = codeTemplate
                .replace(/{{operationId}}/g, item.item.operationId)
                .replace(/{{pathUrl}}/g, item.pathUrl)
                .replace(/{{method}}/g, item.method);
            actionsCode.push(code);
        }
        const botFilePath = path_1.default.join(destinationPath, "src", "bot.py");
        const botFileContent = (await fs_extra_1.default.readFile(botFilePath)).toString();
        const updateBotFileContent = botFileContent
            .replace("{{OPENAPI_SPEC_PATH}}", openapiSpecFileName)
            .replace("# Replace with action code", actionsCode.join("\n"));
        await fs_extra_1.default.writeFile(botFilePath, updateBotFileContent);
    }
    else if (language === constants_2.ProgrammingLanguage.CSharp) {
        const actionsCode = [];
        const codeTemplate = ActionCode["cs"];
        for (const item of specItems) {
            const code = codeTemplate
                .replace(/{{operationId}}/g, item.item.operationId)
                .replace(/{{apiPath}}/g, item.pathUrl)
                .replace(/{{apiMethod}}/g, m365_spec_parser_1.Utils.updateFirstLetter(item.method))
                .replace(/{{functionName}}/g, m365_spec_parser_1.Utils.updateFirstLetter(item.item.operationId));
            actionsCode.push(code);
        }
        const apiActionCsFilePath = path_1.default.join(destinationPath, "APIActions.cs");
        const apiActionCsFileContent = (await fs_extra_1.default.readFile(apiActionCsFilePath)).toString();
        const updateApiActionCsFileContent = apiActionCsFileContent
            .replace("{{OPENAPI_SPEC_PATH}}", "apiSpecificationFile/" + openapiSpecFileName)
            .replace("// Replace with action code", actionsCode.join("\n"));
        await fs_extra_1.default.writeFile(apiActionCsFilePath, updateApiActionCsFileContent);
        const files = await fs_extra_1.default.readdir(destinationPath);
        const projectFileName = files.find((file) => file.endsWith(".csproj"));
        const projectFilePath = path_1.default.join(destinationPath, projectFileName);
        const projectFileContent = (await fs_extra_1.default.readFile(projectFilePath)).toString();
        const updateProjectFileContent = projectFileContent.replace(/{{OPENAPI_SPEC_PATH}}/g, openapiSpecFileName);
        await fs_extra_1.default.writeFile(projectFilePath, updateProjectFileContent);
    }
}
async function updateForCustomApi(spec, language, destinationPath, openapiSpecFileName) {
    const warnings = [];
    let chatFolder = shouldGenerateTeamsAIV2Code(language)
        ? path_1.default.join(destinationPath, "src", "app")
        : path_1.default.join(destinationPath, "src", "prompts", "chat");
    if (language === constants_2.ProgrammingLanguage.CSharp) {
        chatFolder = path_1.default.join(destinationPath, "prompts", "Chat");
    }
    await fs_extra_1.default.ensureDir(chatFolder);
    // 1. update prompt folder
    await updatePromptForCustomApi(spec, language, chatFolder, shouldGenerateTeamsAIV2Code(language) ? "instructions.txt" : "skprompt.txt");
    const [specItems, needAuth] = parseSpec(spec);
    // 2. update adaptive card folder
    const generateWarnings = await updateAdaptiveCardForCustomApi(specItems, language, destinationPath);
    warnings.push(...generateWarnings);
    // 3. update actions file
    await updateActionForCustomApi(specItems, language, chatFolder);
    // 4. update code
    await updateCodeForCustomApi(specItems, language, destinationPath, openapiSpecFileName);
    // 5. add prompt suggestions
    const manifestPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName);
    await updatePromptSuggestions(specItems, manifestPath);
    return warnings;
}
exports.updateForCustomApi = updateForCustomApi;
async function updatePromptSuggestions(specItems, manifestPath) {
    const descriptions = specItems
        .map((item) => { var _a; return (_a = item.item.summary) !== null && _a !== void 0 ? _a : item.item.description; })
        .filter((item) => item !== undefined)
        .slice(0, 10);
    const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
    if (manifestRes.isOk()) {
        const manifest = manifestRes.value;
        manifest.bots[0].commandLists = [
            {
                scopes: [
                    "personal",
                    ...(featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.CEAEnabled)
                        ? ["copilot"]
                        : []),
                ],
                commands: [
                    ...descriptions.map((des) => {
                        return {
                            title: des.slice(0, 32),
                            description: des.slice(0, 128),
                        };
                    }),
                ],
            },
        ];
        await ManifestUtils_1.manifestUtils._writeAppManifest(manifest, manifestPath);
    }
    else {
        throw manifestRes.error;
    }
}
function getEnvName(authName) {
    return m365_spec_parser_1.Utils.getSafeRegistrationIdEnvName(`${authName}_${m365_spec_parser_1.ConstantString.RegistrationIdPostfix}`);
}
exports.getEnvName = getEnvName;
async function copyKiotaFolder(specPath, projectPath) {
    const originKiotaFolder = path_1.default.join(path_1.default.dirname(specPath), "..", ".kiota");
    if (!(await fs_extra_1.default.pathExists(originKiotaFolder))) {
        return;
    }
    const destinationKiotaFolder = path_1.default.join(projectPath, ".kiota");
    if (await fs_extra_1.default.pathExists(destinationKiotaFolder)) {
        return;
    }
    await fs_extra_1.default.ensureDir(destinationKiotaFolder);
    await fs_extra_1.default.copy(originKiotaFolder, destinationKiotaFolder, { recursive: true });
    return;
}
exports.copyKiotaFolder = copyKiotaFolder;
async function generateAdaptiveCardInPluginManifestForKiota(pluginManifestPath, specPath, context) {
    try {
        const operation = (await (0, daSpecParser_1.listAPIInfo)(specPath)).APIs.filter((value) => value.isValid).map((value) => value.api);
        const specParser = new m365_spec_parser_1.SpecParser(specPath, getParserOptions(m365_spec_parser_1.ProjectType.Copilot, true));
        await specParser.generateAdaptiveCardInPlugin(pluginManifestPath, operation, undefined);
    }
    catch (error) {
        // create ac error, should not block the whole process
        const errorMsg = (0, localizeUtils_1.getLocalizedString)("error.kiota.FailedToCreateAdaptiveCard");
        void context.userInteraction.showMessage("warn", errorMsg, false);
        context.logProvider.warning(errorMsg);
    }
}
exports.generateAdaptiveCardInPluginManifestForKiota = generateAdaptiveCardInPluginManifestForKiota;
//# sourceMappingURL=helper.js.map