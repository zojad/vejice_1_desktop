"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @author yuqzho@microsoft.com, Ning Tang
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateFilesFromApiSpec = exports.getTemplateInfosFromApiSpec = void 0;
const tslib_1 = require("tslib");
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const neverthrow_1 = require("neverthrow");
const path_1 = tslib_1.__importDefault(require("path"));
const stringUtils_1 = require("../../../common/stringUtils");
const utils_1 = require("../../../common/utils");
const question_1 = require("../../../question");
const constants_1 = require("../../../question/constants");
const CopilotGptManifestUtils_1 = require("../../driver/teamsApp/utils/CopilotGptManifestUtils");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const generator_1 = require("../generator");
const const_1 = require("./const");
const helper_1 = require("./helper");
const kiota_1 = require("./kiota");
function normalizePath(path) {
    return "./" + path.replace(/\\/g, "/");
}
async function handleWarnings(context, inputs, warnings, teamsManifest, destinationPath, openapiSpecPath, pluginManifestPath) {
    // log warnings
    if (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VS) {
        const warnSummary = await (0, helper_1.generateScaffoldingSummary)(warnings, teamsManifest, path_1.default.relative(destinationPath, openapiSpecPath), pluginManifestPath === undefined
            ? undefined
            : path_1.default.relative(destinationPath, pluginManifestPath), destinationPath);
        if (warnSummary) {
            context.logProvider.info(warnSummary);
        }
    }
    if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
        return (0, neverthrow_1.ok)({
            warnings: warnings.map((warning) => {
                return {
                    type: warning.type,
                    content: warning.content,
                    data: warning.data,
                };
            }),
        });
    }
    else {
        return (0, neverthrow_1.ok)({ warnings: undefined });
    }
}
async function getTemplateInfosFromApiSpec(context, inputs, projectType, actionContext) {
    var _a, _b, _c, _d, _e;
    const templateName = inputs[question_1.QuestionNames.TemplateName];
    (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
        ["template-name" /* telemetryProperties.templateName */]: templateName,
        ["is-declarative-copilot" /* telemetryProperties.isDeclarativeAgent */]: projectType === m365_spec_parser_1.ProjectType.Copilot ? "true" : "false",
    });
    let language = inputs[question_1.QuestionNames.ProgrammingLanguage];
    if (projectType !== m365_spec_parser_1.ProjectType.TeamsAi) {
        language =
            language === constants_1.ProgrammingLanguage.CSharp
                ? constants_1.ProgrammingLanguage.CSharp
                : constants_1.ProgrammingLanguage.None;
    }
    const safeProjectNameFromVS = language === constants_1.ProgrammingLanguage.CSharp ? inputs[question_1.QuestionNames.SafeProjectName] : undefined;
    const solutionNameFromVS = language === constants_1.ProgrammingLanguage.CSharp ? inputs[question_1.QuestionNames.SolutionName] : undefined;
    const url = inputs[question_1.QuestionNames.ApiSpecLocation].trim();
    const isYaml = !(await (0, utils_1.isJsonSpecFile)(url));
    const openapiSpecFileName = isYaml ? teamsfx_api_1.DefaultApiSpecYamlFileName : teamsfx_api_1.DefaultApiSpecJsonFileName;
    const llmServiceData = {
        llmService: inputs[question_1.QuestionNames.LLMService],
        openAIKey: inputs[question_1.QuestionNames.OpenAIKey],
        azureOpenAIKey: inputs[question_1.QuestionNames.AzureOpenAIKey],
        azureOpenAIEndpoint: inputs[question_1.QuestionNames.AzureOpenAIEndpoint],
        azureOpenAIDeploymentName: inputs[question_1.QuestionNames.AzureOpenAIDeploymentName],
    };
    const openapiSpecPath = (0, kiota_1.isKiotaIntegrated)(inputs)
        ? normalizePath(path_1.default.join(teamsfx_api_1.AppPackageFolderName, path_1.default.basename(inputs[question_1.QuestionNames.ApiSpecLocation])))
        : normalizePath(path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.DefaultApiSpecFolderName, openapiSpecFileName));
    const authData = (_a = (await (0, kiota_1.getAuthDataFromKiota)(context, inputs))) !== null && _a !== void 0 ? _a : inputs.apiAuthData;
    const convertedAuthData = [];
    if (authData && authData.length > 0) {
        for (const auth of authData) {
            const envName = (_b = auth.registrationId) !== null && _b !== void 0 ? _b : (0, helper_1.getEnvName)((_c = auth.authName) !== null && _c !== void 0 ? _c : "");
            convertedAuthData.push({
                authName: (_d = auth.authName) !== null && _d !== void 0 ? _d : "",
                openapiSpecPath: openapiSpecPath,
                registrationIdEnvName: envName,
                authType: auth.authType,
            });
        }
    }
    context.templateVariables = generator_1.Generator.getDefaultVariables(inputs[question_1.QuestionNames.AppName], safeProjectNameFromVS, solutionNameFromVS, inputs.targetFramework, inputs.placeProjectFileInSolutionDir === "true", convertedAuthData !== null && convertedAuthData !== void 0 ? convertedAuthData : [], llmServiceData);
    context.telemetryReporter.sendTelemetryEvent(const_1.declarativeAgentExistingApiSpecUrlTelemetryEvent, {
        ["remote-url" /* telemetryProperties.isRemoteUrlTelemetryProperty */]: (0, stringUtils_1.isValidHttpUrl)(url).toString(),
        ["generate-type" /* telemetryProperties.generateType */]: projectType.toString(),
        ["auth-type" /* telemetryProperties.authType */]: (_e = authData === null || authData === void 0 ? void 0 : authData.map((item) => item.authType).join(",")) !== null && _e !== void 0 ? _e : "None",
    });
    inputs.templateState = {
        isYaml: isYaml,
        templateName: templateName,
        url: url,
        isPlugin: projectType === m365_spec_parser_1.ProjectType.Copilot,
        type: projectType,
    };
    return (0, neverthrow_1.ok)([
        {
            templateName: templateName,
            language: language,
            replaceMap: Object.assign(Object.assign({}, context.templateVariables), { DeclarativeCopilot: projectType === m365_spec_parser_1.ProjectType.Copilot ? "true" : "" }),
        },
    ]);
}
exports.getTemplateInfosFromApiSpec = getTemplateInfosFromApiSpec;
async function generateFilesFromApiSpec(context, inputs, destinationPath, projectType, componentName) {
    const templateState = inputs.templateState;
    const isDeclarativeAgent = projectType === m365_spec_parser_1.ProjectType.Copilot;
    const isKiotaIntegration = (0, kiota_1.isKiotaIntegrated)(inputs);
    const manifestPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName);
    const apiSpecFolderPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, isKiotaIntegration ? "" : teamsfx_api_1.DefaultApiSpecFolderName);
    const openapiSpecFileName = isKiotaIntegration
        ? path_1.default.basename(inputs[question_1.QuestionNames.ApiSpecLocation])
        : templateState.isYaml
            ? teamsfx_api_1.DefaultApiSpecYamlFileName
            : teamsfx_api_1.DefaultApiSpecJsonFileName;
    let openapiSpecPath = path_1.default.join(apiSpecFolderPath, openapiSpecFileName);
    if (projectType === m365_spec_parser_1.ProjectType.TeamsAi) {
        const language = inputs[question_1.QuestionNames.ProgrammingLanguage];
        if (language === constants_1.ProgrammingLanguage.CSharp) {
            openapiSpecPath = path_1.default.join(destinationPath, teamsfx_api_1.DefaultApiSpecFolderName, openapiSpecFileName);
        }
    }
    await fs_extra_1.default.ensureDir(apiSpecFolderPath);
    const pluginManifestPath = templateState.type === m365_spec_parser_1.ProjectType.Copilot
        ? path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, isKiotaIntegration
            ? path_1.default.basename(inputs[question_1.QuestionNames.ActionManifestPath])
            : teamsfx_api_1.DefaultPluginManifestFileName)
        : undefined;
    const responseTemplateFolder = templateState.type === m365_spec_parser_1.ProjectType.SME
        ? path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ResponseTemplatesFolderName)
        : undefined;
    if (isKiotaIntegration) {
        return await (0, kiota_1.kiotaPostProcess)(context, inputs, destinationPath, openapiSpecPath, pluginManifestPath || "", manifestPath, templateState.type, isDeclarativeAgent);
    }
    const specParser = new m365_spec_parser_1.SpecParser(templateState.url, (0, helper_1.getParserOptions)(templateState.type, isDeclarativeAgent));
    const generateResult = await (0, helper_1.generateFromApiSpec)(specParser, manifestPath, inputs, context, componentName, templateState.type, {
        destinationApiSpecFilePath: openapiSpecPath,
        pluginManifestFilePath: pluginManifestPath,
        responseTemplateFolder,
    }, templateState.url);
    let warnings;
    if (generateResult.isErr()) {
        return (0, neverthrow_1.err)(generateResult.error);
    }
    else {
        warnings = generateResult.value.warnings;
    }
    if (isDeclarativeAgent) {
        const addActionResult = await CopilotGptManifestUtils_1.copilotGptManifestUtils.updateDeclarativeAgentManifest(manifestPath, const_1.defaultDeclarativeAgentManifestFileName, const_1.defaultDeclarativeAgentActionId, pluginManifestPath || "");
        if (addActionResult.isErr()) {
            return (0, neverthrow_1.err)(addActionResult.error);
        }
    }
    if (projectType === m365_spec_parser_1.ProjectType.TeamsAi) {
        const specs = await specParser.getFilteredSpecs(inputs[question_1.QuestionNames.ApiOperation]);
        const spec = specs[1];
        try {
            const language = inputs[question_1.QuestionNames.ProgrammingLanguage];
            const updateWarnings = await (0, helper_1.updateForCustomApi)(spec, language, destinationPath, openapiSpecFileName);
            warnings.push(...updateWarnings);
        }
        catch (error) {
            throw new teamsfx_api_1.SystemError(componentName, const_1.failedToUpdateCustomApiTemplateErrorName, error.message, error.message);
        }
    }
    const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
    if (manifestRes.isErr()) {
        return (0, neverthrow_1.err)(manifestRes.error);
    }
    const teamsManifest = manifestRes.value;
    return handleWarnings(context, inputs, warnings, teamsManifest, destinationPath, openapiSpecPath, pluginManifestPath);
}
exports.generateFilesFromApiSpec = generateFilesFromApiSpec;
//# sourceMappingURL=common.js.map