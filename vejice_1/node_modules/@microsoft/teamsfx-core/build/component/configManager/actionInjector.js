"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionInjector = void 0;
const tslib_1 = require("tslib");
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const yaml_1 = require("yaml");
const common_1 = require("../../error/common");
const constant_1 = require("./constant");
class ActionInjector {
    static hasActionWithName(provisionNode, action, name, specRelativePath) {
        const hasAuthAction = provisionNode.items.some((item) => item.get("uses") === action &&
            !!item.get("with") &&
            item.get("with").get("name") === name &&
            item.get("with").get("apiSpecPath") === specRelativePath);
        return hasAuthAction;
    }
    static getTeamsAppIdEnvName(provisionNode) {
        var _a;
        for (const item of provisionNode.items) {
            if (item.get("uses") === "teamsApp/create") {
                return (_a = item.get("writeToEnvironmentFile")) === null || _a === void 0 ? void 0 : _a.get("teamsAppId");
            }
        }
        return undefined;
    }
    static generateAuthAction(actionName, authName, teamsAppIdEnvName, specRelativePath, envName, flow, isMicrosoftEntra, enablePKCE) {
        const result = {
            uses: actionName,
            with: {
                name: `${authName}`,
                appId: `\${{${teamsAppIdEnvName}}}`,
                apiSpecPath: specRelativePath,
            },
        };
        if (flow) {
            result.with.flow = flow;
            result.writeToEnvironmentFile = {
                configurationId: envName,
            };
        }
        else {
            result.writeToEnvironmentFile = {
                registrationId: envName,
            };
        }
        if (enablePKCE) {
            result.with.isPKCEEnabled = true;
        }
        if (isMicrosoftEntra) {
            result.with.identityProvider = constant_1.MicrosoftEntraAuthType;
            result.writeToEnvironmentFile.applicationIdUri = m365_spec_parser_1.Utils.getSafeRegistrationIdEnvName(`${authName}_APPLICATION_ID_URI`);
        }
        return result;
    }
    static async injectCreateOAuthAction(ymlPath, authName, specRelativePath, forceToAddNew, // If it from add plugin, then we will add another CreateOAuthAction
    isMicrosoftEntra, enablePKCE, registrationId) {
        const ymlContent = await fs_extra_1.default.readFile(ymlPath, "utf-8");
        const actionName = "oauth/register";
        const document = (0, yaml_1.parseDocument)(ymlContent);
        const provisionNode = document.get("provision");
        if (provisionNode) {
            const hasOAuthAction = ActionInjector.hasActionWithName(provisionNode, actionName, authName, specRelativePath);
            if (!hasOAuthAction || forceToAddNew) {
                provisionNode.items = provisionNode.items.filter((item) => {
                    const uses = item.get("uses");
                    if (forceToAddNew) {
                        return uses;
                    }
                    else {
                        return (uses != actionName ||
                            !item.get("with") ||
                            item.get("with").get("apiSpecPath") !== specRelativePath ||
                            item.get("with").get("name") !== authName);
                    }
                });
                const existingConfigurationIdEnvNames = provisionNode.items
                    .filter((item) => {
                    const uses = item.get("uses");
                    return uses == actionName;
                })
                    .map((item) => { var _a; return (_a = item.get("writeToEnvironmentFile")) === null || _a === void 0 ? void 0 : _a.get("configurationId"); })
                    .filter((item) => {
                    return !!item;
                });
                const defaultEnvName = m365_spec_parser_1.Utils.getSafeRegistrationIdEnvName(`${authName}_${m365_spec_parser_1.ConstantString.RegistrationIdPostfix}`);
                const registrationIdEnvName = registrationId !== null && registrationId !== void 0 ? registrationId : this.findNextAvailableEnvName(defaultEnvName, existingConfigurationIdEnvNames);
                const teamsAppIdEnvName = ActionInjector.getTeamsAppIdEnvName(provisionNode);
                if (teamsAppIdEnvName) {
                    const index = provisionNode.items.findIndex((item) => item.get("uses") === "teamsApp/create");
                    const flow = "authorizationCode";
                    const action = ActionInjector.generateAuthAction(actionName, authName, teamsAppIdEnvName, specRelativePath, registrationIdEnvName, flow, isMicrosoftEntra, enablePKCE);
                    provisionNode.items.splice(index + 1, 0, action);
                }
                else {
                    throw new common_1.InjectOAuthActionFailedError();
                }
                await fs_extra_1.default.writeFile(ymlPath, document.toString(), "utf8");
                return {
                    defaultRegistrationIdEnvName: defaultEnvName,
                    registrationIdEnvName: registrationIdEnvName,
                };
            }
        }
        else {
            throw new common_1.InjectOAuthActionFailedError();
        }
        return undefined;
    }
    static async injectCreateAPIKeyAction(ymlPath, authName, specRelativePath, forceToAddNew, // If it from add plugin, then we will add another CreateApiKeyAction
    registrationId) {
        const ymlContent = await fs_extra_1.default.readFile(ymlPath, "utf-8");
        const actionName = "apiKey/register";
        const document = (0, yaml_1.parseDocument)(ymlContent);
        const provisionNode = document.get("provision");
        if (provisionNode) {
            const hasApiKeyAction = ActionInjector.hasActionWithName(provisionNode, actionName, authName, specRelativePath);
            if (!hasApiKeyAction || forceToAddNew) {
                provisionNode.items = provisionNode.items.filter((item) => {
                    const uses = item.get("uses");
                    if (forceToAddNew) {
                        return uses;
                    }
                    else {
                        return (uses != actionName ||
                            !item.get("with") ||
                            item.get("with").get("apiSpecPath") !== specRelativePath ||
                            item.get("with").get("name") !== authName);
                    }
                });
                const existingRegistrationIdEnvNames = provisionNode.items
                    .filter((item) => {
                    const uses = item.get("uses");
                    return uses == actionName;
                })
                    .map((item) => { var _a; return (_a = item.get("writeToEnvironmentFile")) === null || _a === void 0 ? void 0 : _a.get("registrationId"); })
                    .filter((item) => {
                    return !!item;
                });
                const teamsAppIdEnvName = ActionInjector.getTeamsAppIdEnvName(provisionNode);
                const defaultEnvName = m365_spec_parser_1.Utils.getSafeRegistrationIdEnvName(`${authName}_${m365_spec_parser_1.ConstantString.RegistrationIdPostfix}`);
                const registrationIdEnvName = registrationId !== null && registrationId !== void 0 ? registrationId : this.findNextAvailableEnvName(defaultEnvName, existingRegistrationIdEnvNames);
                if (teamsAppIdEnvName) {
                    const index = provisionNode.items.findIndex((item) => item.get("uses") === "teamsApp/create");
                    const action = ActionInjector.generateAuthAction(actionName, authName, teamsAppIdEnvName, specRelativePath, registrationIdEnvName);
                    provisionNode.items.splice(index + 1, 0, action);
                }
                else {
                    throw new common_1.InjectAPIKeyActionFailedError();
                }
                await fs_extra_1.default.writeFile(ymlPath, document.toString(), "utf8");
                return {
                    defaultRegistrationIdEnvName: defaultEnvName,
                    registrationIdEnvName: registrationIdEnvName,
                };
            }
        }
        else {
            throw new common_1.InjectAPIKeyActionFailedError();
        }
        return undefined;
    }
    static findNextAvailableEnvName(baseEnvName, existingEnvNames) {
        let suffix = 1;
        let envName = baseEnvName;
        while (existingEnvNames.includes(envName)) {
            envName = `${baseEnvName}${suffix}`;
            suffix++;
        }
        return envName;
    }
}
exports.ActionInjector = ActionInjector;
//# sourceMappingURL=actionInjector.js.map