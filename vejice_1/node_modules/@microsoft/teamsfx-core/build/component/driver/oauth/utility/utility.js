"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseScopes = exports.validateUrl = exports.validateSecret = exports.getAuthInfo = void 0;
const common_1 = require("../../../utils/common");
const lodash_1 = require("lodash");
const constants_1 = require("./constants");
const oauthDomainInvalid_1 = require("../error/oauthDomainInvalid");
const oauthFailedToGetDomain_1 = require("../error/oauthFailedToGetDomain");
const oauthAuthInfoInvalid_1 = require("../error/oauthAuthInfoInvalid");
const oauthAuthMissingInSpec_1 = require("../error/oauthAuthMissingInSpec");
const daSpecParser_1 = require("../../../../common/daSpecParser");
async function getAuthInfo(args, context, actionName) {
    if (args.baseUrl) {
        if (args.identityProvider === "MicrosoftEntra") {
            return {
                domain: [args.baseUrl],
            };
        }
        else if (args.authorizationUrl && args.tokenUrl) {
            return {
                domain: [args.baseUrl],
                authorizationEndpoint: args.authorizationUrl,
                tokenExchangeEndpoint: args.tokenUrl,
                tokenRefreshEndpoint: args.refreshUrl,
                scopes: parseScopes(args.scope), // optional
            };
        }
    }
    let authInfo = {};
    // when update, baseUrl and apiSpecPath are not required
    if (args.apiSpecPath) {
        authInfo = await getandValidateOauthInfoFromSpec(args, context, actionName);
    }
    if (args.baseUrl)
        authInfo.domain = [args.baseUrl];
    if (args.authorizationUrl)
        authInfo.authorizationEndpoint = args.authorizationUrl;
    if (args.tokenUrl)
        authInfo.tokenExchangeEndpoint = args.tokenUrl;
    if (args.refreshUrl)
        authInfo.tokenRefreshEndpoint = args.refreshUrl;
    if (args.scope)
        authInfo.scopes = parseScopes(args.scope);
    return authInfo;
}
exports.getAuthInfo = getAuthInfo;
async function getandValidateOauthInfoFromSpec(args, context, actionName) {
    const absolutePath = (0, common_1.getAbsolutePath)(args.apiSpecPath, context.projectPath);
    const listResult = await (0, daSpecParser_1.listAPIInfo)(absolutePath);
    const operations = listResult.APIs.filter((value) => {
        const auth = value.auth;
        return auth && auth.authScheme.type === "oauth2" && auth.name === args.name;
    });
    if (operations.length === 0) {
        throw new oauthAuthMissingInSpec_1.OauthAuthMissingInSpec(actionName, args.name);
    }
    const domains = operations
        .map((value) => {
        return value.server;
    })
        .filter((value, index, self) => {
        return self.indexOf(value) === index;
    });
    validateDomain(domains, actionName);
    // Need to separate the logic for different flows
    const flow = "flow" in args ? args.flow : "authorizationCode";
    const authInfoArray = operations
        .map((value) => {
        var _a;
        let authInfo;
        switch (flow) {
            case "authorizationCode":
            default:
                authInfo = ((_a = value.auth) === null || _a === void 0 ? void 0 : _a.authScheme).flows
                    .authorizationCode;
        }
        return {
            authorizationUrl: authInfo.authorizationUrl,
            tokenUrl: authInfo.tokenUrl,
            refreshUrl: authInfo.refreshUrl,
            scopes: Object.keys(authInfo.scopes),
        };
    })
        .reduce((accumulator, currentValue) => {
        if (!accumulator.find((item) => (0, lodash_1.isEqual)(item, currentValue))) {
            accumulator.push(currentValue);
        }
        return accumulator;
    }, []);
    if (authInfoArray.length !== 1) {
        throw new oauthAuthInfoInvalid_1.OauthAuthInfoInvalid(actionName);
    }
    const authInfo = authInfoArray[0];
    return {
        domain: domains,
        authorizationEndpoint: authInfo.authorizationUrl,
        tokenExchangeEndpoint: authInfo.tokenUrl,
        tokenRefreshEndpoint: authInfo.refreshUrl,
        scopes: authInfo.scopes,
    };
}
function validateSecret(clientSecret) {
    if (typeof clientSecret !== "string") {
        return false;
    }
    if (clientSecret.length > constants_1.maxSecretLength || clientSecret.length < constants_1.minSecretLength) {
        return false;
    }
    return true;
}
exports.validateSecret = validateSecret;
function validateDomain(domain, actionName) {
    if (domain.length > constants_1.maxDomainPerOauth) {
        throw new oauthDomainInvalid_1.OauthDomainInvalidError(actionName);
    }
    if (domain.length === 0 || domain.includes("")) {
        throw new oauthFailedToGetDomain_1.OauthFailedToGetDomainError(actionName);
    }
}
function validateUrl(baseUrl) {
    try {
        const url = new URL(baseUrl);
        return url.protocol === "https:";
    }
    catch (error) {
        return false;
    }
}
exports.validateUrl = validateUrl;
function parseScopes(scopes) {
    if (!scopes) {
        return undefined;
    }
    return scopes.split(",").map((scope) => scope.trim());
}
exports.parseScopes = parseScopes;
//# sourceMappingURL=utility.js.map