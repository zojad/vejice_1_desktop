"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeSpecCompileDriver = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const typedi_1 = require("typedi");
const daSpecParser_1 = require("../../../common/daSpecParser");
const kiotaClient_1 = require("../../../common/kiotaClient");
const localizeUtils_1 = require("../../../common/localizeUtils");
const versionMetadata_1 = require("../../../common/versionMetadata");
const common_1 = require("../../../error/common");
const helper_1 = require("../../generator/openApiSpec/helper");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const constants_1 = require("./constants");
const multipleActionError_1 = require("./error/multipleActionError");
const noSpecError_1 = require("./error/noSpecError");
const actionName = "typeSpec/compile"; // DO NOT MODIFY the name
let TypeSpecCompileDriver = class TypeSpecCompileDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.typeSpec.compile.description");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("driver.typeSpec.progressBar");
    }
    async execute(args, ctx, outputEnvVarNames) {
        var _a, _b, _c, _d, _e;
        const summaries = [];
        const outputs = new Map();
        try {
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info((0, localizeUtils_1.getLocalizedString)("driver.typeSpec.compile.start", actionName));
            this.validateArgs(args);
            const projectPath = ctx.projectPath;
            if (!projectPath) {
                throw new common_1.InputValidationError("projectPath", "undefined");
            }
            const mainFilePath = args.path;
            const outputFolderPath = path_1.default.isAbsolute(args.outputDir)
                ? args.outputDir
                : path_1.default.join(ctx.projectPath, args.outputDir);
            const openApiSpecsFolderPath = path_1.default.join(outputFolderPath, constants_1.defaultOpenApiOutputDir);
            const daManifestFilePath = path_1.default.join(outputFolderPath, constants_1.defaultDAManifestFileName);
            if ((_b = ctx.ui) === null || _b === void 0 ? void 0 : _b.runCommand) {
                // 0. Delete output folder if exists
                if (fs_extra_1.default.existsSync(outputFolderPath)) {
                    this.removeGeneratedFiles(outputFolderPath);
                }
                // 1. Compile tsp file to openapi spec and declarative agent manifest
                const tspRes = await ctx.ui.runCommand({
                    cmd: `npx --package=@typespec/compiler tsp compile ${mainFilePath} --config ${args.typeSpecConfigPath}`,
                    workingDirectory: projectPath,
                });
                if (tspRes.isErr()) {
                    throw tspRes.error;
                }
                // 2. Call Kiota to generate plugin manifest
                const openapiSpecs = fs_extra_1.default.readdirSync(openApiSpecsFolderPath);
                if (openapiSpecs.length === 0) {
                    throw new noSpecError_1.NoSpecError(actionName);
                }
                const daManifest = (await fs_extra_1.default.readJSON(daManifestFilePath));
                const actions = daManifest.actions;
                if (actions && actions.length > 0) {
                    if (openapiSpecs.length === 1) {
                        // only one openapi spec, the spac name should = openapi.yaml
                        const spec = openapiSpecs[0];
                        if (actions.length > 1) {
                            throw new multipleActionError_1.MultipleActionError(actionName);
                        }
                        const pluginManifestName = actions[0].id;
                        await (0, kiotaClient_1.kiotageneratePlugin)(`${openApiSpecsFolderPath}/${spec}`, `${outputFolderPath}`, `${pluginManifestName}`, `${outputFolderPath}`, undefined, undefined, undefined, undefined, true);
                    }
                    else {
                        for (const spec of openapiSpecs) {
                            const action = actions.find(
                            // action.id is the namespace (service name)
                            // spec name follows the pattern openapi.{service-name-if-multiple}.json
                            // directly match the action.id in the spec name here
                            (action) => spec.toLowerCase().includes(`.${action.id.toLowerCase()}.`));
                            if (!action) {
                                continue;
                            }
                            const pluginManifestName = action.id;
                            await (0, kiotaClient_1.kiotageneratePlugin)(`${openApiSpecsFolderPath}/${spec}`, `${outputFolderPath}`, `${pluginManifestName}`, `${outputFolderPath}`, undefined, undefined, undefined, undefined, true);
                        }
                    }
                }
                // 3. Update manifest
                const manifestFilePath = path_1.default.join(ctx.projectPath, args.manifestPath);
                const generatedManifestFilePath = path_1.default.join(outputFolderPath, path_1.default.basename(args.manifestPath));
                const manifest = (await fs_extra_1.default.readJSON(manifestFilePath));
                manifest.copilotAgents = manifest.copilotAgents || {};
                manifest.copilotAgents.declarativeAgents = manifest.copilotAgents.declarativeAgents || [];
                manifest.copilotAgents.declarativeAgents = [
                    {
                        file: constants_1.defaultDAManifestFileName,
                        id: "declarativeAgent",
                    },
                ];
                await fs_extra_1.default.writeJSON(generatedManifestFilePath, manifest, { spaces: 2 });
                // 4. If env exists in plugin manifest, update yaml file
                const generatedFolder = fs_extra_1.default.readdirSync(outputFolderPath);
                let showAlert = false;
                for (const file of generatedFolder) {
                    if (file.match(/[^-]+\-apiplugin\.json/)) {
                        const pluginManifestPath = path_1.default.join(outputFolderPath, file);
                        const authData = await (0, daSpecParser_1.parseAndUpdatePluginManifestForKiota)(pluginManifestPath, true);
                        for (const authInfo of authData) {
                            const addAuthRes = await (0, helper_1.injectAuthAction)(ctx.projectPath, authInfo.authName, undefined, path_1.default.join(outputFolderPath, authInfo.specPath), false, authInfo.authType === "apiKey" ? "ApiKeyPluginVault" : "OAuthPluginVault", false, authInfo.registrationId);
                            if (addAuthRes) {
                                showAlert = true;
                            }
                        }
                    }
                }
                if (showAlert) {
                    void ctx.ui.showMessage("warn", (0, localizeUtils_1.getLocalizedString)("driver.typeSpec.compile.reprovision", versionMetadata_1.MetadataV4.configFile), false);
                    return {
                        result: (0, teamsfx_api_1.err)(new common_1.NeedRedoError(actionName)),
                        summaries: summaries,
                    };
                }
            }
            if (ctx.platform === teamsfx_api_1.Platform.VSCode) {
                ctx.logProvider.outputChannel.show();
            }
            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info((0, localizeUtils_1.getLocalizedString)("driver.aadApp.log.successExecuteDriver", actionName));
            return {
                result: (0, teamsfx_api_1.ok)(outputs),
                summaries: summaries,
            };
        }
        catch (error) {
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                (_d = ctx.logProvider) === null || _d === void 0 ? void 0 : _d.error((0, localizeUtils_1.getLocalizedString)("driver.aadApp.log.failExecuteDriver", actionName, error.displayMessage));
                return {
                    result: (0, teamsfx_api_1.err)(error),
                    summaries: summaries,
                };
            }
            const message = JSON.stringify(error);
            (_e = ctx.logProvider) === null || _e === void 0 ? void 0 : _e.error((0, localizeUtils_1.getLocalizedString)("driver.aadApp.log.failExecuteDriver", actionName, message));
            return {
                result: (0, teamsfx_api_1.err)((0, common_1.assembleError)(error, actionName)),
                summaries: summaries,
            };
        }
    }
    validateArgs(args) {
        const invalidParameters = [];
        if (typeof args.path !== "string" || !args.path) {
            invalidParameters.push("path");
        }
        if (typeof args.manifestPath !== "string" || !args.manifestPath) {
            invalidParameters.push("manifestPath");
        }
        if (typeof args.outputDir !== "string" || !args.outputDir) {
            invalidParameters.push("outputDir");
        }
        if (typeof args.typeSpecConfigPath !== "string" || !args.typeSpecConfigPath) {
            invalidParameters.push("typeSpecConfigPath");
        }
        if (invalidParameters.length > 0) {
            throw new common_1.InvalidActionInputError(actionName, invalidParameters, constants_1.helpLink);
        }
    }
    removeGeneratedFiles(outputFolderPath) {
        const files = fs_extra_1.default.readdirSync(outputFolderPath);
        for (const file of files) {
            if (file === constants_1.defaultOpenApiOutputDir || file === ".kiota") {
                const folderPath = path_1.default.join(outputFolderPath, file);
                fs_extra_1.default.rmSync(folderPath, { recursive: true, force: true });
            }
            if (file === constants_1.defaultDAManifestFileName ||
                file.match(/[^-]+\-apiplugin\.json/) ||
                file.match(/[^-]+\-openapi\.json/) ||
                file.match(/[^-]+\-openapi\.yaml/) ||
                file.match(/[^-]+\-openapi\.yml/)) {
                const filePath = path_1.default.join(outputFolderPath, file);
                fs_extra_1.default.rmSync(filePath);
            }
        }
    }
};
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Map]),
    tslib_1.__metadata("design:returntype", Promise)
], TypeSpecCompileDriver.prototype, "execute", null);
TypeSpecCompileDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(actionName) // DO NOT MODIFY the service name
], TypeSpecCompileDriver);
exports.TypeSpecCompileDriver = TypeSpecCompileDriver;
//# sourceMappingURL=compile.js.map