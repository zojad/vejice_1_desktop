"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateDevChannelDriver = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = require("typedi");
const axios_1 = tslib_1.__importDefault(require("axios"));
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../util/wrapUtil");
const localizeUtils_1 = require("../../../common/localizeUtils");
const graphClient_1 = require("../../../client/graphClient");
const common_1 = require("../../../error/common");
const utils_1 = require("../util/utils");
const telemetry_1 = require("../../../common/telemetry");
const actionName = "devChannel/create";
let CreateDevChannelDriver = class CreateDevChannelDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.devChannel.description");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("driver.devChannel.progress.message");
    }
    async execute(args, context, outputEnvVarNames) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.create(args, wrapContext, outputEnvVarNames);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async create(args, context, outputEnvVarNames) {
        // Skip creation if the team and channel already exist
        const state = (0, utils_1.loadStateFromEnv)(outputEnvVarNames);
        const graphClient = new graphClient_1.GraphClient(context.m365TokenProvider);
        try {
            if (state.teamId && state.channelId) {
                const message = (0, localizeUtils_1.getLocalizedString)("driver.devChannel.summary.exists", outputEnvVarNames.get("teamId"), outputEnvVarNames.get("channelId"));
                context.logProvider.info(message);
                context.addSummary(message);
                context.addTelemetryProperties({ [telemetry_1.TelemetryProperty.SkipCreation]: "true" });
                // Update the channel web URL, incase user manually modify teamId or channelId
                state.channelWebUrl = await graphClient.GetChannelDeeplinkAsync(state.teamId, state.channelId);
                const outputs = (0, utils_1.mapStateToEnv)(state, outputEnvVarNames);
                return (0, teamsfx_api_1.ok)(outputs);
            }
            const res = await graphClient.CreateTeamAndChannelAsync(args.teamName, args.teamDescription, args.channelName);
            state.channelId = res.channelId;
            state.teamId = res.teamId;
            context.logProvider.info((0, localizeUtils_1.getLocalizedString)("driver.devChannel.success", args.teamName, args.channelName, state.channelId, state.teamId));
            context.addSummary((0, localizeUtils_1.getLocalizedString)("driver.devChannel.summary", args.teamName, args.channelName));
            state.channelWebUrl = await graphClient.GetChannelDeeplinkAsync(state.teamId, state.channelId);
            const outputs = (0, utils_1.mapStateToEnv)(state, outputEnvVarNames);
            return (0, teamsfx_api_1.ok)(outputs);
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error)) {
                const message = JSON.stringify(error.response.data);
                context.logProvider.error(message);
                return (0, teamsfx_api_1.err)(new common_1.HttpClientError(error, actionName, message));
            }
            else {
                return (0, teamsfx_api_1.err)(error);
            }
        }
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext,
        Map]),
    tslib_1.__metadata("design:returntype", Promise)
], CreateDevChannelDriver.prototype, "create", null);
CreateDevChannelDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(actionName)
], CreateDevChannelDriver);
exports.CreateDevChannelDriver = CreateDevChannelDriver;
//# sourceMappingURL=create.js.map