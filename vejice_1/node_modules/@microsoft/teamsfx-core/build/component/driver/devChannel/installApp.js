"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstallAppToChannelDriver = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = require("typedi");
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../util/wrapUtil");
const localizeUtils_1 = require("../../../common/localizeUtils");
const graphClient_1 = require("../../../client/graphClient");
const common_1 = require("../../../error/common");
const common_2 = require("../../../error/common");
const constants_1 = require("../teamsApp/constants");
const telemetry_1 = require("../../../common/telemetry");
const errors_1 = require("./errors");
const actionName = "devChannel/installApp";
let InstallAppToChannelDriver = class InstallAppToChannelDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.devChannel.install.description");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("driver.devChannel.install.progress.message");
    }
    async execute(args, context, outputEnvVarNames) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.install(args, wrapContext, outputEnvVarNames);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async install(args, context, outputEnvVarNames) {
        const argsValidationResult = this.validateArgs(args);
        if (argsValidationResult.isErr()) {
            return (0, teamsfx_api_1.err)(argsValidationResult.error);
        }
        let appPackagePath = args.appPackagePath;
        if (!path.isAbsolute(appPackagePath)) {
            appPackagePath = path.join(context.projectPath, appPackagePath);
        }
        if (!(await fs_extra_1.default.pathExists(appPackagePath))) {
            return (0, teamsfx_api_1.err)(new common_2.FileNotFoundError(actionName, appPackagePath));
        }
        const archivedFile = await fs_extra_1.default.readFile(appPackagePath);
        // Read Teams app id from app package.
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            return (0, teamsfx_api_1.err)(new common_2.FileNotFoundError(actionName, constants_1.Constants.MANIFEST_FILE));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        const teamsAppId = manifest.id;
        try {
            const graphClient = new graphClient_1.GraphClient(context.m365TokenProvider);
            // Get installed apps, delete it if externalId already exists.
            const apps = await graphClient.GetAppInstallationForTeam(args.teamId);
            apps.map(async (app) => {
                if (app.teamsApp.externalId == teamsAppId) {
                    context.addTelemetryProperties({ [telemetry_1.TelemetryProperty.DeleteInstalledApp]: "true" });
                    const message = (0, localizeUtils_1.getLocalizedString)("driver.devChannel.install.summary.exists", app.teamsApp.displayName, args.teamId);
                    context.logProvider.info(message);
                    context.addSummary(message);
                    await graphClient.DeleteInstalledApp(args.teamId, app.id);
                }
            });
            await graphClient.InstallAppToChannelAsync(args.teamId, args.channelId, archivedFile);
            const message = (0, localizeUtils_1.getLocalizedString)("driver.devChannel.install.success", args.teamId, args.channelId);
            context.logProvider.info(message);
            context.addSummary(message);
            return (0, teamsfx_api_1.ok)(new Map());
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error)) {
                const message = JSON.stringify(error.response.data);
                // User trying to install app to a non-sandboxed team.
                if (error.response.status === 404 &&
                    message.includes("Failed to execute TeamsGraphService backend request GetSandboxingConfigurationRequest")) {
                    context.logProvider.error((0, localizeUtils_1.getLocalizedString)("error.installApp.outsideSandbox"));
                    return (0, teamsfx_api_1.err)(new errors_1.InstallAppOutsideSandboxError(actionName));
                }
                context.logProvider.error(message);
                return (0, teamsfx_api_1.err)(new common_1.HttpClientError(error, actionName, message));
            }
            else {
                return (0, teamsfx_api_1.err)(error);
            }
        }
    }
    validateArgs(args) {
        const invalidParams = [];
        // Need teamId and channelId to install app to channel
        if (!args.teamId || typeof args.teamId !== "string") {
            invalidParams.push("teamId");
        }
        if (!args.channelId || typeof args.channelId !== "string") {
            invalidParams.push("channelId");
        }
        if (!args.appPackagePath) {
            invalidParams.push("appPackagePath");
        }
        if (invalidParams.length > 0) {
            return (0, teamsfx_api_1.err)(new common_2.InvalidActionInputError(actionName, invalidParams));
        }
        else {
            return (0, teamsfx_api_1.ok)(undefined);
        }
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext,
        Map]),
    tslib_1.__metadata("design:returntype", Promise)
], InstallAppToChannelDriver.prototype, "install", null);
InstallAppToChannelDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(actionName)
], InstallAppToChannelDriver);
exports.InstallAppToChannelDriver = InstallAppToChannelDriver;
//# sourceMappingURL=installApp.js.map