"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodejsInstaller = exports.NodejsInstaller = exports.NodejsMirrors = exports.ComponentName = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const linkedom_1 = require("linkedom");
const os_1 = tslib_1.__importDefault(require("os"));
const path = tslib_1.__importStar(require("path"));
const tar_1 = require("tar");
const error_1 = require("../../../error");
const nodeChecker_1 = require("../../deps-checker/internal/nodeChecker");
const httpClient_1 = require("./httpClient");
const localizeUtils_1 = require("../../../common/localizeUtils");
const stream_1 = tslib_1.__importDefault(require("stream"));
const Handlebars = tslib_1.__importStar(require("handlebars"));
exports.ComponentName = "NodeInstaller";
exports.NodejsMirrors = [
    {
        name: "NPM",
        url: "https://registry.npmmirror.com/-/binary/node/",
        indexJsonUrl: "https://cdn.npmmirror.com/binaries/node/index.json",
        packageUrlTpl: Handlebars.compile("https://cdn.npmmirror.com/binaries/node/{{version}}/node-{{version}}-{{name}}{{ext}}"),
    },
    {
        name: "Official",
        url: "https://nodejs.org/dist/",
        indexJsonUrl: "https://nodejs.org/dist/index.json",
        packageUrlTpl: Handlebars.compile("https://nodejs.org/dist/{{version}}/node-{{version}}-{{name}}{{ext}}"),
    },
    {
        name: "Tencent",
        url: "https://mirrors.cloud.tencent.com/nodejs-release/",
        indexJsonUrl: "https://mirrors.cloud.tencent.com/nodejs-release/index.json",
        packageUrlTpl: Handlebars.compile("https://mirrors.cloud.tencent.com/nodejs-release/{{version}}/node-{{version}}-{{name}}{{ext}}"),
    },
    {
        name: "Aliyun",
        url: "https://mirrors.aliyun.com/nodejs-release/",
        indexJsonUrl: "https://mirrors.aliyun.com/nodejs-release/index.json",
        packageUrlTpl: Handlebars.compile("https://mirrors.aliyun.com/nodejs-release/{{version}}/node-{{version}}-{{name}}{{ext}}"),
    },
];
class NodejsInstaller {
    getNameAndExt() {
        const platform = os_1.default.platform();
        const arch = os_1.default.arch();
        const osMap = {
            win32: "win",
            darwin: "darwin",
            linux: "linux",
            aix: "aix",
        };
        const archMap = {
            x64: "x64",
            arm64: "arm64",
            arm: "armv7l",
            ppc64: "ppc64le",
            s390x: "s390x",
        };
        const targetOS = osMap[platform] || platform;
        const targetArch = archMap[arch] || arch;
        let extPattern;
        switch (targetOS) {
            case "win":
                extPattern = ".zip"; // Windows zip is preferred
                break;
            case "darwin":
            case "linux":
                extPattern = ".tar.xz"; // macOS/Linux .tar.xz is preferred
                break;
            default:
                extPattern = ".tar.gz";
        }
        return { name: `${targetOS}-${targetArch}`, ext: extPattern };
    }
    getLatestLTSVersion(mirror) {
        const jsonData = mirror.indexJson;
        const ltsVersion = jsonData.find((entry) => entry.lts !== false);
        return ltsVersion === null || ltsVersion === void 0 ? void 0 : ltsVersion.version;
    }
    async fetchJSON(url) {
        try {
            const res = await httpClient_1.httpClient.getText(url);
            return (0, teamsfx_api_1.ok)(JSON.parse(res));
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new error_1.InstallNodeJSError(e.message));
        }
    }
    async fetchString(url, timeout) {
        try {
            const res = await httpClient_1.httpClient.getText(url, { timeout: timeout });
            return (0, teamsfx_api_1.ok)(res);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new error_1.InstallNodeJSError(e.message));
        }
    }
    resolveUrl(baseUrl, href) {
        return new URL(href, baseUrl).toString();
    }
    async testMirrorSpeed(mirror, osArchName, ext, timeout, logger) {
        try {
            const time1 = Date.now();
            const indexJson = await httpClient_1.httpClient.getText(mirror.indexJsonUrl, { timeout: timeout });
            mirror.indexJson = JSON.parse(indexJson);
            const ltsVersion = exports.nodejsInstaller.getLatestLTSVersion(mirror);
            if (!ltsVersion) {
                return mirror;
            }
            mirror.version = ltsVersion;
            const packageUrl = this.getDownloadUrl(mirror, ltsVersion, osArchName, ext);
            mirror.packageUrl = packageUrl;
            await httpClient_1.httpClient.headTime(packageUrl, { timeout: timeout });
            const time2 = Date.now();
            mirror.time = time2 - time1;
            logger === null || logger === void 0 ? void 0 : logger.debug(`Mirror: ${mirror.name}, URL: ${packageUrl}, Time: ${mirror.time} ms`);
        }
        catch (e) {
            logger === null || logger === void 0 ? void 0 : logger.error(`Mirror: ${mirror.name}, Error: ${e.message}`);
        }
        return mirror;
    }
    async getBestMirror(osArchName, ext, logger) {
        // const mirror = await this.testMirrorSpeed(FirstPriorityMirror, osArchName, ext, 1000, logger);
        // if (mirror.packageUrl) {
        //   return mirror;
        // }
        for (let i = 0; i < 5; ++i) {
            const mirror = await Promise.race(exports.NodejsMirrors.map((mirror) => this.testMirrorSpeed(mirror, osArchName, ext, 1000, logger)));
            if (mirror.packageUrl) {
                return mirror;
            }
        }
        return undefined;
    }
    parseHtmlToGetUrl(url, html, pattern) {
        const { document } = (0, linkedom_1.parseHTML)(html);
        const links = [...document.querySelectorAll("a")]
            .map((a) => a.getAttribute("href"))
            .filter((href) => href && href.includes(pattern))
            .map((href) => this.resolveUrl(url, href));
        if (links.length === 0) {
            return undefined;
        }
        return links[0];
    }
    async fetchBinary(url, timeout, onProgress) {
        try {
            const res = await httpClient_1.httpClient.get(url, {
                timeout: timeout,
                progress: (downloaded, total) => {
                    if (onProgress) {
                        const progress = ((downloaded / total) * 100).toFixed(2);
                        onProgress(`download progress: ${progress}%`);
                    }
                },
            });
            return (0, teamsfx_api_1.ok)(res);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new error_1.InstallNodeJSError(e.message));
        }
    }
    getAdmZip(buffer) {
        return new adm_zip_1.default(buffer);
    }
    extractZip(buffer, targetDir) {
        const zip = this.getAdmZip(buffer);
        zip.extractAllTo(targetDir, true);
    }
    extractTar(buffer, fileName, targetDir) {
        if (fileName.endsWith(".tar.gz")) {
            const bufferStream = new stream_1.default.PassThrough();
            bufferStream.end(buffer);
            bufferStream.pipe((0, tar_1.extract)({ cwd: targetDir }));
        }
        else if (fileName.endsWith(".tar.xz")) {
            const bufferStream = new stream_1.default.PassThrough();
            bufferStream.end(buffer);
            bufferStream.pipe((0, tar_1.extract)({ cwd: targetDir }));
        }
    }
    extractPackage(buffer, fileName, targetDir) {
        if (fileName.endsWith(".zip")) {
            this.extractZip(buffer, targetDir);
        }
        else if (fileName.endsWith(".tar.gz") || fileName.endsWith(".tar.xz")) {
            this.extractTar(buffer, fileName, targetDir);
        }
    }
    getDownloadUrl(mirror, version, osArchName, ext) {
        const packageUrl = mirror.packageUrlTpl({
            version: version,
            name: osArchName,
            ext: ext,
        });
        return packageUrl;
    }
    async ensureNodeJS(context, checkSystemInstalled, checkUserFolderInstalled) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const startTime = Date.now();
        const progressBar = (_a = context.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar((0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.Progress.title"), 5);
        progressBar === null || progressBar === void 0 ? void 0 : progressBar.start();
        // Checking NodeJS in system environment
        let progressText = (0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.Progress1");
        (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.info(progressText);
        progressBar === null || progressBar === void 0 ? void 0 : progressBar.next(progressText);
        if (checkSystemInstalled) {
            const nodeVersion = await nodeChecker_1.NodeChecker.getInstalledNodeVersion();
            if (nodeVersion !== null) {
                (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.info((0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.InstalledSystem", nodeVersion.version));
                progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true);
                return (0, teamsfx_api_1.ok)({ status: "ignore" });
            }
            else {
                (_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.info((0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.NotInstalledSystem"));
            }
        }
        // Checking NodeJS in user folder
        progressText = (0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.Progress2");
        (_e = context.logProvider) === null || _e === void 0 ? void 0 : _e.info(progressText);
        progressBar === null || progressBar === void 0 ? void 0 : progressBar.next(progressText);
        const { name, ext } = this.getNameAndExt();
        const downloadDir = path.join(os_1.default.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "nodejs");
        await fs_extra_1.default.ensureDir(downloadDir);
        if (checkUserFolderInstalled) {
            const subFolders = await fs_extra_1.default.readdir(downloadDir);
            const foundFolder = subFolders.find((subFolder) => subFolder.endsWith(name));
            if (foundFolder) {
                (_f = context.logProvider) === null || _f === void 0 ? void 0 : _f.info((0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.InstalledUser", path.join(downloadDir, foundFolder)));
                progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true);
                return (0, teamsfx_api_1.ok)({ status: "ignore", installPath: path.join(downloadDir, foundFolder) });
            }
            else {
                (_g = context.logProvider) === null || _g === void 0 ? void 0 : _g.info((0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.NotInstalledUser", downloadDir));
            }
        }
        // Testing speed of download mirrors
        progressText = (0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.Progress3");
        (_h = context.logProvider) === null || _h === void 0 ? void 0 : _h.info(progressText);
        progressBar === null || progressBar === void 0 ? void 0 : progressBar.next(progressText);
        const bestMirror = await exports.nodejsInstaller.getBestMirror(name, ext, context.logProvider);
        if (!(bestMirror === null || bestMirror === void 0 ? void 0 : bestMirror.packageUrl) || !(bestMirror === null || bestMirror === void 0 ? void 0 : bestMirror.version)) {
            progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true);
            return (0, teamsfx_api_1.err)(new error_1.InstallNodeJSError((0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.NoMirrorUsable")));
        }
        (_j = context.logProvider) === null || _j === void 0 ? void 0 : _j.info((0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.BestMirror", bestMirror.name, bestMirror.url, bestMirror.time));
        // User confirmation for installation
        const confirmRes = await ((_l = (_k = context.ui) === null || _k === void 0 ? void 0 : _k.confirm) === null || _l === void 0 ? void 0 : _l.call(_k, {
            name: "confirm",
            title: (0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.Confirm", bestMirror.version),
        }));
        if (confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isErr()) {
            progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true);
            return (0, teamsfx_api_1.err)(confirmRes.error);
        }
        // Downloading NodeJS package
        progressText = (0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.Progress4", bestMirror.packageUrl);
        (_m = context.logProvider) === null || _m === void 0 ? void 0 : _m.info(progressText);
        progressBar === null || progressBar === void 0 ? void 0 : progressBar.next(progressText);
        const t1 = Date.now();
        const downloadRes = await exports.nodejsInstaller.fetchBinary(bestMirror.packageUrl, undefined, (progress) => { var _a; return void ((_a = progressBar === null || progressBar === void 0 ? void 0 : progressBar.text) === null || _a === void 0 ? void 0 : _a.call(progressBar, progress)); });
        const t2 = Date.now();
        if (downloadRes.isErr()) {
            progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true);
            return (0, teamsfx_api_1.err)(downloadRes.error);
        }
        const binary = downloadRes.value;
        (_o = context.logProvider) === null || _o === void 0 ? void 0 : _o.info((0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.SuccessDownload", bestMirror.packageUrl, binary.length, t2 - t1));
        // Extracting package
        progressText = (0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.Progress5");
        (_p = context.logProvider) === null || _p === void 0 ? void 0 : _p.info(progressText);
        progressBar === null || progressBar === void 0 ? void 0 : progressBar.next(progressText);
        exports.nodejsInstaller.extractPackage(binary, bestMirror.packageUrl, downloadDir);
        const t3 = Date.now();
        const targetNodeJSPath = path.join(downloadDir, `node-${bestMirror.version}-${name}`);
        (_q = context.logProvider) === null || _q === void 0 ? void 0 : _q.info((0, localizeUtils_1.getLocalizedString)("action.devTool.nodeInstaller.SuccessExtract", targetNodeJSPath, t3 - t2));
        progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true);
        const totalTime = t3 - startTime;
        return (0, teamsfx_api_1.ok)({ status: "installed", installPath: targetNodeJSPath, totalTime: totalTime });
    }
}
exports.NodejsInstaller = NodejsInstaller;
exports.nodejsInstaller = new NodejsInstaller();
// const logProvider = {
//   info: (message: string) => {
//     console.log(message);
//   },
//   debug: (message: string) => {
//     console.debug(message);
//   },
//   error: (message: string) => {
//     console.error(message);
//   },
// };
// async function main() {
//   const result = await nodejsInstaller.ensureNodeJS(
//     {
//       logProvider: logProvider,
//       ui: {
//         createProgressBar: (title: string, totalSteps: number) => {
//           return {
//             start: (message?: string) => {
//               console.log(`${title}: ${message || ""}`);
//             },
//             next: (message?: string) => {
//               console.log(`Next step: ${message || ""}`);
//             },
//             end: (success: boolean) => {
//               console.log(`Progress ended. Success: ${success.toString()}`);
//             },
//             text: (message: string) => {
//               process.stdout.write(`Progress: ${message}\r`);
//             },
//           };
//         },
//       },
//     } as any,
//     false,
//     false
//   );
//   console.log(result);
// }
// main();
//# sourceMappingURL=nodeInstaller.js.map