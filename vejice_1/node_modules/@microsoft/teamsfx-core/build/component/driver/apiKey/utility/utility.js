"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateUrl = exports.validateDomain = exports.getDomain = exports.loadStateFromEnv = void 0;
const common_1 = require("../../../utils/common");
const constants_1 = require("./constants");
const apiKeyDomainInvalid_1 = require("../error/apiKeyDomainInvalid");
const apiKeyFailedToGetDomain_1 = require("../error/apiKeyFailedToGetDomain");
const apiKeyAuthMissingInSpec_1 = require("../error/apiKeyAuthMissingInSpec");
const daSpecParser_1 = require("../../../../common/daSpecParser");
// Needs to validate the parameters outside of the function
function loadStateFromEnv(outputEnvVarNames) {
    const result = {};
    for (const [propertyName, envVarName] of outputEnvVarNames) {
        result[propertyName] = process.env[envVarName];
    }
    return result;
}
exports.loadStateFromEnv = loadStateFromEnv;
// TODO: need to add logic to read domain from env if need to support non-lifecycle commands
async function getDomain(args, context, actionName) {
    const absolutePath = (0, common_1.getAbsolutePath)(args.apiSpecPath, context.projectPath);
    const listResult = await (0, daSpecParser_1.listAPIInfo)(absolutePath);
    const operations = listResult.APIs;
    const filteredOperations = operations.filter((value) => {
        const auth = value.auth;
        return (auth &&
            auth.name === args.name &&
            ((auth.authScheme.type === "http" && auth.authScheme.scheme.toLowerCase() === "bearer") ||
                (auth.authScheme.type === "apiKey" && auth.authScheme.in !== "cookie")));
    });
    if (filteredOperations.length === 0) {
        throw new apiKeyAuthMissingInSpec_1.ApiKeyAuthMissingInSpecError(actionName, args.name);
    }
    const isCustomAPIKey = filteredOperations[0].auth.authScheme.type === "apiKey" ? "true" : "false";
    context.addTelemetryProperties({ [constants_1.telemetryKeys.isCustomAPIKey]: isCustomAPIKey });
    const servers = filteredOperations.map((value) => value.server);
    const uniqueServerUrls = servers.filter((value, index, self) => self.indexOf(value) === index);
    return uniqueServerUrls;
}
exports.getDomain = getDomain;
function validateDomain(domain, actionName) {
    if (domain.length > constants_1.maxDomainPerApiKey) {
        throw new apiKeyDomainInvalid_1.ApiKeyDomainInvalidError(actionName);
    }
    if (domain.length === 0 || domain.includes("")) {
        throw new apiKeyFailedToGetDomain_1.ApiKeyFailedToGetDomainError(actionName);
    }
}
exports.validateDomain = validateDomain;
function validateUrl(baseUrl) {
    try {
        const url = new URL(baseUrl);
        return url.protocol === "https:";
    }
    catch (error) {
        return false;
    }
}
exports.validateUrl = validateUrl;
//# sourceMappingURL=utility.js.map