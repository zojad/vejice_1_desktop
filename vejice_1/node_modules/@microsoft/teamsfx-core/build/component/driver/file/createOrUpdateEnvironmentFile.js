"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateOrUpdateEnvironmentFileDriver = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const dotenv = tslib_1.__importStar(require("dotenv"));
const fs = tslib_1.__importStar(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../../error/common");
const question_1 = require("../../../question");
const constants_1 = require("../../constants");
const common_2 = require("../../utils/common");
const pathUtils_1 = require("../../utils/pathUtils");
const constants_2 = require("../aad/utility/constants");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const actionName = "file/createOrUpdateEnvironmentFile";
const helpLink = "https://aka.ms/teamsfx-actions/file-createOrUpdateEnvironmentFile";
let CreateOrUpdateEnvironmentFileDriver = class CreateOrUpdateEnvironmentFileDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.file.createOrUpdateEnvironmentFile.description");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("driver.file.progressBar.env");
    }
    async run(args, context) {
        return (0, common_2.wrapRun)(async () => {
            const result = await this.handler(args, context);
            return result.output;
        }, actionName);
    }
    async execute(args, ctx) {
        let summaries = [];
        const outputResult = await (0, common_2.wrapRun)(async () => {
            const result = await this.handler(args, ctx);
            summaries = result.summaries;
            return result.output;
        }, actionName);
        return {
            result: outputResult,
            summaries,
        };
    }
    async handler(args, context) {
        var _a, _b, _c, _d;
        try {
            this.validateArgs(args);
            const target = pathUtils_1.pathUtils.resolveFilePath(context.projectPath, args.target);
            await fs.ensureFile(target);
            const envs = dotenv.parse(await fs.readFile(target));
            (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.debug(`Existing envs: ${JSON.stringify(envs)}`);
            const map = new Map();
            const res = await this.askForOpenAIEnvironmentVariables(context, args, map);
            if (res.isErr()) {
                throw res.error;
            }
            const updatedEnvs = Object.entries(Object.assign(Object.assign({}, envs), args.envs)).map(([key, value]) => `${key}=${value}`);
            (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.debug(`Updated envs: ${JSON.stringify(updatedEnvs)}`);
            await fs.writeFile(target, updatedEnvs.join(os.EOL));
            const envFilePathRes = await pathUtils_1.pathUtils.getEnvFilePath(context.projectPath, process.env.TEAMSFX_ENV || "dev");
            if (envFilePathRes.isOk()) {
                if (path.resolve(target) === path.resolve(envFilePathRes.value)) {
                    for (const key of Object.keys(args.envs)) {
                        map.set(key, args.envs[key]);
                    }
                }
            }
            return {
                output: map,
                summaries: [
                    (0, localizeUtils_1.getLocalizedString)("driver.file.createOrUpdateEnvironmentFile.summary", path.normalize(target)),
                ],
            };
        }
        catch (error) {
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.error((0, localizeUtils_1.getLocalizedString)(constants_2.logMessageKeys.failExecuteDriver, actionName, error.displayMessage));
                throw error;
            }
            const message = JSON.stringify(error);
            (_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.error((0, localizeUtils_1.getLocalizedString)(constants_2.logMessageKeys.failExecuteDriver, actionName, message));
            throw (0, common_1.assembleError)(error, actionName);
        }
    }
    /**
     * Pop up input text to input OpenAI environment variables, or return UserCancel error.
     * @param ctx
     * @param args The arguments passed to the driver.
     * @param envOutput Used to store the resolved environment variables, which will be written to the environment file.
     * @returns
     */
    async askForOpenAIEnvironmentVariables(ctx, args, envOutput) {
        for (const [envKey, envValue] of Object.entries(args.envs)) {
            const result = await this.processOpenAIEnvironmentVariable(ctx, args, envOutput, envKey, envValue);
            if (result.isErr()) {
                return result;
            }
        }
        return (0, teamsfx_api_1.ok)(teamsfx_api_1.Void);
    }
    async processOpenAIEnvironmentVariable(ctx, args, envOutput, envKey, envValue) {
        var _a;
        if (envValue) {
            const placeHolderReg = /\${{\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*}}/;
            const matches = placeHolderReg.exec(envValue);
            if (matches != null && matches.length > 1) {
                const envVarName = matches[1];
                const config = envVarConfigs.find((c) => c.envKey === envKey) || getGenericEnvVarConfig(envKey);
                const result = await ((_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.inputText({
                    name: config.question.name,
                    title: config.question.title,
                    password: config.isPassword || config.question.password,
                    validation: config.validation,
                }));
                if (result === null || result === void 0 ? void 0 : result.isErr()) {
                    return result;
                }
                else if ((result === null || result === void 0 ? void 0 : result.isOk()) && result.value.result) {
                    envOutput.set(envVarName, result.value.result);
                    args.envs[envKey] = result.value.result;
                }
            }
        }
        return (0, teamsfx_api_1.ok)(teamsfx_api_1.Void);
    }
    validateArgs(args) {
        const invalidParameters = [];
        if (!args.target || typeof args.target !== "string" || args.target.length === 0) {
            invalidParameters.push("target");
        }
        if (!args.envs || typeof args.envs !== "object") {
            invalidParameters.push("envs");
        }
        else {
            for (const value of Object.values(args.envs)) {
                if (value === undefined || value === null || typeof value === "object") {
                    invalidParameters.push("envs");
                }
            }
        }
        if (invalidParameters.length > 0) {
            throw new common_1.InvalidActionInputError(actionName, invalidParameters, helpLink);
        }
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], CreateOrUpdateEnvironmentFileDriver.prototype, "run", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], CreateOrUpdateEnvironmentFileDriver.prototype, "execute", null);
CreateOrUpdateEnvironmentFileDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(actionName) // DO NOT MODIFY the service name
], CreateOrUpdateEnvironmentFileDriver);
exports.CreateOrUpdateEnvironmentFileDriver = CreateOrUpdateEnvironmentFileDriver;
const getNonEmptyStringValidation = (key) => {
    return (input) => (input.length < 1 ? (0, localizeUtils_1.getLocalizedString)(key) : undefined);
};
const getEndpointValidation = (key) => {
    return (input) => !input.startsWith("https://") && !input.startsWith("http://")
        ? (0, localizeUtils_1.getLocalizedString)(key)
        : undefined;
};
const getGenericEnvVarConfig = (envKey) => ({
    envKey,
    question: {
        type: "text",
        name: envKey,
        title: envKey,
    },
    validation: getNonEmptyStringValidation("driver.file.createOrUpdateEnvironmentFile.genericEnvVar.validation"),
    isPassword: envKey.toLowerCase().includes("key") || envKey.toLowerCase().includes("secret"),
});
const envVarConfigs = [
    {
        envKey: constants_1.OpenAIEnvironmentVariables.AZURE_OPENAI_API_KEY,
        question: (0, question_1.azureOpenAIKeyQuestion)(),
        validation: getNonEmptyStringValidation("driver.file.createOrUpdateEnvironmentFile.OpenAIKey.validation"),
        isPassword: true,
    },
    {
        envKey: constants_1.OpenAIEnvironmentVariables.AZURE_OPENAI_ENDPOINT,
        question: (0, question_1.azureOpenAIEndpointQuestion)(),
        validation: getEndpointValidation("driver.file.createOrUpdateEnvironmentFile.OpenAIDeploymentEndpoint.validation"),
    },
    {
        envKey: constants_1.OpenAIEnvironmentVariables.AZURE_OPENAI_DEPLOYMENT_NAME,
        question: (0, question_1.azureOpenAIDeploymentNameQuestion)(),
        validation: getNonEmptyStringValidation("driver.file.createOrUpdateEnvironmentFile.OpenAIDeploymentName.validation"),
    },
    {
        envKey: constants_1.OpenAIEnvironmentVariables.AZURE_OPENAI_MODEL_DEPLOYMENT_NAME,
        question: (0, question_1.azureOpenAIDeploymentNameQuestion)(),
        validation: getNonEmptyStringValidation("driver.file.createOrUpdateEnvironmentFile.OpenAIDeploymentName.validation"),
    },
    {
        envKey: constants_1.OpenAIEnvironmentVariables.OPENAI_API_KEY,
        question: (0, question_1.openAIKeyQuestion)(),
        validation: getNonEmptyStringValidation("driver.file.createOrUpdateEnvironmentFile.OpenAIKey.validation"),
        isPassword: true,
    },
    {
        envKey: constants_1.OpenAIEnvironmentVariables.OPENAI_ASSISTANT_ID,
        question: (0, question_1.openAIAssistantIdQuestion)(),
        validation: getNonEmptyStringValidation("driver.file.createOrUpdateEnvironmentFile.OpenAIAssistantID.validation"),
    },
    {
        envKey: constants_1.OpenAIEnvironmentVariables.AZURE_OPENAI_ASSISTANT_ID,
        question: (0, question_1.azureOpenAIAssistantIdQuestion)(),
        validation: getNonEmptyStringValidation("driver.file.createOrUpdateEnvironmentFile.OpenAIAssistantID.validation"),
    },
    {
        envKey: constants_1.OpenAIEnvironmentVariables.AZURE_OPENAI_EMBEDDING_DEPLOYMENT,
        question: (0, question_1.azureOpenAIEmbeddingDeploymentNameQuestion)(),
        validation: getNonEmptyStringValidation("driver.file.createOrUpdateEnvironmentFile.OpenAIEmbeddingDeploymentName.validation"),
    },
    {
        envKey: constants_1.OpenAIEnvironmentVariables.AZURE_OPENAI_EMBEDDING_DEPLOYMENT_NAME,
        question: (0, question_1.azureOpenAIEmbeddingDeploymentNameQuestion)(),
        validation: getNonEmptyStringValidation("driver.file.createOrUpdateEnvironmentFile.OpenAIEmbeddingDeploymentName.validation"),
    },
];
//# sourceMappingURL=createOrUpdateEnvironmentFile.js.map