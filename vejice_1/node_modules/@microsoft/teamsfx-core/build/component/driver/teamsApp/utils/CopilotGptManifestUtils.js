"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.copilotGptManifestUtils = exports.CopilotGptManifestUtils = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const os_1 = require("os");
const path_1 = tslib_1.__importDefault(require("path"));
const strip_bom_1 = tslib_1.__importDefault(require("strip-bom"));
const daSpecParser_1 = require("../../../../common/daSpecParser");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const common_1 = require("../../../../error/common");
const constant_1 = require("../../../configManager/constant");
const envFunctionUtils_1 = require("../../../utils/envFunctionUtils");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const results_1 = require("../results");
const ManifestUtils_1 = require("./ManifestUtils");
const PluginManifestUtils_1 = require("./PluginManifestUtils");
const utils_1 = require("./utils");
class CopilotGptManifestUtils {
    async readCopilotGptManifestFile(path) {
        if (!(await fs_extra_1.default.pathExists(path))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("CopilotGptManifestUtils", path));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content = await fs_extra_1.default.readFile(path, { encoding: "utf-8" });
        content = (0, strip_bom_1.default)(content);
        try {
            const manifest = JSON.parse(content);
            return (0, teamsfx_api_1.ok)(manifest);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.JSONSyntaxError(path, e, "CopilotGptManifestUtils"));
        }
    }
    async readDeclarativeAgentManifestFile(path) {
        if (!(await fs_extra_1.default.pathExists(path))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("CopilotGptManifestUtils", path));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content = await fs_extra_1.default.readFile(path, { encoding: "utf-8" });
        content = (0, strip_bom_1.default)(content);
        try {
            const manifest = teamsfx_api_1.DeclarativeAgentManifestConverter.jsonToManifest(content);
            return (0, teamsfx_api_1.ok)(manifest);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.JSONSyntaxError(path, e, "CopilotGptManifestUtils"));
        }
    }
    readCopilotGptManifestFileSync(path) {
        if (!fs_extra_1.default.pathExistsSync(path)) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("CopilotGptManifestUtils", path));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content = fs_extra_1.default.readFileSync(path, { encoding: "utf-8" });
        content = (0, strip_bom_1.default)(content);
        try {
            const manifest = JSON.parse(content);
            return (0, teamsfx_api_1.ok)(manifest);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("CopilotGptManifestUtils", path));
        }
    }
    readDeclarativeAgentManifestFileSync(path) {
        if (!fs_extra_1.default.pathExistsSync(path)) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("CopilotGptManifestUtils", path));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content = fs_extra_1.default.readFileSync(path, { encoding: "utf-8" });
        content = (0, strip_bom_1.default)(content);
        try {
            const manifest = teamsfx_api_1.DeclarativeAgentManifestConverter.jsonToManifest(content);
            return (0, teamsfx_api_1.ok)(manifest);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.JSONSyntaxError(path, e, "CopilotGptManifestUtils"));
        }
    }
    /**
     * Get Declarative Copilot Manifest with env value filled.
     * @param path path of declaraitve Copilot
     * @returns resolved manifest
     */
    async getManifest(path, context) {
        const manifestRes = await this.readCopilotGptManifestFile(path);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        // Add environment variable keys to telemetry
        const resolvedManifestRes = await (0, utils_1.getResolvedManifest)(JSON.stringify(manifestRes.value), path, envFunctionUtils_1.ManifestType.DeclarativeCopilotManifest, context);
        if (resolvedManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(resolvedManifestRes.error);
        }
        const resolvedManifestString = resolvedManifestRes.value;
        return (0, teamsfx_api_1.ok)(JSON.parse(resolvedManifestString));
    }
    async writeCopilotGptManifestFile(manifest, path) {
        const content = JSON.stringify(manifest, undefined, 4);
        try {
            await fs_extra_1.default.writeFile(path, content);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.WriteFileError(e, "copilotGptManifestUtils"));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    async writeDeclarativeAgentManifestFile(manifest, path) {
        const content = teamsfx_api_1.DeclarativeAgentManifestConverter.manifestToJson(manifest);
        try {
            await fs_extra_1.default.writeFile(path, content);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.WriteFileError(e, "copilotGptManifestUtils"));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    async validateAgainstSchema(declaraitveCopilot, manifestPath, context) {
        var _a;
        const manifestRes = await this.getManifest(manifestPath, context);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const manifest = manifestRes.value;
        try {
            const manifestValidationRes = await teamsfx_api_1.ManifestUtil.validateManifest(manifestRes.value);
            const res = {
                id: declaraitveCopilot.id,
                filePath: manifestPath,
                validationResult: manifestValidationRes,
                actionValidationResult: [],
            };
            if ((_a = manifest.actions) === null || _a === void 0 ? void 0 : _a.length) {
                // action
                for (const action of manifest.actions) {
                    const actionPath = path_1.default.join(path_1.default.dirname(manifestPath), action.file);
                    const actionValidationRes = await PluginManifestUtils_1.pluginManifestUtils.validateAgainstSchema(action, actionPath, context);
                    if (actionValidationRes.isErr()) {
                        return (0, teamsfx_api_1.err)(actionValidationRes.error);
                    }
                    else {
                        res.actionValidationResult.push(actionValidationRes.value);
                    }
                }
            }
            return (0, teamsfx_api_1.ok)(res);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                (0, localizeUtils_1.getLocalizedString)("error.appstudio.validateFetchSchemaFailed", manifestRes.value.$schema, e.message),
            ])));
        }
    }
    async getManifestPath(teamsManifestPath) {
        var _a, _b, _c, _d, _e;
        const teamsManifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(teamsManifestPath);
        if (teamsManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(teamsManifestRes.error);
        }
        const filePath = teamsManifestRes.value.copilotExtensions
            ? (_b = (_a = teamsManifestRes.value.copilotExtensions.declarativeCopilots) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.file
            : (_e = (_d = (_c = teamsManifestRes.value.copilotAgents) === null || _c === void 0 ? void 0 : _c.declarativeAgents) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.file;
        if (!filePath) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.TeamsAppRequiredPropertyMissingError.name, errors_1.AppStudioError.TeamsAppRequiredPropertyMissingError.message("copilotExtensions.declarativeCopilots.file", teamsManifestPath)));
        }
        else {
            return (0, teamsfx_api_1.ok)(path_1.default.resolve(path_1.default.dirname(teamsManifestPath), filePath));
        }
    }
    async updateConversationStarters(actionPath, gptManifest) {
        var _a, _b, _c;
        const actionManifest = await fs_extra_1.default.readJson(actionPath);
        let conversationStarters = (_a = actionManifest.capabilities) === null || _a === void 0 ? void 0 : _a.conversation_starters;
        if (!conversationStarters || conversationStarters.length === 0) {
            const openApiRuntimes = (_b = actionManifest.runtimes) === null || _b === void 0 ? void 0 : _b.filter((runtime) => runtime.type === "OpenApi");
            if (openApiRuntimes) {
                for (const runtime of openApiRuntimes) {
                    const specPathRelativePath = runtime.spec.url;
                    const specPath = path_1.default.resolve(path_1.default.dirname(actionPath), specPathRelativePath);
                    if (await fs_extra_1.default.pathExists(specPath)) {
                        const listResult = await (0, daSpecParser_1.listAPIInfo)(specPath);
                        const operationIds = (_c = actionManifest.functions) === null || _c === void 0 ? void 0 : _c.map((func) => func.name);
                        const newStarters = listResult.APIs.filter((item) => item.isValid &&
                            (operationIds === null || operationIds === void 0 ? void 0 : operationIds.includes(item.operationId)) &&
                            (item.description || item.summary)).map((operation) => {
                            return {
                                text: operation.summary || operation.description,
                            };
                        });
                        conversationStarters = (conversationStarters || []).concat(newStarters);
                    }
                }
            }
        }
        if (conversationStarters) {
            if (!gptManifest.conversation_starters) {
                gptManifest.conversation_starters = [];
            }
            for (const starter of conversationStarters) {
                if (gptManifest.conversation_starters.length >= 6) {
                    break;
                }
                if (!gptManifest.conversation_starters.some((existingStarter) => existingStarter.text === starter.text)) {
                    gptManifest.conversation_starters.push(starter);
                }
            }
        }
    }
    async addAction(copilotGptPath, id, pluginFile) {
        var _a;
        const gptManifestRes = await exports.copilotGptManifestUtils.readCopilotGptManifestFile(copilotGptPath);
        if (gptManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(gptManifestRes.error);
        }
        else {
            const gptManifest = gptManifestRes.value;
            if (!gptManifest.actions) {
                gptManifest.actions = [];
            }
            (_a = gptManifest.actions) === null || _a === void 0 ? void 0 : _a.push({
                id,
                file: pluginFile,
            });
            const actionPath = path_1.default.join(path_1.default.dirname(copilotGptPath), pluginFile);
            await this.updateConversationStarters(actionPath, gptManifest);
            const updateGptManifestRes = await exports.copilotGptManifestUtils.writeCopilotGptManifestFile(gptManifest, copilotGptPath);
            if (updateGptManifestRes.isErr()) {
                return (0, teamsfx_api_1.err)(updateGptManifestRes.error);
            }
            else {
                return (0, teamsfx_api_1.ok)(gptManifest);
            }
        }
    }
    logValidationErrors(validationRes, platform) {
        const validationErrors = validationRes.validationResult;
        const filePath = validationRes.filePath;
        const hasDeclarativeCopilotError = validationErrors.length > 0;
        let hasActionError = false;
        for (const actionValidationRes of validationRes.actionValidationResult) {
            if (actionValidationRes.validationResult.length > 0) {
                hasActionError = true;
                break;
            }
        }
        if (!hasDeclarativeCopilotError && !hasActionError) {
            return "";
        }
        if (platform !== teamsfx_api_1.Platform.CLI) {
            let outputMessage = "";
            if (hasDeclarativeCopilotError) {
                const errors = validationErrors
                    .map((error) => {
                    return `${constant_1.SummaryConstant.Failed} ${error}`;
                })
                    .join(os_1.EOL);
                outputMessage +=
                    (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateDeclarativeCopilotManifest.checkPath", filePath) +
                        os_1.EOL +
                        errors;
            }
            for (const actionValidationRes of validationRes.actionValidationResult) {
                const actionValidationMessage = PluginManifestUtils_1.pluginManifestUtils.logValidationErrors(actionValidationRes, platform);
                if (actionValidationMessage) {
                    outputMessage += (!outputMessage ? "" : os_1.EOL) + actionValidationMessage;
                }
            }
            return outputMessage;
        }
        else {
            const outputMessage = [];
            if (hasDeclarativeCopilotError) {
                outputMessage.push({
                    content: (0, localizeUtils_1.getDefaultString)("driver.teamsApp.summary.validateDeclarativeCopilotManifest.checkPath", filePath) + "\n",
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                });
                validationErrors.map((error) => {
                    outputMessage.push({ content: `${constant_1.SummaryConstant.Failed} `, color: teamsfx_api_1.Colors.BRIGHT_RED });
                    outputMessage.push({
                        content: `${error}\n`,
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    });
                });
            }
            for (const actionValidationRes of validationRes.actionValidationResult) {
                const actionValidationMessage = PluginManifestUtils_1.pluginManifestUtils.logValidationErrors(actionValidationRes, platform);
                if (actionValidationMessage) {
                    outputMessage.push(...actionValidationMessage);
                }
            }
            return outputMessage;
        }
    }
    async getDefaultNextAvailablePluginManifestPath(folder, pluginManifestFileName = teamsfx_api_1.DefaultPluginManifestFileName, isKiotaIntegration = false) {
        if (!(await fs_extra_1.default.pathExists(path_1.default.join(folder, pluginManifestFileName)))) {
            return path_1.default.join(folder, pluginManifestFileName);
        }
        const pluginManifestNamePrefix = pluginManifestFileName.split(".")[0];
        let pluginFileNameSuffix = 1;
        let pluginManifestName = this.getPluginManifestFileName(pluginManifestNamePrefix, pluginFileNameSuffix, isKiotaIntegration);
        while (await fs_extra_1.default.pathExists(path_1.default.join(folder, pluginManifestName))) {
            pluginFileNameSuffix++;
            pluginManifestName = this.getPluginManifestFileName(pluginManifestNamePrefix, pluginFileNameSuffix, isKiotaIntegration);
        }
        return path_1.default.join(folder, pluginManifestName);
    }
    async addEmbeddedKnowledgeFiles(manifestFilePath, filePathList) {
        const declarativeAgentManifestPathRes = await exports.copilotGptManifestUtils.getManifestPath(manifestFilePath);
        if (declarativeAgentManifestPathRes.isErr()) {
            return (0, teamsfx_api_1.err)(declarativeAgentManifestPathRes.error);
        }
        const declarativeAgentManifestPath = declarativeAgentManifestPathRes.value;
        const declarativeAgentManifesRes = await exports.copilotGptManifestUtils.readCopilotGptManifestFile(declarativeAgentManifestPath);
        if (declarativeAgentManifesRes.isErr()) {
            return (0, teamsfx_api_1.err)(declarativeAgentManifesRes.error);
        }
        const declarativeAgentManifest = declarativeAgentManifesRes.value;
        if (!declarativeAgentManifest.capabilities) {
            declarativeAgentManifest.capabilities = [];
        }
        let embeddedKnowledgeCapability;
        embeddedKnowledgeCapability = declarativeAgentManifest.capabilities.find((capability) => capability.name === teamsfx_api_1.DeclarativeCopilotCapabilityName.EmbeddedKnowledge);
        if (!embeddedKnowledgeCapability) {
            embeddedKnowledgeCapability = {
                name: teamsfx_api_1.DeclarativeCopilotCapabilityName.EmbeddedKnowledge,
                files: [],
            };
            declarativeAgentManifest.capabilities.push(embeddedKnowledgeCapability);
        }
        await fs_extra_1.default.ensureDir(path_1.default.resolve(path_1.default.dirname(manifestFilePath), constants_1.EmbeddedKnowledgeLocalDirectoryName));
        for (const filePath of filePathList) {
            const savedAbsolutePath = path_1.default.resolve(path_1.default.dirname(manifestFilePath), constants_1.EmbeddedKnowledgeLocalDirectoryName, path_1.default.basename(filePath));
            await fs_extra_1.default.copyFile(filePath, savedAbsolutePath);
            embeddedKnowledgeCapability.files.push({
                file: path_1.default.relative(path_1.default.dirname(manifestFilePath), savedAbsolutePath).replace(/\\/g, "/"),
            });
        }
        // save the updated declarativeCopilotManifestPath
        await exports.copilotGptManifestUtils.writeCopilotGptManifestFile(declarativeAgentManifest, declarativeAgentManifestPath);
        return (0, teamsfx_api_1.ok)(undefined);
    }
    getPluginManifestFileName(pluginManifestNamePrefix, pluginFileNameSuffix, isKiotaIntegration) {
        let pluginManifestName;
        if (isKiotaIntegration) {
            const pluginManifestNameSplit = pluginManifestNamePrefix.split("-");
            pluginManifestName = `${pluginManifestNameSplit[0]}_${pluginFileNameSuffix}-${pluginManifestNameSplit[1]}.json`;
        }
        else {
            pluginManifestName = `${pluginManifestNamePrefix}_${pluginFileNameSuffix}.json`;
        }
        return pluginManifestName;
    }
    async updateDeclarativeAgentManifest(manifestPath, declarativeAgentManifestPath, declarativeCopilotActionId, pluginManifestPath) {
        const gptManifestPath = path_1.default.join(path_1.default.dirname(manifestPath), declarativeAgentManifestPath);
        const addAcionResult = await exports.copilotGptManifestUtils.addAction(gptManifestPath, declarativeCopilotActionId, path_1.default.basename(pluginManifestPath));
        if (addAcionResult.isErr()) {
            return (0, teamsfx_api_1.err)(addAcionResult.error);
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    async addOneDriveSharePointCapability(agentManifestPath, items_by_sharepoint_ids, items_by_url, manifestRes) {
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const agentManifest = manifestRes.value;
        if (!agentManifest.capabilities) {
            agentManifest.capabilities = [];
        }
        const newCapabilityData = {
            name: teamsfx_api_1.DeclarativeCopilotCapabilityName.OneDriveAndSharePoint,
        };
        const capability = agentManifest.capabilities.find((cap) => cap.name === teamsfx_api_1.DeclarativeCopilotCapabilityName.OneDriveAndSharePoint);
        if (items_by_url) {
            newCapabilityData.items_by_url = capability ? capability.items_by_url || [] : [];
            newCapabilityData.items_by_url.push(items_by_url);
        }
        if (items_by_sharepoint_ids) {
            newCapabilityData.items_by_sharepoint_ids = capability
                ? capability.items_by_sharepoint_ids || []
                : [];
            newCapabilityData.items_by_sharepoint_ids.push(items_by_sharepoint_ids);
        }
        return this.addOrUpdateCapability(agentManifestPath, teamsfx_api_1.DeclarativeCopilotCapabilityName.OneDriveAndSharePoint, manifestRes, newCapabilityData);
    }
    async addWebSearchCapability(context, agentManifestPath, items_by_url, manifestRes) {
        var _a;
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const agentManifest = manifestRes.value;
        if (!agentManifest.capabilities) {
            agentManifest.capabilities = [];
        }
        const newCapabilityData = {
            name: teamsfx_api_1.DeclarativeCopilotCapabilityName.WebSearch,
        };
        const capability = agentManifest.capabilities.find((cap) => cap.name === teamsfx_api_1.DeclarativeCopilotCapabilityName.WebSearch);
        // del capability warning
        if (items_by_url === null && ((_a = capability === null || capability === void 0 ? void 0 : capability.sites) === null || _a === void 0 ? void 0 : _a.length)) {
            const confirmRes = await context.userInteraction.showMessage("warn", (0, localizeUtils_1.getLocalizedString)("core.addKnowledge.doubleConfirm"), true, (0, localizeUtils_1.getLocalizedString)("core.addKnowledge.continue"));
            if (confirmRes.isErr()) {
                return (0, teamsfx_api_1.err)(confirmRes.error);
            }
            else if (confirmRes.value !== (0, localizeUtils_1.getLocalizedString)("core.addKnowledge.continue")) {
                return (0, teamsfx_api_1.err)(new common_1.UserCancelError());
            }
        }
        if (items_by_url) {
            newCapabilityData.sites = capability ? capability.sites || [] : [];
            newCapabilityData.sites.push(items_by_url);
        }
        return this.addOrUpdateCapability(agentManifestPath, teamsfx_api_1.DeclarativeCopilotCapabilityName.WebSearch, manifestRes, newCapabilityData);
    }
    async addGCCapability(agentManifestPath, inputConnectionIds, manifestRes) {
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const agentManifest = manifestRes.value;
        if (!agentManifest.capabilities) {
            agentManifest.capabilities = [];
        }
        let capability = agentManifest.capabilities.find((cap) => cap.name === teamsfx_api_1.DeclarativeCopilotCapabilityName.GraphConnectors);
        if (!capability) {
            capability = { name: teamsfx_api_1.DeclarativeCopilotCapabilityName.GraphConnectors, connections: [] };
            agentManifest.capabilities.push(capability);
        }
        if (!capability.connections) {
            capability.connections = [];
        }
        const connections = capability.connections;
        inputConnectionIds.forEach((id) => {
            if (!connections.some((connection) => connection.connection_id === id)) {
                connections.push({ connection_id: id });
            }
        });
        return this.addOrUpdateCapability(agentManifestPath, teamsfx_api_1.DeclarativeCopilotCapabilityName.GraphConnectors, manifestRes, {
            connections,
        });
    }
    /**
     * Updates or adds a capability in the agent manifest.
     *
     * @param agentManifestPath - The path to the agent manifest file.
     * @param capabilityName - The name of the capability to update or add.
     * @param manifestRes - The result containing the agent manifest schema.
     * @param capabilityData - The data for the capability to update or add.
     */
    async addOrUpdateCapability(agentManifestPath, capabilityName, manifestRes, capabilityData) {
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const agentManifest = manifestRes.value;
        if (!agentManifest.capabilities) {
            agentManifest.capabilities = [];
        }
        const newCapability = Object.assign({ name: capabilityName }, capabilityData);
        const capabilityIndex = agentManifest.capabilities.findIndex((cap) => cap.name === capabilityName);
        if (capabilityIndex !== -1) {
            agentManifest.capabilities[capabilityIndex] = newCapability;
        }
        else {
            agentManifest.capabilities.push(newCapability);
        }
        const updateGptManifestRes = await this.writeCopilotGptManifestFile(agentManifest, agentManifestPath);
        if (updateGptManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(updateGptManifestRes.error);
        }
        else {
            return (0, teamsfx_api_1.ok)(agentManifest);
        }
    }
}
exports.CopilotGptManifestUtils = CopilotGptManifestUtils;
exports.copilotGptManifestUtils = new CopilotGptManifestUtils();
//# sourceMappingURL=CopilotGptManifestUtils.js.map