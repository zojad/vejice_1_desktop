"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var CreateAppPackageDriver_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateAppPackageDriver = exports.actionName = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const typedi_1 = require("typedi");
const uuid = tslib_1.__importStar(require("uuid"));
const featureFlags_1 = require("../../../common/featureFlags");
const globalVars_1 = require("../../../common/globalVars");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../../error/common");
const teamsApp_1 = require("../../../error/teamsApp");
const common_2 = require("../../utils/common");
const envFunctionUtils_1 = require("../../utils/envFunctionUtils");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const utils_1 = require("../util/utils");
const wrapUtil_1 = require("../util/wrapUtil");
const constants_1 = require("./constants");
const CopilotGptManifestUtils_1 = require("./utils/CopilotGptManifestUtils");
const ManifestUtils_1 = require("./utils/ManifestUtils");
const utils_2 = require("./utils/utils");
exports.actionName = "teamsApp/zipAppPackage";
let CreateAppPackageDriver = CreateAppPackageDriver_1 = class CreateAppPackageDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.description.createAppPackageDriver");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.createPackage.progressBar.message");
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, exports.actionName, exports.actionName);
        const res = await this.build(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async build(args, context) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const result = this.validateArgs(args);
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        // TODO: use constant after previous pr merged
        const generatedFolder = path.join(context.projectPath, "appPackage", ".generated");
        const hasTTKGeneratedFolder = fs_extra_1.default.existsSync(generatedFolder) && fs_extra_1.default.existsSync(path.join(generatedFolder, "manifest.json"));
        let manifestPath = hasTTKGeneratedFolder
            ? path.join(generatedFolder, "manifest.json")
            : args.manifestPath;
        if (!path.isAbsolute(manifestPath)) {
            manifestPath = path.join(context.projectPath, manifestPath);
        }
        const manifestRes = await ManifestUtils_1.manifestUtils.getManifestV3(manifestPath, context);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const manifest = manifestRes.value;
        // Deal with relative path
        // Environment variables should have been replaced by value
        // ./build/appPackage/appPackage.dev.zip instead of ./build/appPackage/appPackage.${{TEAMSFX_ENV}}.zip
        const zipFileName = (0, common_2.getAbsolutePath)(args.outputZipPath, context.projectPath);
        const zipFileDir = path.dirname(zipFileName);
        await fs_extra_1.default.mkdir(zipFileDir, { recursive: true });
        let jsonFileDir;
        let teamsManifestJsonFileName;
        const shouldwriteAllManifest = !!args.outputFolder;
        if (args.outputJsonPath) {
            teamsManifestJsonFileName = (0, common_2.getAbsolutePath)(args.outputJsonPath, context.projectPath);
            jsonFileDir = path.dirname(teamsManifestJsonFileName);
        }
        else {
            jsonFileDir = (0, common_2.getAbsolutePath)(args.outputFolder, context.projectPath);
            teamsManifestJsonFileName = path.join(jsonFileDir, `manifest.${process.env.TEAMSFX_ENV}.json`);
        }
        await fs_extra_1.default.mkdir(jsonFileDir, { recursive: true });
        const appDirectory = path.dirname(hasTTKGeneratedFolder ? generatedFolder : manifestPath);
        // check and include all relative file paths in manifest
        const relativeFiles = [manifest.icons.color, manifest.icons.outline];
        const manifestVersion = manifest.manifestVersion === "devPreview"
            ? semver_1.default.coerce("1.19.0") // for MetaOS WXP, fallback the `devPreview` ver as `1.19.0` to enable following logics
            : semver_1.default.coerce(manifest.manifestVersion); // ensure manifestVersion is a valid semver
        if (manifestVersion && semver_1.default.gte(manifestVersion, "1.21.0")) {
            const color32x32 = manifest.icons.color32x32;
            if (color32x32) {
                relativeFiles.push(color32x32);
            }
        }
        for (const file of relativeFiles) {
            const filePath = path.resolve(appDirectory, file);
            if (!(await fs_extra_1.default.pathExists(filePath))) {
                const error = new common_1.FileNotFoundError(exports.actionName, filePath, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage");
                return (0, teamsfx_api_1.err)(error);
            }
            const fileRelativePath = path.relative(appDirectory, filePath);
            if (fileRelativePath.startsWith("..")) {
                return (0, teamsfx_api_1.err)(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(filePath));
            }
        }
        // pre-check existence
        let additionalLanguages;
        if (manifestVersion && semver_1.default.gte(manifestVersion, "1.5.0")) {
            additionalLanguages = (_a = manifest.localizationInfo) === null || _a === void 0 ? void 0 : _a.additionalLanguages;
        }
        let composeExtensionType;
        let apiSpecificationFile;
        let commands;
        if (manifestVersion && semver_1.default.gte(manifestVersion, "1.17.0")) {
            composeExtensionType = (_c = (_b = manifest
                .composeExtensions) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.composeExtensionType;
            apiSpecificationFile = (_e = (_d = manifest
                .composeExtensions) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.apiSpecificationFile;
            commands = (_g = (_f = manifest.composeExtensions) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.commands;
        }
        let defaultLanguageFile;
        let declarativeAgents;
        if (manifestVersion && semver_1.default.gte(manifestVersion, "1.19.0")) {
            defaultLanguageFile = (_h = manifest.localizationInfo) === null || _h === void 0 ? void 0 : _h.defaultLanguageFile;
            declarativeAgents = (_j = manifest.copilotAgents) === null || _j === void 0 ? void 0 : _j.declarativeAgents;
        }
        if (additionalLanguages && additionalLanguages.length > 0) {
            for (const language of additionalLanguages) {
                const file = language.file;
                const fileName = path.join(appDirectory, file);
                if (!(await fs_extra_1.default.pathExists(fileName))) {
                    return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(exports.actionName, fileName, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
                }
            }
        }
        if (defaultLanguageFile) {
            const fileName = path.join(appDirectory, defaultLanguageFile);
            if (!(await fs_extra_1.default.pathExists(fileName))) {
                return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(exports.actionName, fileName, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
            }
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_1.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest, null, 4)));
        // icon images, relative path
        for (const icon of relativeFiles) {
            const dir = path.dirname(icon);
            zip.addLocalFile(path.resolve(appDirectory, icon), dir === "." ? "" : dir);
        }
        // localization file
        if (additionalLanguages && additionalLanguages.length > 0) {
            for (const language of additionalLanguages) {
                const file = language.file;
                const fileName = path.resolve(appDirectory, file);
                const relativePath = path.relative(appDirectory, fileName);
                if (relativePath.startsWith("..")) {
                    return (0, teamsfx_api_1.err)(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(fileName));
                }
                const resolvedLocFileRes = await ManifestUtils_1.manifestUtils.resolveLocFile(fileName);
                if (resolvedLocFileRes.isErr()) {
                    return (0, teamsfx_api_1.err)(resolvedLocFileRes.error);
                }
                if (resolvedLocFileRes.value) {
                    zip.addFile(relativePath, Buffer.from(resolvedLocFileRes.value));
                }
            }
        }
        if (defaultLanguageFile) {
            const fileName = path.resolve(appDirectory, defaultLanguageFile);
            const relativePath = path.relative(appDirectory, fileName);
            if (relativePath.startsWith("..")) {
                return (0, teamsfx_api_1.err)(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(fileName));
            }
            const resolvedLocFileRes = await ManifestUtils_1.manifestUtils.resolveLocFile(fileName);
            if (resolvedLocFileRes.isErr()) {
                return (0, teamsfx_api_1.err)(resolvedLocFileRes.error);
            }
            if (resolvedLocFileRes.value) {
                zip.addFile(relativePath, Buffer.from(resolvedLocFileRes.value));
            }
        }
        // API ME, API specification and Adaptive card templates
        if (composeExtensionType == "apiBased" && apiSpecificationFile) {
            const apiSpecificationFilePath = path.resolve(appDirectory, apiSpecificationFile);
            const checkExistenceRes = await this.validateReferencedFile(apiSpecificationFilePath, appDirectory);
            if (checkExistenceRes.isErr()) {
                return (0, teamsfx_api_1.err)(checkExistenceRes.error);
            }
            const addFileWithVariableRes = await this.addFileWithVariable(zip, apiSpecificationFile, apiSpecificationFilePath, envFunctionUtils_1.ManifestType.ApiSpec, context);
            if (addFileWithVariableRes.isErr()) {
                return (0, teamsfx_api_1.err)(addFileWithVariableRes.error);
            }
            if (commands && commands.length > 0) {
                for (const command of commands) {
                    if (command.apiResponseRenderingTemplateFile) {
                        const adaptiveCardFile = path.resolve(appDirectory, command.apiResponseRenderingTemplateFile);
                        const checkExistenceRes = await this.validateReferencedFile(adaptiveCardFile, appDirectory);
                        if (checkExistenceRes.isErr()) {
                            return (0, teamsfx_api_1.err)(checkExistenceRes.error);
                        }
                        const dir = path.dirname(command.apiResponseRenderingTemplateFile);
                        this.addFileInZip(zip, dir, adaptiveCardFile);
                    }
                }
            }
        }
        // Copilot GPT
        if ((declarativeAgents === null || declarativeAgents === void 0 ? void 0 : declarativeAgents.length) && declarativeAgents[0].file) {
            const declarativeAgentManifestFile = path.resolve(hasTTKGeneratedFolder ? generatedFolder : appDirectory, declarativeAgents[0].file);
            const checkExistenceRes = await this.validateReferencedFile(declarativeAgentManifestFile, appDirectory);
            if (checkExistenceRes.isErr()) {
                return (0, teamsfx_api_1.err)(checkExistenceRes.error);
            }
            const addFileWithVariableRes = await this.addFileWithVariable(zip, declarativeAgents[0].file, declarativeAgentManifestFile, envFunctionUtils_1.ManifestType.DeclarativeCopilotManifest, context, shouldwriteAllManifest
                ? path.join(jsonFileDir, path.relative(appDirectory, declarativeAgentManifestFile))
                : undefined);
            if (addFileWithVariableRes.isErr()) {
                return (0, teamsfx_api_1.err)(addFileWithVariableRes.error);
            }
            const getCopilotGptRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.getManifest(declarativeAgentManifestFile, context);
            if (getCopilotGptRes.isOk()) {
                // Add action files
                if (getCopilotGptRes.value.actions) {
                    const pluginFiles = getCopilotGptRes.value.actions.map((action) => action.file);
                    for (const pluginFile of pluginFiles) {
                        const pluginFileAbsolutePath = path.resolve(path.dirname(declarativeAgentManifestFile), pluginFile);
                        const pluginFileRelativePath = path.relative(hasTTKGeneratedFolder ? generatedFolder : appDirectory, pluginFileAbsolutePath);
                        const useForwardSlash = declarativeAgents[0].file.concat(pluginFile).includes("/");
                        const addPluginRes = await this.addPlugin(zip, (0, utils_2.normalizePath)(pluginFileRelativePath, useForwardSlash), hasTTKGeneratedFolder ? generatedFolder : appDirectory, context, !shouldwriteAllManifest ? undefined : jsonFileDir, hasTTKGeneratedFolder ? appDirectory : undefined);
                        if (addPluginRes.isErr()) {
                            return (0, teamsfx_api_1.err)(addPluginRes.error);
                        }
                    }
                }
                // Add embedded knowledge files
                if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.EmbeddedKnowledgeEnabled)) {
                    if (getCopilotGptRes.value.capabilities) {
                        const embeddedKnowledgeCapabilities = getCopilotGptRes.value.capabilities.filter((capability) => capability.name === teamsfx_api_1.DeclarativeCopilotCapabilityName.EmbeddedKnowledge);
                        if (embeddedKnowledgeCapabilities.length > 0) {
                            const fileSet = new Set();
                            for (const capability of embeddedKnowledgeCapabilities) {
                                const embeddedCapability = capability;
                                if (embeddedCapability.files) {
                                    for (const file of embeddedCapability.files) {
                                        if (file.file) {
                                            fileSet.add(file.file);
                                        }
                                    }
                                }
                            }
                            const fileArr = Array.from(fileSet);
                            if (fileArr.length > 0) {
                                for (const file of fileArr) {
                                    const knowledgeFileAbsolutePath = path.resolve(appDirectory, file);
                                    // check existence
                                    const checkExistenceRes = await this.validateReferencedFile(knowledgeFileAbsolutePath, appDirectory);
                                    if (checkExistenceRes.isErr()) {
                                        return (0, teamsfx_api_1.err)(checkExistenceRes.error);
                                    }
                                    const dir = path.dirname(file);
                                    zip.addLocalFile(knowledgeFileAbsolutePath, dir === "." ? "" : dir);
                                }
                            }
                        }
                    }
                }
            }
            else {
                return (0, teamsfx_api_1.err)(getCopilotGptRes.error);
            }
        }
        zip.writeZip(zipFileName);
        await this.writeJsonFile(teamsManifestJsonFileName, JSON.stringify(manifest, null, 4));
        const builtSuccess = [
            { content: "(âˆš)Done: ", color: teamsfx_api_1.Colors.BRIGHT_GREEN },
            { content: "App Package ", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
            { content: zipFileName, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
            { content: " built successfully!", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
        ];
        context.logProvider.info(builtSuccess);
        return (0, teamsfx_api_1.ok)(new Map());
    }
    static async expandEnvVars(filePath, ctx, manifestType) {
        const content = await fs_extra_1.default.readFile(filePath, "utf8");
        return (0, utils_2.getResolvedManifest)(content, filePath, manifestType, ctx);
    }
    validateArgs(args) {
        const invalidParams = [];
        if (!args || !args.manifestPath) {
            invalidParams.push("manifestPath");
        }
        if (!args || (!args.outputJsonPath && !args.outputFolder)) {
            invalidParams.push("outputJsonPath or outputFolder");
        }
        if (!args || !args.outputZipPath) {
            invalidParams.push("outputZipPath");
        }
        if (invalidParams.length > 0) {
            return (0, teamsfx_api_1.err)(new common_1.InvalidActionInputError(exports.actionName, invalidParams, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
        }
        else {
            return (0, teamsfx_api_1.ok)(undefined);
        }
    }
    async validateReferencedFile(file, directory) {
        if (!(await fs_extra_1.default.pathExists(file))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(exports.actionName, file, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
        }
        const relativePath = path.relative(directory, file);
        if (relativePath.startsWith("..")) {
            return (0, teamsfx_api_1.err)(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(file));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * Add plugin file and plugin related files to zip.
     * @param zip zip
     * @param pluginRelativePath plugin file path relative to app package folder
     * @param appDirectory app package path containing manifest template.
     * @param context context
     * @param outputDirectory optional. Folder where we should put the resolved manifest in.
     * @returns result of adding plugin file and plugin related files
     */
    async addPlugin(zip, pluginRelativePath, appDirectory, context, outputDirectory, defaultAppDirectry) {
        var _a, _b, _c, _d;
        const pluginFile = path.resolve(appDirectory, pluginRelativePath);
        const checkExistenceRes = await this.validateReferencedFile(pluginFile, appDirectory);
        if (checkExistenceRes.isErr()) {
            return (0, teamsfx_api_1.err)(checkExistenceRes.error);
        }
        let pluginFileContent;
        try {
            pluginFileContent = (await fs_extra_1.default.readJSON(pluginFile));
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.JSONSyntaxError(pluginFile, e, exports.actionName));
        }
        let containExternalAdaptiveCard = false;
        if (pluginFileContent.functions) {
            for (const func of pluginFileContent.functions) {
                if ((_c = (_b = (_a = func.capabilities) === null || _a === void 0 ? void 0 : _a.response_semantics) === null || _b === void 0 ? void 0 : _b.static_template) === null || _c === void 0 ? void 0 : _c.file) {
                    const staticTemplateFile = await this.getAdaptiveCardTemplateFile(context, pluginFile, func, appDirectory, defaultAppDirectry);
                    if (!staticTemplateFile) {
                        continue;
                    }
                    if (Object.keys(func.capabilities.response_semantics.static_template).length > 1) {
                        context.logProvider.warning((0, localizeUtils_1.getLocalizedString)("plugins.appstudio.createPackage.aiPlugin.overrideWarning", pluginFile, func.name));
                    }
                    const staticTemplateFileContent = await fs_extra_1.default.readJSON(staticTemplateFile);
                    func.capabilities.response_semantics.static_template = staticTemplateFileContent;
                    containExternalAdaptiveCard = true;
                }
            }
        }
        let tmpPluginFile = pluginFile;
        let tempFolder;
        let namespaceContainsUnderscore = false;
        if ((_d = pluginFileContent.namespace) === null || _d === void 0 ? void 0 : _d.includes("_")) {
            pluginFileContent.namespace = pluginFileContent.namespace.replace(/_/g, "");
            namespaceContainsUnderscore = true;
            context.logProvider.warning((0, localizeUtils_1.getLocalizedString)("plugins.appstudio.createPackage.aiPlugin.containsUnderscore", pluginRelativePath));
        }
        if (containExternalAdaptiveCard) {
            await (0, utils_1.updateVersionForTeamsAppYamlFile)(context.projectPath);
        }
        if (namespaceContainsUnderscore || containExternalAdaptiveCard) {
            tempFolder = path.join(appDirectory, ".tmp");
            await fs_extra_1.default.ensureDir(tempFolder);
            tmpPluginFile = path.join(tempFolder, `tmp-ai-plugin-${uuid.v4().slice(0, 6)}.json`);
            const processedFunctionRes = await (0, envFunctionUtils_1.expandVariableWithFunction)(JSON.stringify(pluginFileContent), context, undefined, true, envFunctionUtils_1.ManifestType.PluginManifest, pluginFile);
            if (processedFunctionRes.isErr()) {
                return (0, teamsfx_api_1.err)(processedFunctionRes.error);
            }
            pluginFileContent = JSON.parse(processedFunctionRes.value);
            await fs_extra_1.default.writeJSON(tmpPluginFile, pluginFileContent, { spaces: 4 });
        }
        const addFileWithVariableRes = await this.addFileWithVariable(zip, pluginRelativePath, tmpPluginFile, envFunctionUtils_1.ManifestType.PluginManifest, context, !outputDirectory
            ? undefined
            : path.join(outputDirectory, path.relative(appDirectory, pluginFile)));
        if (containExternalAdaptiveCard && tmpPluginFile !== pluginFile && tempFolder) {
            await fs_extra_1.default.remove(tempFolder);
        }
        if (addFileWithVariableRes.isErr()) {
            return (0, teamsfx_api_1.err)(addFileWithVariableRes.error);
        }
        const addFilesRes = await this.addPluginRelatedFiles(zip, pluginRelativePath, appDirectory, context);
        if (addFilesRes.isErr()) {
            return (0, teamsfx_api_1.err)(addFilesRes.error);
        }
        else {
            return (0, teamsfx_api_1.ok)(undefined);
        }
    }
    /**
     * Add plugin related files (OpenAPI spec) to zip.
     * @param zip zip.
     * @param pluginFile plugin file path relative to app package folder.
     * @param appDirectory app package folder.
     * @param context context.
     * @returns results whether add files related to plugin is successful.
     */
    async addPluginRelatedFiles(zip, pluginFile, appDirectory, context) {
        var _a;
        const pluginFilePath = path.join(appDirectory, pluginFile);
        const pluginContent = (await fs_extra_1.default.readJSON(pluginFilePath));
        const runtimes = pluginContent.runtimes;
        if (runtimes && runtimes.length > 0) {
            for (const runtime of runtimes) {
                if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
                    const specFile = path.resolve(path.dirname(pluginFilePath), runtime.spec.url);
                    // add openapi spec
                    const checkExistenceRes = await this.validateReferencedFile(specFile, appDirectory);
                    if (checkExistenceRes.isErr()) {
                        return (0, teamsfx_api_1.err)(checkExistenceRes.error);
                    }
                    const entryName = path.relative(appDirectory, specFile);
                    const useForwardSlash = pluginFile.concat(runtime.spec.url).includes("/");
                    const addFileWithVariableRes = await this.addFileWithVariable(zip, (0, utils_2.normalizePath)(entryName, useForwardSlash), specFile, envFunctionUtils_1.ManifestType.ApiSpec, context);
                    if (addFileWithVariableRes.isErr()) {
                        return (0, teamsfx_api_1.err)(addFileWithVariableRes.error);
                    }
                }
            }
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    async addFileWithVariable(zip, entryName, filePath, manifestType, context, outputPath // If outputPath exists, we will write down the file after replacing placeholders.
    ) {
        const expandedEnvVarResult = await CreateAppPackageDriver_1.expandEnvVars(filePath, context, manifestType);
        if (expandedEnvVarResult.isErr()) {
            return (0, teamsfx_api_1.err)(expandedEnvVarResult.error);
        }
        const content = expandedEnvVarResult.value;
        const attr = await fs_extra_1.default.stat(filePath);
        zip.addFile(entryName, Buffer.from(content), "", attr.mode);
        if (outputPath && path.extname(outputPath).toLowerCase() === ".json") {
            await this.writeJsonFile(`${outputPath.substring(0, outputPath.length - 5)}.${process.env.TEAMSFX_ENV}.json`, content);
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    addFileInZip(zip, zipPath, filePath) {
        zip.addLocalFile(filePath, zipPath === "." ? "" : zipPath);
    }
    async writeJsonFile(jsonFileName, content) {
        if (await fs_extra_1.default.pathExists(jsonFileName)) {
            await fs_extra_1.default.chmod(jsonFileName, 0o777);
        }
        await fs_extra_1.default.ensureDir(path.dirname(jsonFileName));
        await fs_extra_1.default.writeFile(jsonFileName, content);
        await fs_extra_1.default.chmod(jsonFileName, 0o444);
    }
    async getAdaptiveCardTemplateFile(context, pluginFile, func, appDirectory, defaultAppDirectry) {
        let staticTemplateFile = path.resolve(defaultAppDirectry !== null && defaultAppDirectry !== void 0 ? defaultAppDirectry : path.dirname(pluginFile), func.capabilities.response_semantics.static_template.file);
        let checkExistenceRes = await this.validateReferencedFile(staticTemplateFile, defaultAppDirectry !== null && defaultAppDirectry !== void 0 ? defaultAppDirectry : appDirectory);
        if (checkExistenceRes.isOk()) {
            return staticTemplateFile;
        }
        if (defaultAppDirectry) {
            // Try generated folder
            staticTemplateFile = path.resolve(appDirectory, func.capabilities.response_semantics.static_template.file);
            checkExistenceRes = await this.validateReferencedFile(staticTemplateFile, appDirectory);
        }
        if (checkExistenceRes.isErr()) {
            delete func.capabilities.response_semantics.static_template.file;
            context.logProvider.warning((0, localizeUtils_1.getLocalizedString)("plugins.appstudio.createPackage.aiPlugin.invalidFilePropertyWarning", pluginFile, func.name));
            return undefined;
        }
        return staticTemplateFile;
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "CreateAppPackageDriver" }),
        (0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(exports.actionName, exports.actionName),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext]),
    tslib_1.__metadata("design:returntype", Promise)
], CreateAppPackageDriver.prototype, "build", null);
CreateAppPackageDriver = CreateAppPackageDriver_1 = tslib_1.__decorate([
    (0, typedi_1.Service)(exports.actionName)
], CreateAppPackageDriver);
exports.CreateAppPackageDriver = CreateAppPackageDriver;
//# sourceMappingURL=createAppPackage.js.map