"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.pathUtils = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const yaml_1 = tslib_1.__importDefault(require("yaml"));
const versionMetadata_1 = require("../../common/versionMetadata");
const environmentName_1 = require("../../core/environmentName");
const common_1 = require("../../error/common");
class PathUtils {
    getYmlFilePath(projectPath, env, silent = false) {
        if (process.env.TEAMSFX_CONFIG_FILE_PATH)
            return process.env.TEAMSFX_CONFIG_FILE_PATH;
        const envName = env || process.env.TEAMSFX_ENV || "dev";
        const ymlPathV4 = path.join(projectPath, envName === environmentName_1.environmentNameManager.getLocalEnvName()
            ? versionMetadata_1.MetadataV4.localConfigFile
            : envName === environmentName_1.environmentNameManager.getPlaygroundEnvName()
                ? versionMetadata_1.MetadataV4.testToolConfigFile
                : envName === environmentName_1.environmentNameManager.getSandboxEnvName()
                    ? versionMetadata_1.MetadataV4.sandboxConfigFile
                    : versionMetadata_1.MetadataV4.configFile);
        if (fs_extra_1.default.pathExistsSync(ymlPathV4)) {
            return ymlPathV4;
        }
        const ymlPathV3 = path.join(projectPath, envName === environmentName_1.environmentNameManager.getLocalEnvName()
            ? versionMetadata_1.MetadataV3.localConfigFile
            : envName === environmentName_1.environmentNameManager.getTestToolEnvName()
                ? versionMetadata_1.MetadataV3.testToolConfigFile
                : envName === environmentName_1.environmentNameManager.getSandboxEnvName()
                    ? versionMetadata_1.MetadataV3.sandboxConfigFile
                    : versionMetadata_1.MetadataV3.configFile);
        if (fs_extra_1.default.pathExistsSync(ymlPathV3)) {
            return ymlPathV3;
        }
        if (silent)
            return undefined;
        if (environmentName_1.environmentNameManager.isRemoteEnvironment(envName)) {
            throw new common_1.MissingRequiredFileError("core", "", ymlPathV4);
        }
        else {
            throw new common_1.MissingRequiredFileError("core", "Debug ", ymlPathV4);
        }
    }
    async getEnvFolderPath(projectPath) {
        var _a;
        const ymlFilePath = this.getYmlFilePath(projectPath, "dev");
        const ymlContent = await fs_extra_1.default.readFile(ymlFilePath, "utf-8");
        const yamlObj = yaml_1.default.parse(ymlContent);
        const folderPath = ((_a = yamlObj.environmentFolderPath) === null || _a === void 0 ? void 0 : _a.toString()) || "./env";
        const envFolderPath = path.isAbsolute(folderPath)
            ? folderPath
            : path.join(projectPath, folderPath);
        if (!(await fs_extra_1.default.pathExists(envFolderPath)))
            return (0, teamsfx_api_1.ok)(undefined);
        return (0, teamsfx_api_1.ok)(envFolderPath);
    }
    async getEnvFilePath(projectPath, env) {
        const envFolderPathRes = await this.getEnvFolderPath(projectPath);
        if (envFolderPathRes.isErr())
            return (0, teamsfx_api_1.err)(envFolderPathRes.error);
        const folderPath = envFolderPathRes.value;
        if (!folderPath)
            return (0, teamsfx_api_1.ok)(undefined);
        const envFilePath = path.join(folderPath, `.env.${env}`);
        return (0, teamsfx_api_1.ok)(envFilePath);
    }
    resolveFilePath(projectPath, absoluteOrRelativePath) {
        if (!absoluteOrRelativePath)
            return projectPath;
        if (path.isAbsolute(absoluteOrRelativePath))
            return absoluteOrRelativePath;
        return path.join(projectPath, absoluteOrRelativePath);
    }
}
exports.pathUtils = new PathUtils();
//# sourceMappingURL=pathUtils.js.map