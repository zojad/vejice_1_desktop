"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.azureClientHelper = void 0;
const arm_resources_1 = require("@azure/arm-resources");
const error_1 = require("../../error");
const pipelinePolicy_1 = require("./pipelinePolicy");
const constants_1 = require("../../common/constants");
class AzureClientHelper {
    constructor() {
        this.getChallengeHandler = (tokenProvider) => {
            const getTokenForChallenge = async (scopes) => {
                const azureToken = await tokenProvider.getIdentityCredentialAsync(false, scopes);
                if (!azureToken) {
                    throw new error_1.InvalidAzureCredentialError();
                }
                const token = (await azureToken.getToken(constants_1.AzureScopes));
                return token.token;
            };
            return getTokenForChallenge;
        };
    }
    async createRmClient(azureAccountProvider, subscriptionId) {
        const azureToken = await azureAccountProvider.getIdentityCredentialAsync();
        if (azureToken === undefined) {
            throw new error_1.InvalidAzureCredentialError();
        }
        await azureAccountProvider.setSubscription(subscriptionId);
        const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId, {
            userAgentOptions: { userAgentPrefix: "AgentsToolkit" },
        });
        this.addPipelinePolicy(rmClient.pipeline, new pipelinePolicy_1.BearerChallengePolicy(this.getChallengeHandler(azureAccountProvider)));
        return rmClient;
    }
    addPipelinePolicy(pipeline, policy) {
        pipeline.addPolicy(policy, { phase: "Sign" });
    }
}
exports.azureClientHelper = new AzureClientHelper();
//# sourceMappingURL=azureClient.js.map