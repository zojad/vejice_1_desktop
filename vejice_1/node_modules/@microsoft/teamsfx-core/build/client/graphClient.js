"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphClient = exports.RetryHandler = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../common/constants");
const globalState_1 = require("../common/globalState");
const globalVars_1 = require("../common/globalVars");
const localizeUtils_1 = require("../common/localizeUtils");
const utils_1 = require("../common/utils");
const wrappedAxiosClient_1 = require("../common/wrappedAxiosClient");
const listSensitivityLabelAPIPath = "/me/informationProtection/sensitivityLabels";
const errorSourceName = "GraphAPI";
const GeneralLabelDisplayName = "General";
const listSensitivityLabelCacheKeyPrefix = "listSensitivityLabelCacheKey";
class RetryHandler {
    static async Retry(fn) {
        let retries = this.RETRIES;
        let lastError;
        while (retries > 0) {
            retries--;
            try {
                return await fn();
            }
            catch (e) {
                lastError = e;
                if (retries > 0) {
                    await new Promise((resolve) => setTimeout(resolve, 5000));
                }
            }
        }
        throw lastError;
    }
}
exports.RetryHandler = RetryHandler;
RetryHandler.RETRIES = 3;
class GraphClient {
    constructor(tokenProvider, logProvider) {
        var _a;
        this.baseUrl = (_a = process.env.GRAPH_ENDPOINT) !== null && _a !== void 0 ? _a : "https://graph.microsoft.com/beta";
        this.tokenProvider = tokenProvider;
        this.logProvider = logProvider;
    }
    createRequesterWithToken(token) {
        const instance = wrappedAxiosClient_1.WrappedAxiosClient.create({
            baseURL: this.baseUrl,
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${token}`;
        return instance;
    }
    async listSensitivityLabels(token, useCache = false) {
        try {
            const userInfo = await this.getCurrentUserInfo();
            const accountUniqueName = userInfo[0];
            const tenantId = userInfo[1];
            if (useCache && accountUniqueName && tenantId) {
                // TTK supports switching tenant, so we need to add tenantId in the cache key.
                const cacheKey = this.buildCacheKey(accountUniqueName, tenantId);
                const cacheValueRes = await (0, globalState_1.globalStateGet)(cacheKey);
                if (cacheValueRes) {
                    const timeStamp = cacheValueRes.unixTimestamp;
                    // if cache data is within 1 day, use the cache.
                    if (Date.now() - timeStamp < 1000 * 60 * 60 * 24) {
                        return (0, teamsfx_api_1.ok)(cacheValueRes.labels);
                    }
                }
            }
            const requester = wrappedAxiosClient_1.WrappedAxiosClient.create({
                baseURL: this.baseUrl,
            });
            requester.defaults.headers.common["Authorization"] = `Bearer ${token}`;
            requester.defaults.headers.common["Content-Type"] = "application/json";
            const response = await RetryHandler.Retry(() => requester.get(listSensitivityLabelAPIPath));
            if (response && response.data && response.data.value) {
                if (accountUniqueName && tenantId) {
                    // always update the cache if the user is signed in.
                    const cacheKey = this.buildCacheKey(accountUniqueName, tenantId);
                    // only retrieve the necessary properties from the response.data.value
                    const labels = response.data.value.map((label) => ({
                        id: label === null || label === void 0 ? void 0 : label.id,
                        name: label === null || label === void 0 ? void 0 : label.name,
                        description: label === null || label === void 0 ? void 0 : label.description,
                        displayName: label === null || label === void 0 ? void 0 : label.displayName,
                    }));
                    const cacheValue = {
                        labels: labels,
                        unixTimestamp: Date.now(),
                    };
                    await (0, globalState_1.globalStateUpdate)(cacheKey, cacheValue);
                }
                return (0, teamsfx_api_1.ok)(response.data.value);
            }
            else {
                return (0, teamsfx_api_1.err)(new teamsfx_api_1.SystemError({
                    name: "listSensitivityLabelsError",
                    message: (0, localizeUtils_1.getDefaultString)("error.graphAPI.apiFailed.message", "listSensitivityLabels", "empty data"),
                    source: errorSourceName,
                }));
            }
        }
        catch (error) {
            return (0, teamsfx_api_1.err)(new teamsfx_api_1.SystemError({
                name: "listSensitivityLabelsError",
                message: (0, localizeUtils_1.getDefaultString)("error.graphAPI.apiFailed.message", "listSensitivityLabels", error.message),
                source: errorSourceName,
            }));
        }
    }
    async getGeneralSentivityLabel(token) {
        const result = await this.listSensitivityLabels(token);
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        const labels = result.value;
        const generalLabel = labels.find((label) => label.displayName === GeneralLabelDisplayName);
        if (generalLabel && generalLabel.id) {
            return (0, teamsfx_api_1.ok)(generalLabel);
        }
        else {
            return (0, teamsfx_api_1.err)(new teamsfx_api_1.SystemError({
                name: "getGeneralSentivityLabelError",
                message: (0, localizeUtils_1.getDefaultString)("error.graphAPI.apiFailed.message", "getGeneralSentivityLabelId", "General label not found"),
                source: errorSourceName,
            }));
        }
    }
    buildCacheKey(accountUniqueName, tenantId) {
        return `${listSensitivityLabelCacheKeyPrefix}:${tenantId}:${accountUniqueName}`;
    }
    /**
     * Get sandboxing configuration of team app settings.
     * @returns
     */
    async GetTeamsAppSettingsAsync() {
        const tokenResponse = await this.tokenProvider.getAccessToken({
            scopes: constants_1.GraphTeamsAppSettingsReadScopes,
        });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        const response = await requester.get(`/teamwork/teamsAppSettings?$select=sandboxingConfiguration`);
        return response.data;
    }
    async GetJoinedSandboxedTeamsAsync() {
        const tokenResponse = await this.tokenProvider.getAccessToken({
            scopes: constants_1.GraphTeamsTeamReadScopes,
        });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        const response = await requester.get(`/me/joinedTeams?isSandboxedTeam=true`);
        return response.data.value;
    }
    /**
     * Get weburl of a channel.
     * @param teamId
     * @param channelId
     * @returns
     */
    async GetChannelDeeplinkAsync(teamId, channelId) {
        const tokenResponse = await this.tokenProvider.getAccessToken({
            scopes: constants_1.GraphTeamsChannelReadScopes,
        });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        const response = await requester.get(`/teams/${teamId}/channels/${channelId}`);
        const data = response.data;
        return data.webUrl;
    }
    /**
     * Install Teams app package into a channel.
     * @param teamId
     * @param channelId
     * @param file Teams app package zip file
     */
    async InstallAppToChannelAsync(teamId, channelId, file) {
        const tokenResponse = await this.tokenProvider.getAccessToken({
            scopes: constants_1.GraphTeamsInstallAppScopes,
        });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        await requester.post(`/teams/${teamId}/installedApps?targetChannelId=${channelId}`, file, {
            headers: { "Content-Type": "application/zip" },
        });
    }
    /**
     * Get installed apps in a team.
     * @param teamId
     * @returns An array of installed apps, the externalId is the Teams app id.
     */
    async GetAppInstallationForTeam(teamId) {
        const tokenResponse = await this.tokenProvider.getAccessToken({
            scopes: constants_1.GraphTeamsInstallAppScopes,
        });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        const response = await requester.get(`/teams/${teamId}/installedApps?$expand=teamsapp`);
        return response.data.value;
    }
    async DeleteInstalledApp(teamId, installationId) {
        const tokenResponse = await this.tokenProvider.getAccessToken({
            scopes: constants_1.GraphTeamsInstallAppScopes,
        });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        await requester.delete(`/teams/${teamId}/installedApps/${installationId}`);
    }
    /**
     * Create a sandboxed team and a channel.
     * @param teamName Team name
     * @param description Team description
     * @param defaultChannelName Channel name
     * @returns
     */
    async CreateTeamAndChannelAsync(teamName, description, defaultChannelName) {
        var _a;
        const LocationRegex = /teams\('([0-9a-fA-F-]{36})'\)\/operations\('([0-9a-fA-F-]{36})'/;
        const tokenResponse = await this.tokenProvider.getAccessToken({
            scopes: [
                ...constants_1.GraphTeamsTeamCreateScopes,
                ...constants_1.GraphTeamsTeamReadScopes,
                ...constants_1.GraphTeamsChannelReadScopes,
            ],
        });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        const teamData = {
            "template@odata.bind": "https://graph.microsoft.com/beta/teamsTemplates('standard')",
            displayName: teamName,
            description: description,
            firstChannelName: defaultChannelName,
        };
        const response = await requester.post(`/teams?isSandboxedTeam=true`, teamData);
        const location = response.headers.location;
        if (location) {
            // this.logProvider?.info(`Location header: ${location}`);
            const match = location.match(LocationRegex);
            if (match) {
                const teamId = match[1];
                let status = await requester.get(location);
                // Query team creation status, until it's succeeded
                while (status.data.status !== "succeeded") {
                    await (0, utils_1.waitSeconds)(5);
                    const message = (0, localizeUtils_1.getLocalizedString)("driver.devChannel.status", status.data.status);
                    (_a = this.logProvider) === null || _a === void 0 ? void 0 : _a.info(message);
                    status = await requester.get(location);
                }
                // Get Channel ID
                const channels = await this.GetChannelsInTeamAsync(teamId);
                const channel = channels.find((channel) => channel.displayName === defaultChannelName);
                if (channel) {
                    const channelId = channel.id;
                    return {
                        teamId: teamId,
                        channelId: channelId,
                    };
                }
                else {
                    throw new Error(`Failed to find channel with name: ${defaultChannelName}`);
                }
            }
            else {
                throw new Error("Failed to parse location header.");
            }
        }
        else {
            throw new Error("Failed to create team and channel.");
        }
    }
    async CreateChannelAsync(teamId, channelName, description) {
        const tokenResponse = await this.tokenProvider.getAccessToken({
            scopes: constants_1.GraphTeamsChannelCreateScopes,
        });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        const channelData = {
            displayName: channelName,
            description: description,
            membershipType: "standard",
        };
        const response = await requester.post(`/teams/${teamId}/channels`, channelData);
        return response.data;
    }
    /**
     * List channels in a team
     * @param teamId Team ID
     * @returns A list of channels, with id and webUrl
     */
    async GetChannelsInTeamAsync(teamId) {
        const tokenResponse = await this.tokenProvider.getAccessToken({
            scopes: constants_1.GraphTeamsChannelReadScopes,
        });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        const response = await requester.get(`/teams/${teamId}/channels`);
        return response.data.value;
    }
    /**
     * Get current user info
     * @returns unique name and tenant id in string array
     */
    async getCurrentUserInfo() {
        // check if user has already logged in to the sensitivity label scope
        const loginStatusRes = await this.tokenProvider.getStatus({
            scopes: [constants_1.ListSensitivityLabelScope],
        });
        if (!loginStatusRes ||
            loginStatusRes.isErr() ||
            loginStatusRes.value.status != teamsfx_api_1.signedIn ||
            !loginStatusRes.value.token) {
            return ["", ""];
        }
        let accountUniqueName = "";
        let tenantId = "";
        const accountInfo = loginStatusRes.value.accountInfo;
        if (typeof (accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo["unique_name"]) === "string") {
            accountUniqueName = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo["unique_name"];
        }
        if (typeof (accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo["tid"]) === "string") {
            tenantId = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo["tid"];
        }
        return [accountUniqueName, tenantId];
    }
    async getUserInfoFromId(id) {
        const tokenResponse = await this.tokenProvider.getAccessToken({ scopes: constants_1.GraphScopes });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        const response = await requester.get(`/users/${id}`);
        if (!response || !response.data) {
            return undefined;
        }
        return response.data;
    }
    async getGroupInfo(email) {
        const tokenResponse = await this.tokenProvider.getAccessToken({ scopes: constants_1.GroupSearchScopes });
        if (tokenResponse.isErr()) {
            throw tokenResponse.error;
        }
        const requester = this.createRequesterWithToken(tokenResponse.value);
        const res = await requester.get(`/groups?$filter=startsWith(mail,'${email}')`);
        if (!res || !res.data || !res.data.value) {
            return undefined;
        }
        const group = res.data.value.find((group) => { var _a; return ((_a = group.mail) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === email.toLowerCase(); });
        if (!group) {
            return undefined;
        }
        return group;
    }
}
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "GraphAPIClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], GraphClient.prototype, "listSensitivityLabels", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "GraphClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], GraphClient.prototype, "GetTeamsAppSettingsAsync", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "GraphClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], GraphClient.prototype, "GetJoinedSandboxedTeamsAsync", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "GraphClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], GraphClient.prototype, "GetChannelDeeplinkAsync", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "GraphClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, Buffer]),
    tslib_1.__metadata("design:returntype", Promise)
], GraphClient.prototype, "InstallAppToChannelAsync", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "GraphClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], GraphClient.prototype, "CreateTeamAndChannelAsync", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "GraphClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], GraphClient.prototype, "CreateChannelAsync", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "GraphClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], GraphClient.prototype, "GetChannelsInTeamAsync", null);
exports.GraphClient = GraphClient;
//# sourceMappingURL=graphClient.js.map