"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateOpenAPISpec = exports.listAPIInfo = exports.parseAndUpdatePluginManifestForKiota = exports.generatePlugin = void 0;
const tslib_1 = require("tslib");
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const featureFlags_1 = require("./featureFlags");
const kiotaClient_1 = require("./kiotaClient");
const kiota_1 = require("@microsoft/kiota");
const fs = tslib_1.__importStar(require("fs-extra"));
const tmp_1 = tslib_1.__importDefault(require("tmp"));
const crypto_1 = require("crypto");
const path_1 = tslib_1.__importDefault(require("path"));
const localizeUtils_1 = require("./localizeUtils");
const daProjectConfig = {
    projectType: m365_spec_parser_1.ProjectType.Copilot,
    isGptPlugin: true,
    allowMultipleParameters: true,
    allowMissingId: true,
    allowSwagger: true,
    allowAPIKeyAuth: true,
    allowBearerTokenAuth: true,
    allowOauth2: true,
    allowMethods: ["get", "post", "put", "delete", "patch", "head", "connect", "options", "trace"],
    allowResponseSemantics: true,
};
async function generatePlugin(specPath, teamsManifestPath, outputAPISpecPath, outputAIPluginPath, operations, adaptiveCardUpdateStrategy, platform, updateExistingPlugin = false) {
    var _a, _b, _c, _d, _e, _f;
    const allowAPIKeyAuth = platform !== teamsfx_api_1.Platform.VS;
    const allowBearerTokenAuth = platform !== teamsfx_api_1.Platform.VS;
    const allowOauth2 = platform !== teamsfx_api_1.Platform.VS;
    if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaNPMIntegration)) {
        const warnings = [];
        const tmpWorkingDir = tmp_1.default.dirSync({ unsafeCleanup: true });
        const tmpOutputDir = path_1.default.join(tmpWorkingDir.name, "plugin");
        const manifest = await fs.readJSON(teamsManifestPath);
        const namespace = removeEnvsAndSpecialCharaters(manifest.name.short);
        const includePatterns = [];
        for (const operation of operations) {
            const [method, path] = operation.split(" ");
            includePatterns.push(`${path}#${method}`);
        }
        const treeInfo = await (0, kiotaClient_1.listAPITreeInfo)(specPath, includePatterns);
        const operationInfos = extractOperations(treeInfo);
        for (let i = 0; i < operationInfos.length; i++) {
            const operationId = operationInfos[i].operationId;
            if (!operationId) {
                warnings.push({
                    type: m365_spec_parser_1.WarningType.OperationIdMissing,
                    content: m365_spec_parser_1.Utils.format(m365_spec_parser_1.ConstantString.MissingOperationId, operationInfos[i].api),
                    data: operationInfos[i].api,
                });
            }
            else {
                const containsSpecialCharacters = /[^a-zA-Z0-9_]/.test(operationId);
                const safeOperationId = operationId.replace(/[^a-zA-Z0-9]/g, "_");
                if (containsSpecialCharacters) {
                    warnings.push({
                        type: m365_spec_parser_1.WarningType.OperationIdContainsSpecialCharacters,
                        content: m365_spec_parser_1.Utils.format(m365_spec_parser_1.ConstantString.OperationIdContainsSpecialCharacters, operationId, safeOperationId),
                        data: operationId,
                    });
                }
            }
            const authScheme = (_a = operationInfos[i].auth) === null || _a === void 0 ? void 0 : _a.authScheme;
            if (authScheme) {
                if (!isAuthTypeSupported(authScheme, allowAPIKeyAuth, allowBearerTokenAuth, allowOauth2)) {
                    warnings.push({
                        type: m365_spec_parser_1.WarningType.UnsupportedAuthType,
                        content: m365_spec_parser_1.Utils.format(m365_spec_parser_1.ConstantString.AuthTypeIsNotSupported, operationId),
                        data: operationId,
                    });
                }
            }
            // TODO: add logs when kiota update the spec version, wait for kiota api
        }
        const kiotaGenerateResult = await (0, kiotaClient_1.kiotageneratePlugin)(specPath, tmpOutputDir, namespace, tmpWorkingDir.name, undefined, undefined, includePatterns, []);
        const apiSpecPath = kiotaGenerateResult.openAPISpec;
        const pluginPath = kiotaGenerateResult.aiPlugin;
        const extname = path_1.default.extname(outputAPISpecPath);
        if (!updateExistingPlugin) {
            const outputSpecWithoutExt = path_1.default.join(path_1.default.dirname(outputAPISpecPath), path_1.default.basename(outputAPISpecPath, extname));
            outputAPISpecPath = outputSpecWithoutExt + ".yaml";
        }
        await fs.copy(apiSpecPath, outputAPISpecPath);
        const adaptiveCardsFolder = path_1.default.join(path_1.default.dirname(apiSpecPath), "adaptiveCards");
        const destAdaptiveCardsFolder = path_1.default.join(path_1.default.dirname(outputAIPluginPath), "adaptiveCards");
        if (await fs.pathExists(adaptiveCardsFolder)) {
            await fs.copy(adaptiveCardsFolder, destAdaptiveCardsFolder, {
                overwrite: !updateExistingPlugin,
                errorOnExist: false,
            });
        }
        const relativePath = path_1.default.relative(path_1.default.dirname(outputAIPluginPath), outputAPISpecPath);
        const normalizedPath = relativePath.replace(/\\/g, "/");
        const generatedPluginManifest = (await fs.readJSON(pluginPath));
        if (!updateExistingPlugin) {
            const originalSpecFolder = path_1.default.join(tmpWorkingDir.name, `.kiota/documents/${namespace}/`);
            const files = await fs.readdir(originalSpecFolder);
            const originalSpecFilename = files[0];
            const originalSpecFile = path_1.default.join(originalSpecFolder, originalSpecFilename);
            const outputOriginalSpecPath = outputAPISpecPath + ".original";
            await fs.copy(originalSpecFile, outputOriginalSpecPath);
            (_b = generatedPluginManifest.runtimes) === null || _b === void 0 ? void 0 : _b.forEach((runtime) => {
                runtime.spec.url = normalizedPath;
            });
            await fs.writeJson(outputAIPluginPath, generatedPluginManifest, { spaces: 4 });
        }
        else {
            const existingPluginManifest = (await fs.readJSON(outputAIPluginPath));
            const functionNamesToRemove = new Set();
            (_c = existingPluginManifest.runtimes) === null || _c === void 0 ? void 0 : _c.forEach((runtime) => {
                const runtimeObj = runtime;
                if (runtimeObj.spec.url === normalizedPath && runtimeObj.run_for_functions) {
                    runtimeObj.run_for_functions.forEach((name) => functionNamesToRemove.add(name));
                }
            });
            if (existingPluginManifest.functions) {
                existingPluginManifest.functions = existingPluginManifest.functions
                    .filter((f) => !functionNamesToRemove.has(f.name))
                    .concat((_d = generatedPluginManifest.functions) !== null && _d !== void 0 ? _d : []);
            }
            else {
                existingPluginManifest.functions = (_e = generatedPluginManifest.functions) !== null && _e !== void 0 ? _e : [];
            }
            const runtimes = existingPluginManifest.runtimes;
            existingPluginManifest.runtimes = runtimes === null || runtimes === void 0 ? void 0 : runtimes.filter((r) => r.spec.url !== normalizedPath);
            for (const runtime of generatedPluginManifest.runtimes) {
                runtime.spec.url = normalizedPath;
                (_f = existingPluginManifest.runtimes) === null || _f === void 0 ? void 0 : _f.push(runtime);
            }
            await fs.writeJson(outputAIPluginPath, existingPluginManifest, { spaces: 4 });
        }
        await parseAndUpdatePluginManifestForKiota(outputAIPluginPath, true);
        return {
            allSuccess: true,
            warnings: warnings,
        };
    }
    const options = Object.assign(Object.assign({}, daProjectConfig), { allowAPIKeyAuth,
        allowBearerTokenAuth,
        allowOauth2 });
    const parser = new m365_spec_parser_1.SpecParser(specPath, options);
    const result = await parser.generateForCopilot(teamsManifestPath, operations, outputAPISpecPath, outputAIPluginPath, undefined, undefined, adaptiveCardUpdateStrategy);
    return result;
}
exports.generatePlugin = generatePlugin;
async function parseAndUpdatePluginManifestForKiota(pluginManifestPath, updatePlaceholder) {
    var _a;
    const authData = [];
    const pluginManifest = (await fs.readJSON(pluginManifestPath));
    (_a = pluginManifest.runtimes) === null || _a === void 0 ? void 0 : _a.forEach((runtime) => {
        if (runtime.auth) {
            const auth = runtime.auth;
            if (auth.reference_id &&
                auth.reference_id.match(/^{\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*}/g) &&
                auth.type !== "None") {
                const registrationId = auth.reference_id.replace(/[{}]/g, "");
                const parts = registrationId.split("_");
                const authName = parts.slice(0, -2).join("_");
                const newReferenceId = authName.toUpperCase() + "_" + m365_spec_parser_1.ConstantString.RegistrationIdPostfix;
                authData.push({
                    authName: authName,
                    authType: auth.type === "ApiKeyPluginVault" ? "apiKey" : "oauth2",
                    registrationId: newReferenceId,
                    specPath: runtime.spec.url,
                });
                if (updatePlaceholder) {
                    auth.reference_id = `\$\{\{${newReferenceId}\}\}`;
                }
            }
        }
    });
    if (updatePlaceholder && authData.length > 0) {
        await fs.writeJson(pluginManifestPath, pluginManifest, { spaces: 4 });
    }
    return authData;
}
exports.parseAndUpdatePluginManifestForKiota = parseAndUpdatePluginManifestForKiota;
async function listAPIInfo(specPath, platform) {
    const allowAPIKeyAuth = platform !== teamsfx_api_1.Platform.VS;
    const allowBearerTokenAuth = platform !== teamsfx_api_1.Platform.VS;
    const allowOauth2 = platform !== teamsfx_api_1.Platform.VS;
    if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaNPMIntegration)) {
        const treeInfo = await (0, kiotaClient_1.listAPITreeInfo)(specPath);
        const operations = extractOperations(treeInfo);
        for (const operation of operations) {
            if (!operation.server) {
                operation.reason.push(m365_spec_parser_1.ErrorType.NoServerInformation);
            }
            else {
                const serverValidateResult = m365_spec_parser_1.Utils.checkServerUrl([{ url: operation.server }], true);
                operation.reason.push(...serverValidateResult.map((item) => item.type));
            }
            if (operation.reason.length > 0) {
                operation.isValid = false;
            }
        }
        return {
            specVersion: treeInfo.specVersion,
            allAPICount: operations.length,
            validAPICount: operations.filter((api) => api.isValid).length,
            APIs: operations,
        };
    }
    const options = Object.assign(Object.assign({}, daProjectConfig), { allowAPIKeyAuth,
        allowBearerTokenAuth,
        allowOauth2 });
    const parser = new m365_spec_parser_1.SpecParser(specPath, options);
    return await parser.list();
}
exports.listAPIInfo = listAPIInfo;
async function validateOpenAPISpec(specPath, platform) {
    var _a;
    if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaNPMIntegration)) {
        let apiInfo;
        try {
            apiInfo = await listAPIInfo(specPath, platform);
        }
        catch (e) {
            return {
                status: m365_spec_parser_1.ValidationStatus.Error,
                warnings: [],
                errors: [
                    {
                        type: m365_spec_parser_1.ErrorType.SpecNotValid,
                        content: (0, localizeUtils_1.getLocalizedString)("error.daSpecParser.InvalidSpecError", e.toString()),
                    },
                ],
                specHash: "",
            };
        }
        if (apiInfo.allAPICount === 0 || apiInfo.validAPICount === 0) {
            const data = [];
            for (const info of apiInfo.APIs) {
                const apiInvalidReason = { api: info.api, reason: info.reason };
                data.push(apiInvalidReason);
            }
            return {
                status: m365_spec_parser_1.ValidationStatus.Error,
                warnings: [],
                errors: [{ type: m365_spec_parser_1.ErrorType.NoSupportedApi, content: "", data: data }],
                specHash: "",
            };
        }
        const result = {
            status: m365_spec_parser_1.ValidationStatus.Valid,
            warnings: [],
            errors: [],
            specHash: "",
        };
        if (apiInfo.specVersion === kiota_1.OpenApiSpecVersion.V2_0) {
            result.warnings.push({
                type: m365_spec_parser_1.WarningType.ConvertSwaggerToOpenAPI,
                content: m365_spec_parser_1.ConstantString.ConvertSwaggerToOpenAPI,
            });
        }
        // TODO: curently kiota will generate spec with version 3.0.4, if it changed in the future, we need to update this
        if (apiInfo.specVersion === kiota_1.OpenApiSpecVersion.V3_1) {
            result.warnings.push({
                type: m365_spec_parser_1.WarningType.OpenAPI31ConvertTo30,
                content: m365_spec_parser_1.ConstantString.OpenAPI31ConvertTo30,
            });
        }
        const serverUrl = (_a = apiInfo.APIs.find((api) => api.isValid)) === null || _a === void 0 ? void 0 : _a.server;
        if (serverUrl) {
            const serverString = JSON.stringify(serverUrl);
            result.specHash = (0, crypto_1.createHash)("sha256").update(serverString).digest("hex");
        }
        return result;
    }
    const options = Object.assign(Object.assign({}, daProjectConfig), { allowAPIKeyAuth: platform !== teamsfx_api_1.Platform.VS, allowBearerTokenAuth: platform !== teamsfx_api_1.Platform.VS, allowOauth2: platform !== teamsfx_api_1.Platform.VS });
    const parser = new m365_spec_parser_1.SpecParser(specPath, options);
    return await parser.validate();
}
exports.validateOpenAPISpec = validateOpenAPISpec;
function removeEnvsAndSpecialCharaters(str) {
    const placeHolderReg = /\${{\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*}}/g;
    const matches = placeHolderReg.exec(str);
    let newStr = str;
    if (matches != null) {
        newStr = newStr.replace(matches[0], "");
    }
    return newStr.toLowerCase().replace(/[^a-z0-9]/g, "");
}
function extractOperations(treeInfo) {
    var _a, _b, _c;
    let operations = [];
    if (treeInfo && treeInfo.rootNode) {
        operations = traverseTreeNodeForOperations(treeInfo.rootNode, (_a = treeInfo.servers) !== null && _a !== void 0 ? _a : [], (_b = treeInfo.security) !== null && _b !== void 0 ? _b : [], (_c = treeInfo.securitySchemes) !== null && _c !== void 0 ? _c : {});
    }
    return operations;
}
function traverseTreeNodeForOperations(node, parentServer, parentSecurity, securitySchemes) {
    var _a, _b;
    const operations = [];
    const server = node.servers && node.servers.length > 0 ? node.servers : parentServer;
    const security = Object.keys(node.security || {}).length > 0 ? node.security : parentSecurity;
    if (node.isOperation) {
        const normalizedPath = node.path.replace(/\\/g, "/");
        const lastHashIndex = normalizedPath.lastIndexOf("#");
        const resourcePath = normalizedPath.substring(0, lastHashIndex);
        let auth;
        if (security && Object.keys(securitySchemes).length > 0) {
            const firstRequirementObject = security[0];
            if (firstRequirementObject) {
                const securitySchemeNames = Object.keys(firstRequirementObject);
                if (securitySchemeNames.length > 0) {
                    const schemeName = securitySchemeNames[0];
                    if (securitySchemeNames.length > 1) {
                        auth = {
                            name: securitySchemeNames.join(", "),
                            authScheme: {
                                type: "multipleAuth",
                            },
                        };
                    }
                    else {
                        auth = {
                            name: schemeName,
                            authScheme: securitySchemes[schemeName],
                        };
                    }
                }
            }
        }
        const apiInfo = {
            api: `${node.segment} ${resourcePath}`,
            server: server[0],
            operationId: node.operationId,
            isValid: true,
            reason: [],
            auth: auth,
            summary: (_a = node.summary) !== null && _a !== void 0 ? _a : "",
            description: (_b = node.description) !== null && _b !== void 0 ? _b : "",
        };
        if (node.selected) {
            operations.push(apiInfo);
        }
    }
    if (node.children && node.children.length > 0) {
        for (const child of node.children) {
            const childOps = traverseTreeNodeForOperations(child, server, security !== null && security !== void 0 ? security : [], securitySchemes);
            operations.push(...childOps);
        }
    }
    return operations;
}
function isAuthTypeSupported(authScheme, allowAPIKeyAuth, allowBearerTokenAuth, allowOauth2) {
    return ((allowAPIKeyAuth && m365_spec_parser_1.Utils.isAPIKeyAuthButNotInCookie(authScheme)) ||
        (allowOauth2 && m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(authScheme)) ||
        (allowBearerTokenAuth && m365_spec_parser_1.Utils.isBearerTokenAuth(authScheme)));
}
//# sourceMappingURL=daSpecParser.js.map