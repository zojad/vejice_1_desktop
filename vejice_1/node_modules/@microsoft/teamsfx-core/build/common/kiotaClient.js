"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.kiotageneratePlugin = exports.listAPITreeInfo = exports.searchOpenAPISpec = void 0;
const tslib_1 = require("tslib");
const kiota_1 = require("@microsoft/kiota");
const error_1 = require("../error");
const localizeUtils_1 = require("./localizeUtils");
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const path_1 = tslib_1.__importDefault(require("path"));
const os = tslib_1.__importStar(require("os"));
const ERROR_LOG_LEVEL = 4;
function setKiotaBinaryPath() {
    if (process.env.KIOTA_BINARY_PATH) {
        (0, kiota_1.setKiotaConfig)({ binaryLocation: process.env.KIOTA_BINARY_PATH });
    }
    else {
        // If running inside pkg package used by VS, set the binary location to a specific directory to avoid issues.
        const isInsidePkg = typeof process.pkg !== "undefined";
        if (isInsidePkg) {
            const kiotaBinDir = path_1.default.join(os.homedir(), "kiota-bin");
            (0, kiota_1.setKiotaConfig)({ binaryLocation: kiotaBinDir });
        }
    }
}
async function searchOpenAPISpec(query) {
    setKiotaBinaryPath();
    const searchResult = await (0, kiota_1.searchDescription)({
        searchTerm: query,
        clearCache: false,
    });
    const result = [];
    if (searchResult) {
        for (const key in searchResult) {
            const api = searchResult[key];
            if (api && api.DescriptionUrl) {
                result.push({
                    key: key,
                    url: api.DescriptionUrl,
                    description: api.Description,
                });
            }
        }
    }
    return result;
}
exports.searchOpenAPISpec = searchOpenAPISpec;
async function listAPITreeInfo(specPath, includeFilters, excludeFilters) {
    setKiotaBinaryPath();
    const treeInfo = await (0, kiota_1.getKiotaTree)({
        includeFilters: includeFilters,
        descriptionPath: specPath,
        excludeFilters: excludeFilters,
        clearCache: true,
        includeKiotaValidationRules: true,
    });
    if (!treeInfo) {
        throw new Error((0, localizeUtils_1.getLocalizedString)("error.kiotaClient.EmptyResult"));
    }
    const errors = treeInfo.logs
        .filter((log) => log.level >= ERROR_LOG_LEVEL)
        .map((log) => log.message);
    if (errors.length > 0) {
        throw new Error(errors.join("\n"));
    }
    const treeInfoStr = JSON.stringify(treeInfo);
    const resolvedTreeInfo = m365_spec_parser_1.Utils.resolveEnv(treeInfoStr);
    return JSON.parse(resolvedTreeInfo);
}
exports.listAPITreeInfo = listAPITreeInfo;
async function kiotageneratePlugin(specPath, outputPath, pluginName, workingDirectory, authType, authRefId, includePatterns, excludePatterns, noWorkspace) {
    setKiotaBinaryPath();
    const config = {
        descriptionPath: specPath,
        outputPath: outputPath,
        includePatterns: includePatterns !== null && includePatterns !== void 0 ? includePatterns : [],
        excludePatterns: excludePatterns !== null && excludePatterns !== void 0 ? excludePatterns : [],
        pluginName: pluginName,
        clearCache: false,
        cleanOutput: false,
        disabledValidationRules: [],
        operation: kiota_1.ConsumerOperation.Edit,
        pluginAuthType: authType !== null && authType !== void 0 ? authType : null,
        pluginAuthRefid: authRefId !== null && authRefId !== void 0 ? authRefId : undefined,
        workingDirectory: workingDirectory,
        noWorkspace: noWorkspace,
    };
    try {
        const result = await (0, kiota_1.generatePlugin)(config);
        if (!result) {
            throw new Error("Get empty result from kiota");
        }
        if (!result.isSuccess) {
            const errorMessage = result.logs
                .filter((log) => log.level >= ERROR_LOG_LEVEL)
                .map((log) => log.message)
                .join(";");
            throw new Error(errorMessage);
        }
        return result;
    }
    catch (error) {
        throw new error_1.KiotaGeneratePluginError(error.message);
    }
}
exports.kiotageneratePlugin = kiotageneratePlugin;
//# sourceMappingURL=kiotaClient.js.map