"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runForTypeSpecProject = exports.getTypeSpecArgs = exports.isTestToolEnabledProject = exports.listDevTunnels = exports.getSPFxToken = exports.getSPFxTenant = exports.listAllTenants = exports.isSandboxedEnabled = exports.getSideloadingStatus = void 0;
const tslib_1 = require("tslib");
const dev_tunnels_management_1 = require("@microsoft/dev-tunnels-management");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const teamsDevPortalClient_1 = require("../client/teamsDevPortalClient");
const graphClient_1 = require("../client/graphClient");
const constants_1 = require("./constants");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const versionMetadata_1 = require("./versionMetadata");
const pathUtils_1 = require("../component/utils/pathUtils");
const yaml_1 = require("yaml");
const projectTypeChecker_1 = require("./projectTypeChecker");
const typedi_1 = tslib_1.__importDefault(require("typedi"));
async function getSideloadingStatus(token) {
    return teamsDevPortalClient_1.teamsDevPortalClient.getSideloadingStatus(token);
}
exports.getSideloadingStatus = getSideloadingStatus;
async function isSandboxedEnabled(tokenProvider) {
    const graphClient = new graphClient_1.GraphClient(tokenProvider);
    const teamsAppSettings = await graphClient.GetTeamsAppSettingsAsync();
    return (teamsAppSettings.sandboxingConfiguration &&
        teamsAppSettings.sandboxingConfiguration.sensitivityLabelUsedToIdentifySandboxedContainers !==
            "");
}
exports.isSandboxedEnabled = isSandboxedEnabled;
async function listAllTenants(token) {
    const RM_ENDPOINT = "https://management.azure.com/tenants?api-version=2022-06-01";
    if (token.length > 0) {
        try {
            const response = await axios_1.default.get(RM_ENDPOINT, {
                headers: { Authorization: `Bearer ${token}` },
            });
            return response.data.value;
        }
        catch (error) {
            return [];
        }
    }
    return [];
}
exports.listAllTenants = listAllTenants;
async function getSPFxTenant(graphToken) {
    const GRAPH_TENANT_ENDPT = "https://graph.microsoft.com/v1.0/sites/root?$select=webUrl";
    if (graphToken.length > 0) {
        const response = await axios_1.default.get(GRAPH_TENANT_ENDPT, {
            headers: { Authorization: `Bearer ${graphToken}` },
        });
        return response.data.webUrl;
    }
    return "";
}
exports.getSPFxTenant = getSPFxTenant;
async function getSPFxToken(m365TokenProvider) {
    const graphTokenRes = await m365TokenProvider.getAccessToken({
        scopes: constants_1.GraphReadUserScopes,
    });
    let spoToken = undefined;
    if (graphTokenRes && graphTokenRes.isOk()) {
        const tenant = await getSPFxTenant(graphTokenRes.value);
        const spfxTokenRes = await m365TokenProvider.getAccessToken({
            scopes: (0, constants_1.SPFxScopes)(tenant),
        });
        spoToken = spfxTokenRes.isOk() ? spfxTokenRes.value : undefined;
    }
    return spoToken;
}
exports.getSPFxToken = getSPFxToken;
// this function will be deleted after VS has added get dev tunnel and list dev tunnels API
const TunnelManagementUserAgent = { name: "Teams-Toolkit" };
async function listDevTunnels(token, isGitHub = false) {
    try {
        const tunnelManagementClientImpl = new dev_tunnels_management_1.TunnelManagementHttpClient(TunnelManagementUserAgent, dev_tunnels_management_1.ManagementApiVersions.Version20230927preview, () => {
            if (isGitHub === true) {
                const res = `github client_id=a200baed193bb2088a6e ${token}`;
                return Promise.resolve(res);
            }
            else {
                const res = `Bearer ${token}`;
                return Promise.resolve(res);
            }
        });
        const options = {
            includeAccessControl: true,
        };
        const tunnels = await tunnelManagementClientImpl.listTunnels(undefined, undefined, options);
        return (0, teamsfx_api_1.ok)(tunnels);
    }
    catch (error) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.SystemError("DevTunnels", "ListDevTunnelsFailed", error.message));
    }
}
exports.listDevTunnels = listDevTunnels;
function isTestToolEnabledProject(projectPath) {
    const testToolYmlPathV4 = path_1.default.join(projectPath, versionMetadata_1.MetadataV4.testToolConfigFile);
    if (fs_extra_1.default.pathExistsSync(testToolYmlPathV4)) {
        return true;
    }
    const testToolYmlPath = path_1.default.join(projectPath, versionMetadata_1.MetadataV3.testToolConfigFile);
    if (fs_extra_1.default.pathExistsSync(testToolYmlPath)) {
        return true;
    }
    return false;
}
exports.isTestToolEnabledProject = isTestToolEnabledProject;
function getTypeSpecArgs(projectPath) {
    var _a, _b, _c, _d;
    const defaultArgs = {
        path: "./main.tsp",
        manifestPath: "./appPackage/manifest.json",
        outputDir: "./appPackage/.generated",
        typeSpecConfigPath: "./tspconfig.yaml",
    };
    const yamlFilePath = pathUtils_1.pathUtils.getYmlFilePath(projectPath);
    if (!yamlFilePath) {
        return defaultArgs;
    }
    const yamlContent = fs_extra_1.default.readFileSync(yamlFilePath, "utf8");
    const document = (0, yaml_1.parseDocument)(yamlContent);
    const provisionNode = document.get("provision");
    if (!provisionNode) {
        return defaultArgs;
    }
    const tspCompileAction = provisionNode.items.find((item) => item.get("uses") === "typeSpec/compile");
    if (!tspCompileAction) {
        return defaultArgs;
    }
    const args = tspCompileAction.get("with");
    return {
        path: (_a = args.get("path")) !== null && _a !== void 0 ? _a : defaultArgs.path,
        manifestPath: (_b = args.get("manifestPath")) !== null && _b !== void 0 ? _b : defaultArgs.manifestPath,
        outputDir: (_c = args.get("outputDir")) !== null && _c !== void 0 ? _c : defaultArgs.outputDir,
        typeSpecConfigPath: (_d = args.get("typeSpecConfigPath")) !== null && _d !== void 0 ? _d : defaultArgs.typeSpecConfigPath,
    };
}
exports.getTypeSpecArgs = getTypeSpecArgs;
async function runForTypeSpecProject(projectPath, context) {
    const isTspProject = (0, projectTypeChecker_1.isTypeSpecProject)(projectPath);
    if (isTspProject) {
        // Call npm/install
        const npmInstallDriver = typedi_1.default.get("cli/runNpmCommand");
        const npmInstallArgs = {
            args: "install --no-audit --progress=false",
        };
        const npmInstallResult = (await npmInstallDriver.execute(npmInstallArgs, context)).result;
        if (npmInstallResult.isErr()) {
            throw (0, teamsfx_api_1.err)(npmInstallResult.error);
        }
        // call typespec/compile
        const typeSpecCompileDriver = typedi_1.default.get("typeSpec/compile");
        const typeSpecCompileArgs = getTypeSpecArgs(projectPath);
        const typeSpecCompileResult = (await typeSpecCompileDriver.execute(typeSpecCompileArgs, context)).result;
        if (typeSpecCompileResult.isErr()) {
            throw (0, teamsfx_api_1.err)(typeSpecCompileResult.error);
        }
    }
}
exports.runForTypeSpecProject = runForTypeSpecProject;
//# sourceMappingURL=tools.js.map