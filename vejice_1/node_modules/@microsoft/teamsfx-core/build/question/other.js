"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectSensitivityLabelQuestion = exports.selectDeclarativeAgentManifestQuestion = exports.setSensitivityLabelNode = exports.syncManifestQuestionNode = exports.uninstallQuestionNode = exports.oauthQuestion = exports.apiSpecApiKeyQuestion = exports.apiSpecApiKeyConfirmQestion = exports.authNameQuestion = exports.apiFromPluginManifestQuestion = exports.apiSpecFromPluginManifestQuestion = exports.microsoftEntraParameterQuestion = exports.apiKeyNameQuestion = exports.apiKeyInQuestion = exports.apiKeyParameterQuestion = exports.oauthPKCEQuestion = exports.oauthScopeQuestion = exports.oauthRefreshUrlQuestion = exports.oauthTokenUrlQuestion = exports.oauthAuthorizationUrlQuestion = exports.oauthParametersQuestion = exports.addAuthActionAuthTypeQuestion = exports.urlValidation = exports.addAuthActionQuestion = exports.kiotaRegenerateQuestion = exports.addEmbeddedKnowledgeFilesQuestion = exports.addKnowledgeQuestionNode = exports.metaOSExtendToDAQuestionNode = exports.addPluginQuestionNode = exports.regeneratePluginNode = exports.createNewEnvQuestionNode = exports.selectSourceEnvQuestion = exports.newTargetEnvQuestion = exports.newEnvNameValidation = exports.selectAadManifestQuestion = exports.isAadMainifestContainsPlaceholder = exports.inputUserEmailQuestion = exports.selectTargetEnvQuestion = exports.previewWithTeamsAppManifestQuestionNode = exports.selectTeamsAppPackageQuestionNode = exports.copilotPluginAddAPIQuestionNode = exports.confirmManifestQuestion = exports.selectLocalTeamsAppManifestQuestion = exports.selectTeamsAppManifestQuestion = exports.addWebPartQuestionNode = exports.selectTeamsAppManifestQuestionNode = exports.validateTeamsAppQuestionNode = exports.deployAadManifestQuestionNode = exports.convertAadToNewSchemaQuestionNode = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const graphClient_1 = require("../client/graphClient");
const constants_1 = require("../common/constants");
const featureFlags_1 = require("../common/featureFlags");
const globalVars_1 = require("../common/globalVars");
const localizeUtils_1 = require("../common/localizeUtils");
const constants_2 = require("../component/driver/add/utility/constants");
const ManifestUtils_1 = require("../component/driver/teamsApp/utils/ManifestUtils");
const envUtil_1 = require("../component/utils/envUtil");
const environmentName_1 = require("../core/environmentName");
const constants_3 = require("./constants");
const create_1 = require("./create");
const teamsProjectTypeNode_1 = require("./scaffold/vsc/teamsProjectTypeNode");
function convertAadToNewSchemaQuestionNode() {
    return {
        data: { type: "group" },
        children: [
            {
                condition: (inputs) => teamsfx_api_1.DynamicPlatforms.includes(inputs.platform) &&
                    !inputs[constants_3.QuestionNames.AadAppManifestFilePath],
                data: selectAadManifestQuestion(),
                children: [
                    {
                        condition: (inputs) => inputs.platform === teamsfx_api_1.Platform.VSCode && // confirm question only works for VSC
                            inputs.projectPath !== undefined &&
                            path.resolve(inputs[constants_3.QuestionNames.AadAppManifestFilePath]) !==
                                path.join(inputs.projectPath, "aad.manifest.json"),
                        data: confirmManifestQuestion(false, false),
                        cliOptionDisabled: "self",
                        inputsDisabled: "self",
                    },
                ],
            },
        ],
    };
}
exports.convertAadToNewSchemaQuestionNode = convertAadToNewSchemaQuestionNode;
function deployAadManifestQuestionNode() {
    return {
        data: { type: "group" },
        children: [
            {
                condition: (inputs) => teamsfx_api_1.DynamicPlatforms.includes(inputs.platform),
                data: selectAadManifestQuestion(),
                children: [
                    {
                        condition: (inputs) => inputs.platform === teamsfx_api_1.Platform.VSCode && // confirm question only works for VSC
                            inputs.projectPath !== undefined &&
                            path.resolve(inputs[constants_3.QuestionNames.AadAppManifestFilePath]) !==
                                path.join(inputs.projectPath, "aad.manifest.json"),
                        data: confirmManifestQuestion(false, false),
                        cliOptionDisabled: "self",
                        inputsDisabled: "self",
                    },
                    {
                        condition: isAadMainifestContainsPlaceholder,
                        data: selectTargetEnvQuestion(constants_3.QuestionNames.Env, false, false, ""),
                    },
                ],
            },
        ],
    };
}
exports.deployAadManifestQuestionNode = deployAadManifestQuestionNode;
function validateTeamsAppQuestionNode() {
    return {
        data: selectTeamsAppValidationMethodQuestion(),
        cliOptionDisabled: "self",
        inputsDisabled: "self",
        children: [
            {
                condition: { equals: constants_3.TeamsAppValidationOptions.schema().id },
                data: selectTeamsAppManifestQuestion(),
            },
            {
                condition: { equals: constants_3.TeamsAppValidationOptions.package().id },
                data: selectTeamsAppPackageQuestion(),
            },
            {
                condition: { equals: constants_3.TeamsAppValidationOptions.testCases().id },
                data: selectTeamsAppPackageQuestion(),
            },
        ],
    };
}
exports.validateTeamsAppQuestionNode = validateTeamsAppQuestionNode;
function selectTeamsAppManifestQuestionNode() {
    return {
        data: selectTeamsAppManifestQuestion(),
        children: [
            {
                condition: (inputs) => confirmCondition(inputs, false),
                data: confirmManifestQuestion(true, false),
                cliOptionDisabled: "self",
                inputsDisabled: "self",
            },
        ],
    };
}
exports.selectTeamsAppManifestQuestionNode = selectTeamsAppManifestQuestionNode;
function confirmCondition(inputs, isLocal) {
    return (inputs.platform === teamsfx_api_1.Platform.VSCode && // confirm question only works for VSC
        inputs.projectPath &&
        inputs[isLocal ? constants_3.QuestionNames.LocalTeamsAppManifestFilePath : constants_3.QuestionNames.TeamsAppManifestFilePath] &&
        path.resolve(inputs[isLocal
            ? constants_3.QuestionNames.LocalTeamsAppManifestFilePath
            : constants_3.QuestionNames.TeamsAppManifestFilePath]) !==
            path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, isLocal ? "manifest.local.json" : "manifest.json"));
}
async function spfxFrameworkExist(inputs) {
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
        return false;
    }
    const yorcPath = path.join(inputs[constants_3.QuestionNames.SPFxFolder], constants_2.Constants.YO_RC_FILE);
    if (!(await fs_extra_1.default.pathExists(yorcPath))) {
        return false;
    }
    const yorcJson = (await fs_extra_1.default.readJson(yorcPath));
    if (!yorcJson["@microsoft/generator-sharepoint"]) {
        return false;
    }
    return yorcJson["@microsoft/generator-sharepoint"]["template"];
}
function addWebPartQuestionNode() {
    return {
        data: (0, create_1.SPFxImportFolderQuestion)(true),
        children: [
            {
                data: (0, create_1.SPFxWebpartNameQuestion)(),
                children: [
                    {
                        data: (0, create_1.SPFxFrameworkQuestion)(),
                        condition: async (inputs) => {
                            return !(await spfxFrameworkExist(inputs));
                        },
                    },
                    {
                        data: selectTeamsAppManifestQuestion(),
                        children: [
                            {
                                condition: (inputs) => confirmCondition(inputs, false),
                                data: confirmManifestQuestion(true, false),
                                cliOptionDisabled: "self",
                                inputsDisabled: "self",
                            },
                            {
                                data: selectLocalTeamsAppManifestQuestion(),
                                children: [
                                    {
                                        condition: (inputs) => confirmCondition(inputs, true),
                                        data: confirmManifestQuestion(true, true),
                                        cliOptionDisabled: "self",
                                        inputsDisabled: "self",
                                    },
                                ],
                            },
                        ],
                    },
                ],
            },
        ],
    };
}
exports.addWebPartQuestionNode = addWebPartQuestionNode;
function selectTeamsAppManifestQuestion() {
    return {
        name: constants_3.QuestionNames.TeamsAppManifestFilePath,
        cliName: "manifest-file",
        cliShortName: "t",
        cliDescription: "Specifies the app manifest file path.",
        title: (0, localizeUtils_1.getLocalizedString)("core.selectTeamsAppManifestQuestion.title"),
        type: "singleFile",
        default: (inputs) => {
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./appPackage/manifest.json";
            }
            else {
                if (!inputs.projectPath)
                    return undefined;
                const manifestPath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, "manifest.json");
                if (fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return manifestPath;
                }
                else {
                    return undefined;
                }
            }
        },
    };
}
exports.selectTeamsAppManifestQuestion = selectTeamsAppManifestQuestion;
function selectLocalTeamsAppManifestQuestion() {
    return {
        name: constants_3.QuestionNames.LocalTeamsAppManifestFilePath,
        cliName: "local-manifest-file",
        cliShortName: "l",
        cliDescription: "Specifies the app manifest template file path for local environment, it can be either absolute path or relative path to project root folder.",
        title: (0, localizeUtils_1.getLocalizedString)("core.selectLocalTeamsAppManifestQuestion.title"),
        type: "singleFile",
        default: (inputs) => {
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./appPackage/manifest.local.json";
            }
            else {
                if (!inputs.projectPath)
                    return undefined;
                const manifestPath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, "manifest.local.json");
                if (fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return manifestPath;
                }
                else {
                    return undefined;
                }
            }
        },
    };
}
exports.selectLocalTeamsAppManifestQuestion = selectLocalTeamsAppManifestQuestion;
function confirmManifestQuestion(isTeamsApp = true, isLocal = false) {
    const map = {
        true_true: constants_3.QuestionNames.ConfirmLocalManifest,
        true_false: constants_3.QuestionNames.ConfirmManifest,
        false_true: constants_3.QuestionNames.ConfirmAadManifest,
        false_false: constants_3.QuestionNames.ConfirmAadManifest,
    };
    const name = map[`${isTeamsApp.toString()}_${isLocal.toString()}`];
    return {
        name: name,
        title: isTeamsApp
            ? (0, localizeUtils_1.getLocalizedString)(isLocal
                ? "core.selectLocalTeamsAppManifestQuestion.title"
                : "core.selectTeamsAppManifestQuestion.title")
            : (0, localizeUtils_1.getLocalizedString)("core.selectAadAppManifestQuestion.title"),
        type: "singleSelect",
        staticOptions: [],
        skipSingleOption: false,
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.confirmManifestQuestion.placeholder"),
        dynamicOptions: (inputs) => {
            return [
                {
                    id: "manifest",
                    label: `$(file) ${path.basename(isTeamsApp
                        ? inputs[isLocal
                            ? constants_3.QuestionNames.LocalTeamsAppManifestFilePath
                            : constants_3.QuestionNames.TeamsAppManifestFilePath]
                        : inputs[constants_3.QuestionNames.AadAppManifestFilePath])}`,
                    description: path.dirname(isTeamsApp
                        ? inputs[isLocal
                            ? constants_3.QuestionNames.LocalTeamsAppManifestFilePath
                            : constants_3.QuestionNames.TeamsAppManifestFilePath]
                        : inputs[constants_3.QuestionNames.AadAppManifestFilePath]),
                },
            ];
        },
    };
}
exports.confirmManifestQuestion = confirmManifestQuestion;
function selectTeamsAppValidationMethodQuestion() {
    const options = [constants_3.TeamsAppValidationOptions.schema(), constants_3.TeamsAppValidationOptions.package()];
    if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.AsyncAppValidation)) {
        options.push(constants_3.TeamsAppValidationOptions.testCases());
    }
    return {
        name: constants_3.QuestionNames.ValidateMethod,
        title: (0, localizeUtils_1.getLocalizedString)("core.selectValidateMethodQuestion.validate.selectTitle"),
        staticOptions: options,
        type: "singleSelect",
    };
}
function copilotPluginAddAPIQuestionNode() {
    return {
        data: (0, create_1.apiSpecLocationQuestion)(false),
        children: [
            {
                data: (0, create_1.apiOperationQuestion)(false),
            },
        ],
    };
}
exports.copilotPluginAddAPIQuestionNode = copilotPluginAddAPIQuestionNode;
function selectTeamsAppPackageQuestion() {
    return {
        name: constants_3.QuestionNames.TeamsAppPackageFilePath,
        title: (0, localizeUtils_1.getLocalizedString)("core.selectTeamsAppPackageQuestion.title"),
        cliDescription: "Specifies the zipped app package path, it's a relative path to project root folder, defaults to '${folder}/appPackage/build/appPackage.${env}.zip'",
        cliName: "app-package-file",
        cliShortName: "p",
        type: "singleFile",
        default: (inputs) => {
            if (!inputs.projectPath)
                return undefined;
            const appPackagePath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.BuildFolderName, "appPackage.dev.zip");
            if (fs_extra_1.default.pathExistsSync(appPackagePath)) {
                return appPackagePath;
            }
            else {
                return undefined;
            }
        },
    };
}
function selectTeamsAppPackageQuestionNode() {
    return {
        data: selectTeamsAppPackageQuestion(),
    };
}
exports.selectTeamsAppPackageQuestionNode = selectTeamsAppPackageQuestionNode;
function selectM365HostQuestion() {
    return {
        name: constants_3.QuestionNames.M365Host,
        cliShortName: "m",
        cliDescription: "Preview the application in Teams, Outlook or the Microsoft 365 app.",
        title: (0, localizeUtils_1.getLocalizedString)("core.M365HostQuestion.title"),
        default: constants_3.HubOptions.teams().id,
        type: "singleSelect",
        staticOptions: constants_3.HubOptions.all(),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.M365HostQuestion.placeholder"),
    };
}
function previewWithTeamsAppManifestQuestionNode() {
    return {
        data: { type: "group" },
        children: [
            {
                data: selectM365HostQuestion(),
            },
            selectTeamsAppManifestQuestionNode(),
        ],
    };
}
exports.previewWithTeamsAppManifestQuestionNode = previewWithTeamsAppManifestQuestionNode;
function selectTargetEnvQuestion(questionName = constants_3.QuestionNames.TargetEnvName, remoteOnly = true, throwErrorIfNoEnv = false, defaultValueIfNoEnv = environmentName_1.environmentNameManager.getDefaultEnvName()) {
    return {
        type: "singleSelect",
        name: questionName,
        title: (0, localizeUtils_1.getLocalizedString)("core.QuestionSelectTargetEnvironment.title"),
        cliName: "env",
        cliDescription: "Specifies the environment name for the project.",
        staticOptions: [],
        dynamicOptions: async (inputs) => {
            if (!inputs.projectPath)
                return [];
            const res = await envUtil_1.envUtil.listEnv(inputs.projectPath, remoteOnly);
            if (res.isErr()) {
                if (throwErrorIfNoEnv)
                    throw res.error;
                return [defaultValueIfNoEnv];
            }
            // "testtool" env is a pure local env and doesn't have manifest
            return res.value.filter((env) => env !== environmentName_1.environmentNameManager.getTestToolEnvName() &&
                env !== environmentName_1.environmentNameManager.getPlaygroundEnvName());
        },
        skipSingleOption: true,
        forgetLastValue: true,
    };
}
exports.selectTargetEnvQuestion = selectTargetEnvQuestion;
async function getDefaultUserEmail() {
    if (!(globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.tokenProvider.m365TokenProvider))
        return undefined;
    const jsonObjectRes = await globalVars_1.TOOLS.tokenProvider.m365TokenProvider.getJsonObject({
        scopes: constants_1.AppStudioScopes,
    });
    if (jsonObjectRes.isErr()) {
        throw jsonObjectRes.error;
    }
    const jsonObject = jsonObjectRes.value;
    const currentUserEmail = jsonObject.upn;
    let defaultUserEmail = "";
    if (currentUserEmail && currentUserEmail.indexOf("@") > 0) {
        defaultUserEmail = "[UserName]@" + currentUserEmail.split("@")[1];
    }
    return defaultUserEmail;
}
function inputUserEmailQuestion(title, cliDescription, useDefaultUser) {
    return {
        name: constants_3.QuestionNames.UserEmail,
        type: "text",
        title: title,
        cliDescription: cliDescription,
        default: useDefaultUser ? getDefaultUserEmail : undefined,
        validation: {
            validFunc: async (input, previousInputs) => {
                if (!input || input.trim() === "") {
                    return (0, localizeUtils_1.getLocalizedString)("core.getUserEmailQuestion.validation1");
                }
                input = input.trim();
                if (useDefaultUser) {
                    const defaultUserEmail = await getDefaultUserEmail();
                    if (input === defaultUserEmail) {
                        return (0, localizeUtils_1.getLocalizedString)("core.getUserEmailQuestion.validation2");
                    }
                }
                const re = /\S+@\S+\.\S+/;
                if (!re.test(input)) {
                    return (0, localizeUtils_1.getLocalizedString)("core.getUserEmailQuestion.validation3");
                }
                return undefined;
            },
        },
    };
}
exports.inputUserEmailQuestion = inputUserEmailQuestion;
async function isAadMainifestContainsPlaceholder(inputs) {
    const aadManifestPath = inputs === null || inputs === void 0 ? void 0 : inputs[constants_3.QuestionNames.AadAppManifestFilePath];
    const placeholderRegex = /\$\{\{ *[a-zA-Z0-9_.-]* *\}\}/g;
    const regexObj = new RegExp(placeholderRegex);
    try {
        if (!aadManifestPath || !(await fs_extra_1.default.pathExists(aadManifestPath))) {
            return false;
        }
        const manifest = await fs_extra_1.default.readFile(aadManifestPath, constants_1.ConstantString.UTF8Encoding);
        if (regexObj.test(manifest)) {
            return true;
        }
    }
    catch (e) {
        return false;
    }
    return false;
}
exports.isAadMainifestContainsPlaceholder = isAadMainifestContainsPlaceholder;
function selectAadManifestQuestion() {
    return {
        name: constants_3.QuestionNames.AadAppManifestFilePath,
        cliName: "entra-app-manifest-file",
        cliShortName: "a",
        cliDescription: "Specifies the Microsoft Entra app manifest file path, can be either absolute path or relative path to project root folder.",
        title: (0, localizeUtils_1.getLocalizedString)("core.selectAadAppManifestQuestion.title"),
        type: "singleFile",
        default: (inputs) => {
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./aad.manifest.json";
            }
            else {
                if (!inputs.projectPath)
                    return undefined;
                const manifestPath = path.join(inputs.projectPath, "aad.manifest.json");
                if (fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return manifestPath;
                }
                else {
                    return undefined;
                }
            }
        },
    };
}
exports.selectAadManifestQuestion = selectAadManifestQuestion;
async function newEnvNameValidation(input, inputs) {
    const targetEnvName = input;
    const match = targetEnvName.match(environmentName_1.environmentNameManager.envNameRegex);
    if (!match) {
        return (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.validation1");
    }
    if (!environmentName_1.environmentNameManager.isRemoteEnvironment(targetEnvName)) {
        return (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.validation3", targetEnvName);
    }
    if (!(inputs === null || inputs === void 0 ? void 0 : inputs.projectPath))
        return "Project path is not defined";
    const envListRes = await envUtil_1.envUtil.listEnv(inputs.projectPath, true);
    if (envListRes.isErr()) {
        return (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.validation4");
    }
    inputs.existingEnvNames = envListRes.value; //cache existing env names
    const found = envListRes.value.find((env) => env.localeCompare(targetEnvName, undefined, { sensitivity: "base" }) === 0) !== undefined;
    if (found) {
        return (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.validation5", targetEnvName);
    }
    else {
        return undefined;
    }
}
exports.newEnvNameValidation = newEnvNameValidation;
function newTargetEnvQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.NewTargetEnvName,
        cliName: "name",
        cliDescription: "Specifies the new environment name.",
        cliType: "argument",
        title: (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.title"),
        validation: {
            validFunc: newEnvNameValidation,
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.placeholder"),
    };
}
exports.newTargetEnvQuestion = newTargetEnvQuestion;
// export const lastUsedMark = " (last used)";
// let lastUsedEnv: string | undefined;
// export function reOrderEnvironments(environments: Array<string>): Array<string> {
//   if (!lastUsedEnv) {
//     return environments;
//   }
//   const index = environments.indexOf(lastUsedEnv);
//   if (index === -1) {
//     return environments;
//   }
//   return [lastUsedEnv + lastUsedMark]
//     .concat(environments.slice(0, index))
//     .concat(environments.slice(index + 1));
// }
function selectSourceEnvQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SourceEnvName,
        cliName: "env",
        title: (0, localizeUtils_1.getLocalizedString)("core.QuestionSelectSourceEnvironment.title"),
        cliDescription: "Specifies an existing environment name to copy from.",
        staticOptions: [],
        dynamicOptions: async (inputs) => {
            if (inputs.existingEnvNames) {
                const envList = inputs.existingEnvNames;
                return envList;
            }
            else if (inputs.projectPath) {
                const envListRes = await envUtil_1.envUtil.listEnv(inputs.projectPath, true);
                if (envListRes.isErr()) {
                    throw envListRes.error;
                }
                return envListRes.value;
            }
            return [];
        },
        skipSingleOption: true,
        forgetLastValue: true,
    };
}
exports.selectSourceEnvQuestion = selectSourceEnvQuestion;
function createNewEnvQuestionNode() {
    return {
        data: newTargetEnvQuestion(),
        children: [
            {
                data: selectSourceEnvQuestion(),
            },
        ],
    };
}
exports.createNewEnvQuestionNode = createNewEnvQuestionNode;
function regeneratePluginNode() {
    return {
        data: (0, create_1.selectExistingPluginManifestQuestion)(),
        children: [
            {
                data: (0, create_1.selectOpenAPISpecFromPluginQuestion)(),
            },
            {
                data: (0, create_1.selectApiOperationForRegenerateQuestion)(),
            },
        ],
    };
}
exports.regeneratePluginNode = regeneratePluginNode;
// add Plugin to a declarative Copilot project
function addPluginQuestionNode() {
    return {
        data: (0, create_1.apiPluginStartQuestion)(true),
        children: [
            ...[(0, teamsProjectTypeNode_1.inputOrSearchAPISpecNode)()],
            {
                data: (0, create_1.apiSpecLocationQuestion)(),
                condition: (inputs) => {
                    return (!featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaNPMIntegration) &&
                        !featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
                        inputs[constants_3.QuestionNames.ActionType] === constants_3.ActionStartOptions.apiSpec().id);
                },
            },
            {
                data: (0, create_1.apiOperationQuestion)(true, true),
                condition: (inputs) => {
                    return (!featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaNPMIntegration) &&
                        !featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
                        inputs[constants_3.QuestionNames.ActionType] === constants_3.ActionStartOptions.apiSpec().id);
                },
            },
            {
                data: selectTeamsAppManifestQuestion(),
            },
        ],
    };
}
exports.addPluginQuestionNode = addPluginQuestionNode;
function metaOSExtendToDAQuestionNode() {
    return {
        data: {
            type: "group",
        },
        children: [
            {
                data: (0, create_1.folderQuestion)(),
            },
            {
                data: (0, create_1.appNameQuestion)(),
            },
        ],
    };
}
exports.metaOSExtendToDAQuestionNode = metaOSExtendToDAQuestionNode;
// add Knowledge to a declarative Copilot project
function addKnowledgeQuestionNode() {
    return {
        data: (0, create_1.addKnowledgeStartQuestion)(true),
        children: [
            // Web Content
            {
                data: (0, create_1.searchTypeQuestion)(),
                condition: (inputs) => {
                    return inputs[constants_3.QuestionNames.KnowledgeSource] === constants_3.KnowledgeSourceOptions.webSearch().id;
                },
                children: [
                    {
                        data: (0, create_1.webContentQuestion)(),
                        condition: (inputs) => {
                            return inputs[constants_3.QuestionNames.SearchType] === constants_3.KnowledgeSearchTypeOptions.url().id;
                        },
                    },
                    {
                        data: selectTeamsAppManifestQuestion(),
                    },
                ],
            },
            // OneDrive SharePoint
            {
                data: (0, create_1.searchTypeQuestion)(),
                condition: (inputs) => {
                    return (inputs[constants_3.QuestionNames.KnowledgeSource] === constants_3.KnowledgeSourceOptions.oneDriveSharePoint().id);
                },
                children: [
                    {
                        data: (0, create_1.oneDriveSharePointItemQuestion)(),
                        condition: (inputs) => {
                            return inputs[constants_3.QuestionNames.SearchType] === constants_3.KnowledgeSearchTypeOptions.url().id;
                        },
                    },
                    {
                        data: (0, create_1.oneDriveSharePointItemConfirmQuestion)(),
                        condition: (inputs) => {
                            return inputs[constants_3.QuestionNames.SearchType] === constants_3.KnowledgeSearchTypeOptions.url().id;
                        },
                    },
                    {
                        data: selectTeamsAppManifestQuestion(),
                    },
                ],
            },
            // Copilot connector
            {
                data: (0, create_1.GCItemQuestion)(),
                condition: {
                    equals: constants_3.KnowledgeSourceOptions.graphConnector().id,
                },
                children: [
                    {
                        data: (0, create_1.GCListQuestion)(),
                        condition: {
                            equals: constants_3.GCSelectOptions.list().id,
                        },
                    },
                    {
                        data: (0, create_1.GCInputQuestion)(),
                        condition: {
                            equals: constants_3.GCSelectOptions.input().id,
                        },
                    },
                    {
                        data: selectTeamsAppManifestQuestion(),
                    },
                ],
            },
            // Embedded Knowledge
            {
                data: selectTeamsAppManifestQuestion(),
                condition: (inputs) => {
                    return (inputs[constants_3.QuestionNames.KnowledgeSource] === constants_3.KnowledgeSourceOptions.embeddedKnowledge().id);
                },
                children: [
                    {
                        data: addEmbeddedKnowledgeFilesQuestion(),
                    },
                ],
            },
        ],
    };
}
exports.addKnowledgeQuestionNode = addKnowledgeQuestionNode;
function addEmbeddedKnowledgeFilesQuestion() {
    return {
        name: constants_3.QuestionNames.EmbeddedKnowledgeFiles,
        title: (0, localizeUtils_1.getLocalizedString)("core.addEmbeddedKnowledgeFilesQuestion.title"),
        type: "multiFile",
        cliDescription: "Select your embedded knowledge files.",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.addEmbeddedKnowledgeFilesQuestion.placeholder"),
    };
}
exports.addEmbeddedKnowledgeFilesQuestion = addEmbeddedKnowledgeFilesQuestion;
function kiotaRegenerateQuestion() {
    return {
        data: selectTeamsAppManifestQuestion(),
    };
}
exports.kiotaRegenerateQuestion = kiotaRegenerateQuestion;
function addAuthActionQuestion() {
    return {
        data: (0, create_1.pluginManifestQuestion)(),
        children: [
            {
                data: apiSpecFromPluginManifestQuestion(),
                condition: async (inputs) => {
                    const pluginManifestPath = inputs[constants_3.QuestionNames.PluginManifestFilePath];
                    if (!!!pluginManifestPath) {
                        return false;
                    }
                    const pluginManifest = (await fs_extra_1.default.readJson(pluginManifestPath));
                    const specs = pluginManifest
                        .runtimes.filter((runtime) => runtime.type === "OpenApi")
                        .map((runtime) => runtime.spec.url);
                    const spesDedup = [...new Set(specs)];
                    if (spesDedup.length === 1) {
                        inputs[constants_3.QuestionNames.ApiSpecLocation] = spesDedup[0];
                        return false;
                    }
                    return true;
                },
            },
            {
                data: apiFromPluginManifestQuestion(),
                condition: async (inputs) => {
                    const pluginManifestPath = inputs[constants_3.QuestionNames.PluginManifestFilePath];
                    const apiSpecPath = inputs[constants_3.QuestionNames.ApiSpecLocation];
                    if (!!!pluginManifestPath || !!!apiSpecPath) {
                        return false;
                    }
                    const pluginManifest = (await fs_extra_1.default.readJson(pluginManifestPath));
                    const apis = [];
                    pluginManifest
                        .runtimes.filter((runtime) => runtime.type === "OpenApi" && runtime.spec.url === apiSpecPath)
                        .forEach((runtime) => {
                        apis.push(...runtime.run_for_functions);
                    });
                    const apisDedup = [...new Set(apis)];
                    if (apisDedup.length === 1) {
                        inputs[constants_3.QuestionNames.ApiOperation] = apisDedup;
                        return false;
                    }
                    return true;
                },
            },
            {
                data: authNameQuestion(),
            },
            {
                data: addAuthActionAuthTypeQuestion(),
            },
            oauthParametersQuestion(),
            apiKeyParameterQuestion(),
            microsoftEntraParameterQuestion(),
        ],
    };
}
exports.addAuthActionQuestion = addAuthActionQuestion;
function urlValidation(input, allowEmpty = false) {
    if (input.trim() === "") {
        return allowEmpty ? undefined : (0, localizeUtils_1.getLocalizedString)("core.addAuthAction.validation.url");
    }
    try {
        new URL(input);
    }
    catch (error) {
        return (0, localizeUtils_1.getLocalizedString)("core.addAuthAction.validation.url");
    }
    return undefined;
}
exports.urlValidation = urlValidation;
function addAuthActionAuthTypeQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.ApiAuth,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiMessageExtensionAuth.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiMessageExtensionAuth.placeholder"),
        cliDescription: "The authentication type for the API.",
        staticOptions: constants_3.AddAuthActionAuthTypeOptions.all(),
        default: constants_3.AddAuthActionAuthTypeOptions.bearerToken().id,
    };
}
exports.addAuthActionAuthTypeQuestion = addAuthActionAuthTypeQuestion;
function oauthParametersQuestion() {
    return {
        data: oauthAuthorizationUrlQuestion(),
        condition: (inputs) => {
            return inputs[constants_3.QuestionNames.ApiAuth] === constants_3.AddAuthActionAuthTypeOptions.oauth().id;
        },
        children: [
            {
                data: oauthTokenUrlQuestion(),
            },
            {
                data: oauthRefreshUrlQuestion(),
            },
            {
                data: oauthScopeQuestion(),
            },
            {
                data: oauthPKCEQuestion(),
            },
        ],
    };
}
exports.oauthParametersQuestion = oauthParametersQuestion;
function oauthAuthorizationUrlQuestion() {
    return {
        name: constants_3.QuestionNames.OAuthAuthorizationUrl,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.OAuthAuthorizationUrl.title"),
        type: "text",
        cliDescription: "Authorization Url for oauth.",
        validation: {
            validFunc: (input) => urlValidation(input, false),
        },
    };
}
exports.oauthAuthorizationUrlQuestion = oauthAuthorizationUrlQuestion;
function oauthTokenUrlQuestion() {
    return {
        name: constants_3.QuestionNames.OAuthTokenUrl,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.OAuthTokenUrl.title"),
        type: "text",
        cliDescription: "Token Url for oauth.",
        validation: {
            validFunc: (input) => urlValidation(input, false),
        },
    };
}
exports.oauthTokenUrlQuestion = oauthTokenUrlQuestion;
function oauthRefreshUrlQuestion() {
    return {
        name: constants_3.QuestionNames.OAuthRefreshUrl,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.OAuthRefreshUrl.title"),
        type: "text",
        cliDescription: "Refresh Url for oauth. Leave it emplt if not needed.",
        validation: {
            validFunc: (input) => urlValidation(input, true),
        },
    };
}
exports.oauthRefreshUrlQuestion = oauthRefreshUrlQuestion;
function oauthScopeQuestion() {
    return {
        name: constants_3.QuestionNames.OAuthScope,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.OAuthScope.title"),
        type: "text",
        cliDescription: "Scope for oauth.",
        validation: {
            validFunc: (input) => {
                const regExp = /([-a-zA-Z1-9./:_]+:\s*[-a-zA-Z1-9./:_]+)(\s*;\s*[-a-zA-Z1-9./:_]+:\s*[-a-zA-Z1-9./:_]+)*/g;
                if (!regExp.test(input)) {
                    return (0, localizeUtils_1.getLocalizedString)("core.oauthScopeQuestion.validation.scope");
                }
                return undefined;
            },
        },
    };
}
exports.oauthScopeQuestion = oauthScopeQuestion;
function oauthPKCEQuestion() {
    return {
        name: constants_3.QuestionNames.OauthPKCE,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.OauthPKCE.title"),
        type: "singleSelect",
        staticOptions: [
            {
                id: "true",
                label: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.OauthPKCE.true"),
            },
            {
                id: "false",
                label: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.OauthPKCE.false"),
            },
        ],
        default: "false",
    };
}
exports.oauthPKCEQuestion = oauthPKCEQuestion;
function apiKeyParameterQuestion() {
    return {
        data: apiKeyInQuestion(),
        condition: (inputs) => {
            return inputs[constants_3.QuestionNames.ApiAuth] === constants_3.AddAuthActionAuthTypeOptions.apiKey().id;
        },
        children: [
            {
                data: apiKeyNameQuestion(),
            },
        ],
    };
}
exports.apiKeyParameterQuestion = apiKeyParameterQuestion;
function apiKeyInQuestion() {
    return {
        name: constants_3.QuestionNames.ApiKeyIn,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.ApiKeyIn.title"),
        type: "singleSelect",
        staticOptions: [
            {
                id: "header",
                label: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.ApiKeyIn.header"),
            },
            {
                id: "query",
                label: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.ApiKeyIn.query"),
            },
        ],
        default: "header",
    };
}
exports.apiKeyInQuestion = apiKeyInQuestion;
function apiKeyNameQuestion() {
    return {
        name: constants_3.QuestionNames.ApiKeyName,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.ApiKeyName.title"),
        type: "text",
        cliDescription: "Name of the API key.",
    };
}
exports.apiKeyNameQuestion = apiKeyNameQuestion;
function microsoftEntraParameterQuestion() {
    return {
        data: oauthScopeQuestion(),
        condition: (inputs) => {
            return inputs[constants_3.QuestionNames.ApiAuth] === constants_3.AddAuthActionAuthTypeOptions.microsoftEntra().id;
        },
    };
}
exports.microsoftEntraParameterQuestion = microsoftEntraParameterQuestion;
function apiSpecFromPluginManifestQuestion() {
    return {
        name: constants_3.QuestionNames.ApiSpecLocation,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.ApiSpecLocation.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.ApiSpecLocation.placeholder"),
        type: "singleSelect",
        staticOptions: [],
        cliDescription: "OpenAPI specification to add Auth configuration.",
        dynamicOptions: async (inputs) => {
            const pluginManifestPath = inputs[constants_3.QuestionNames.PluginManifestFilePath];
            const pluginManifest = (await fs_extra_1.default.readJson(pluginManifestPath));
            const specs = pluginManifest
                .runtimes.filter((runtime) => runtime.type === "OpenApi")
                .map((runtime) => runtime.spec.url);
            return [...new Set(specs)];
        },
    };
}
exports.apiSpecFromPluginManifestQuestion = apiSpecFromPluginManifestQuestion;
function apiFromPluginManifestQuestion() {
    return {
        name: constants_3.QuestionNames.ApiOperation,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.ApiOperation.title"),
        type: "multiSelect",
        staticOptions: [],
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.ApiOperation.placeholder"),
        cliDescription: "API to add Auth configuration.",
        dynamicOptions: async (inputs) => {
            const pluginManifestPath = inputs[constants_3.QuestionNames.PluginManifestFilePath];
            const apiSpecPath = inputs[constants_3.QuestionNames.ApiSpecLocation];
            const pluginManifest = (await fs_extra_1.default.readJson(pluginManifestPath));
            const apis = [];
            pluginManifest
                .runtimes.filter((runtime) => runtime.type === "OpenApi" && runtime.spec.url === apiSpecPath)
                .forEach((runtime) => {
                apis.push(...runtime.run_for_functions);
            });
            return [...new Set(apis)];
        },
    };
}
exports.apiFromPluginManifestQuestion = apiFromPluginManifestQuestion;
function authNameQuestion() {
    return {
        name: constants_3.QuestionNames.AuthName,
        title: (0, localizeUtils_1.getLocalizedString)("core.addAuthActionQuestion.authName.title"),
        type: "text",
        cliDescription: "Name of Auth Configuration.",
        validation: {
            validFunc: (input) => {
                if (!input || input.trim() === "") {
                    return (0, localizeUtils_1.getLocalizedString)("core.authNameQuestion.validation.empty");
                }
                return undefined;
            },
        },
        additionalValidationOnAccept: {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                inputs[constants_3.QuestionNames.ActionType] = constants_3.ActionStartOptions.newApi().id;
                return;
            },
        },
    };
}
exports.authNameQuestion = authNameQuestion;
function apiSpecApiKeyConfirmQestion() {
    return {
        name: constants_3.QuestionNames.ApiSpecApiKeyConfirm,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.ApiKeyConfirm"),
        type: "confirm",
        default: true,
    };
}
exports.apiSpecApiKeyConfirmQestion = apiSpecApiKeyConfirmQestion;
function apiSpecApiKeyQuestion() {
    return {
        data: {
            type: "text",
            name: constants_3.QuestionNames.ApiSpecApiKey,
            cliShortName: "k",
            password: true,
            title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.ApiKey"),
            cliDescription: "Api key for OpenAPI spec.",
            forgetLastValue: true,
            validation: {
                validFunc: (input) => {
                    if (input.length < 10 || input.length > 512) {
                        return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.invalidApiKey.message");
                    }
                    return undefined;
                },
            },
            additionalValidationOnAccept: {
                validFunc: (input, inputs) => {
                    if (!inputs) {
                        throw new Error("inputs is undefined"); // should never happen
                    }
                    process.env[constants_3.QuestionNames.ApiSpecApiKey] = input;
                    return;
                },
            },
        },
        condition: (inputs) => {
            return (inputs.outputEnvVarNames &&
                !process.env[inputs.outputEnvVarNames.get("registrationId")] &&
                !inputs.primaryClientSecret &&
                !inputs.secondaryClientSecret);
        },
        children: [
            {
                data: apiSpecApiKeyConfirmQestion(),
            },
        ],
    };
}
exports.apiSpecApiKeyQuestion = apiSpecApiKeyQuestion;
function oauthQuestion() {
    return {
        data: { type: "group" },
        condition: (inputs) => {
            return (inputs.outputEnvVarNames && !process.env[inputs.outputEnvVarNames.get("configurationId")]);
        },
        children: [
            {
                data: oauthClientIdQuestion(),
                condition: (inputs) => {
                    return !inputs.clientId;
                },
            },
            {
                data: oauthClientSecretQuestion(),
                condition: (inputs) => {
                    return (!inputs.isPKCEEnabled &&
                        !inputs.clientSecret &&
                        (!inputs.identityProvider || inputs.identityProvider === "Custom"));
                },
            },
            {
                data: oauthConfirmQestion(),
                condition: (inputs) => {
                    return (!inputs.isPKCEEnabled &&
                        (!inputs.clientSecret || !inputs.clientId) &&
                        (!inputs.identityProvider || inputs.identityProvider === "Custom"));
                },
            },
        ],
    };
}
exports.oauthQuestion = oauthQuestion;
function uninstallQuestionNode() {
    return {
        data: {
            type: "group",
        },
        children: [
            {
                data: uninstallModeQuestion(),
                condition: () => {
                    return true;
                },
                children: [
                    {
                        data: {
                            type: "text",
                            name: constants_3.QuestionNames.ManifestId,
                            title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.manifestId"),
                        },
                        condition: (input) => {
                            return input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeManifestId;
                        },
                    },
                    {
                        data: {
                            type: "text",
                            name: constants_3.QuestionNames.Env,
                            title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.env"),
                        },
                        condition: (input) => {
                            return input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeEnv;
                        },
                        children: [
                            {
                                data: uninstallProjectPathQuestion(),
                                condition: () => {
                                    return true;
                                },
                            },
                        ],
                    },
                    {
                        data: uninstallOptionQuestion(),
                        condition: (input) => {
                            return (input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeManifestId ||
                                input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeEnv);
                        },
                    },
                    {
                        data: {
                            type: "text",
                            name: constants_3.QuestionNames.TitleId,
                            title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.titleId"),
                        },
                        condition: (input) => {
                            return input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeTitleId;
                        },
                    },
                ],
            },
        ],
    };
}
exports.uninstallQuestionNode = uninstallQuestionNode;
function uninstallModeQuestion() {
    return {
        name: constants_3.QuestionNames.UninstallMode,
        title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.chooseMode"),
        type: "singleSelect",
        staticOptions: [
            {
                id: constants_3.QuestionNames.UninstallModeManifestId,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.manifestIdMode"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.manifestIdMode.detail"),
            },
            {
                id: constants_3.QuestionNames.UninstallModeEnv,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.envMode"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.envMode.detail"),
            },
            {
                id: constants_3.QuestionNames.UninstallModeTitleId,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.titleIdMode"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.titleIdMode.detail"),
            },
        ],
        default: constants_3.QuestionNames.UninstallModeManifestId,
    };
}
function uninstallOptionQuestion() {
    return {
        name: constants_3.QuestionNames.UninstallOptions,
        title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.chooseOption"),
        type: "multiSelect",
        staticOptions: [
            {
                id: constants_3.QuestionNames.UninstallOptionM365,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.m365Option"),
            },
            {
                id: constants_3.QuestionNames.UninstallOptionTDP,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.tdpOption"),
            },
            {
                id: constants_3.QuestionNames.UninstallOptionBot,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.botOption"),
            },
        ],
    };
}
function uninstallProjectPathQuestion() {
    return {
        type: "folder",
        name: constants_3.QuestionNames.ProjectPath,
        title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.projectPath"),
        cliDescription: "Project Path for uninstall",
        placeholder: "./",
        default: "./",
    };
}
function oauthClientIdQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.OauthClientId,
        cliShortName: "i",
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.OauthClientId"),
        cliDescription: "Oauth client id for OpenAPI spec.",
        forgetLastValue: true,
        additionalValidationOnAccept: {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                process.env[constants_3.QuestionNames.OauthClientId] = input;
                return;
            },
        },
    };
}
function oauthConfirmQestion() {
    return {
        name: constants_3.QuestionNames.OauthConfirm,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.OauthClientSecretConfirm"),
        type: "confirm",
        default: true,
    };
}
function oauthClientSecretQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.OauthClientSecret,
        cliShortName: "c",
        password: true,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.OauthClientSecret"),
        cliDescription: "Oauth client secret for OpenAPI spec.",
        forgetLastValue: true,
        validation: {
            validFunc: (input) => {
                if (input.length < 10 || input.length > 512) {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.invalidApiKey.message");
                }
                return undefined;
            },
        },
        additionalValidationOnAccept: {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                process.env[constants_3.QuestionNames.OauthClientSecret] = input;
                return;
            },
        },
    };
}
function syncManifestQuestionNode() {
    return {
        data: {
            type: "group",
        },
        children: [
            {
                data: {
                    type: "folder",
                    name: constants_3.QuestionNames.ProjectPath,
                    title: (0, localizeUtils_1.getLocalizedString)("core.syncManifest.projectPath"),
                    cliDescription: "Project Path",
                    placeholder: "./",
                    default: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform)
                        ? "./"
                        : path.join(os.homedir(), constants_1.ConstantString.RootFolder),
                },
            },
            {
                data: {
                    type: "text",
                    name: constants_3.QuestionNames.Env,
                    title: (0, localizeUtils_1.getLocalizedString)("core.syncManifest.env"),
                    cliDescription: "Target Microsoft 365 Agents Toolkit Environment",
                },
            },
            {
                data: {
                    type: "text",
                    name: constants_3.QuestionNames.TeamsAppId,
                    title: (0, localizeUtils_1.getLocalizedString)("core.syncManifest.teamsAppId"),
                    cliDescription: "App ID (optional)",
                },
            },
        ],
    };
}
exports.syncManifestQuestionNode = syncManifestQuestionNode;
function setSensitivityLabelNode() {
    return {
        data: {
            type: "group",
        },
        children: [
            {
                data: selectDeclarativeAgentManifestQuestion(),
            },
            {
                data: SelectSensitivityLabelQuestion(),
            },
        ],
    };
}
exports.setSensitivityLabelNode = setSensitivityLabelNode;
function selectDeclarativeAgentManifestQuestion() {
    return {
        name: constants_3.QuestionNames.DeclarativeAgentManifestPath,
        cliName: "declarative-agent-manifest-file",
        cliShortName: "d",
        cliDescription: "Specify the path for the Declarative Agent manifest. It can be either absolute path or relative path to the project root folder, with default at './appPackage/declarativeAgent.json'",
        title: (0, localizeUtils_1.getLocalizedString)("core.selectDeclarativeAgentManifestQuestion.title"),
        type: "singleFile",
        default: async (inputs) => {
            var _a, _b, _c;
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./appPackage/declarativeAgent.json";
            }
            else {
                if (!inputs.projectPath) {
                    return Promise.resolve(undefined);
                }
                const manifestPath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, "manifest.json");
                if (!fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return Promise.resolve(undefined);
                }
                const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
                if (manifestRes.isErr()) {
                    return Promise.resolve(undefined);
                }
                const manifest = manifestRes.value;
                const declarativeAgentPath = (_c = (_b = (_a = manifest === null || manifest === void 0 ? void 0 : manifest.copilotAgents) === null || _a === void 0 ? void 0 : _a.declarativeAgents) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.file;
                if (!declarativeAgentPath) {
                    return Promise.resolve(undefined);
                }
                const declarativeAgentAbsolutePath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, declarativeAgentPath);
                if (!fs_extra_1.default.pathExistsSync(declarativeAgentAbsolutePath)) {
                    return Promise.resolve(undefined);
                }
                return declarativeAgentAbsolutePath;
            }
        },
    };
}
exports.selectDeclarativeAgentManifestQuestion = selectDeclarativeAgentManifestQuestion;
function SelectSensitivityLabelQuestion() {
    return {
        name: constants_3.QuestionNames.SensitivityLabel,
        cliName: "sensitivity-label",
        cliShortName: "s",
        cliDescription: "Specify the sensitivity label to be set.",
        title: (0, localizeUtils_1.getLocalizedString)("core.selectSensitivityLabelQuestion.title"),
        type: "singleSelect",
        // Different tenant may have different sensitivity labels, so the options are always dynamic
        staticOptions: [],
        dynamicOptions: async (inputs) => {
            var _a, _b, _c;
            const tokenRes = await globalVars_1.TOOLS.tokenProvider.m365TokenProvider.getAccessToken({
                scopes: [constants_1.ListSensitivityLabelScope],
            });
            if (tokenRes.isErr()) {
                throw tokenRes.error;
            }
            const graphClient = new graphClient_1.GraphClient(globalVars_1.TOOLS.tokenProvider.m365TokenProvider);
            const res = await graphClient.listSensitivityLabels(tokenRes.value);
            if (res.isErr()) {
                throw res.error;
            }
            const options = [];
            for (const label of res.value) {
                options.push({
                    id: (_a = label.id) !== null && _a !== void 0 ? _a : "",
                    label: (_b = label.displayName) !== null && _b !== void 0 ? _b : "",
                    description: (_c = label.description) !== null && _c !== void 0 ? _c : "",
                });
            }
            return options;
        },
        skipValidation: true,
    };
}
exports.SelectSensitivityLabelQuestion = SelectSensitivityLabelQuestion;
//# sourceMappingURL=other.js.map