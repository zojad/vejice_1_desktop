"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSampleProjectQuestionNode = exports.GCConnectionIdQuestion = exports.GCNameQuestion = exports.searchTypeQuestion = exports.webContentQuestion = exports.GCInputQuestion = exports.GCListQuestion = exports.GCItemQuestion = exports.oneDriveSharePointItemConfirmQuestion = exports.oneDriveSharePointItemQuestion = exports.addKnowledgeStartQuestion = exports.pluginApiSpecQuestion = exports.pluginManifestQuestion = exports.selectApiOperationForRegenerateQuestion = exports.selectOpenAPISpecFromPluginQuestion = exports.selectExistingPluginManifestQuestion = exports.apiPluginStartQuestion = exports.azureOpenAIEmbeddingDeploymentNameQuestion = exports.azureOpenAIAssistantIdQuestion = exports.openAIAssistantIdQuestion = exports.azureOpenAIDeploymentNameQuestion = exports.azureOpenAIEndpointQuestion = exports.azureOpenAIKeyQuestion = exports.openAIKeyQuestion = exports.apiOperationQuestion = exports.apiAuthQuestion = exports.apiSpecLocationQuestion = exports.selectOpenApiSpecQuestion = exports.searchOpenAPISpecQueryQuestion = exports.apiSpecTypeSelectQuestion = exports.selectBotIdsQuestion = exports.selectTabsContentUrlQuestion = exports.selectTabWebsiteUrlQuestion = exports.getTabWebsiteOptions = exports.appNameQuestion = exports.getSolutionName = exports.folderQuestion = exports.SPFxImportFolderQuestion = exports.SPFxWebpartNameQuestion = exports.SPFxFrameworkQuestion = exports.SPFxPackageSelectQuestion = exports.SPFxSolutionQuestion = exports.getProjectTypeAndCapability = void 0;
const tslib_1 = require("tslib");
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const jsonschema = tslib_1.__importStar(require("jsonschema"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("../common/constants");
const correlator_1 = require("../common/correlator");
const daSpecParser_1 = require("../common/daSpecParser");
const globalVars_1 = require("../common/globalVars");
const kiotaClient_1 = require("../common/kiotaClient");
const localizeUtils_1 = require("../common/localizeUtils");
const samples_1 = require("../common/samples");
const stringUtils_1 = require("../common/stringUtils");
const telemetry_1 = require("../common/telemetry");
const PluginManifestUtils_1 = require("../component/driver/teamsApp/utils/PluginManifestUtils");
const utils_1 = require("../component/driver/teamsApp/utils/utils");
const constant_1 = require("../component/generator/constant");
const helper_1 = require("../component/generator/declarativeAgent/helper");
const helper_2 = require("../component/generator/openApiSpec/helper");
const error_1 = require("../component/generator/spfx/error");
const constants_2 = require("../component/generator/spfx/utils/constants");
const utils_2 = require("../component/generator/spfx/utils/utils");
const templateNames_1 = require("../component/generator/templates/templateNames");
const error_2 = require("../error");
const constants_3 = require("./constants");
const CapabilityOptions_1 = require("./scaffold/vsc/CapabilityOptions");
const ProjectTypeOptions_1 = require("./scaffold/vsc/ProjectTypeOptions");
const utils_3 = require("./utils");
const ManifestUtils_1 = require("../component/driver/teamsApp/utils/ManifestUtils");
function getProjectTypeAndCapability(teamsApp) {
    // bot
    if ((0, utils_1.isBot)(teamsApp)) {
        return { projectType: "bot-type", templateId: CapabilityOptions_1.BotCapabilityOptions.basicBot().id };
    }
    // bot based message extension
    if ((0, utils_1.isBotBasedMessageExtension)(teamsApp)) {
        return { projectType: "me-type", templateId: CapabilityOptions_1.MeCapabilityOptions.basicMe().id };
    }
    // tab only
    if ((0, utils_1.needTabCode)(teamsApp)) {
        return { projectType: "tab-type", templateId: CapabilityOptions_1.TabCapabilityOptions.nonSsoTab().id };
    }
    return undefined;
}
exports.getProjectTypeAndCapability = getProjectTypeAndCapability;
function SPFxSolutionQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SPFxSolution,
        title: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.title"),
        cliDescription: "Create a new or import an existing SharePoint Framework solution.",
        cliShortName: "s",
        staticOptions: [
            {
                id: "new",
                label: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.createNew"),
                detail: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.createNew.detail"),
            },
            {
                id: "import",
                label: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.importExisting"),
                detail: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.importExisting.detail"),
            },
        ],
        default: "new",
    };
}
exports.SPFxSolutionQuestion = SPFxSolutionQuestion;
function SPFxPackageSelectQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SPFxInstallPackage,
        title: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.title"),
        cliDescription: "Install the latest version of SharePoint Framework.",
        staticOptions: [],
        placeholder: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.placeholder"),
        dynamicOptions: async (inputs) => {
            const versions = await Promise.all([
                utils_2.Utils.findGloballyInstalledVersion(undefined, constants_2.Constants.GeneratorPackageName, 0, false),
                utils_2.Utils.findLatestVersion(undefined, constants_2.Constants.GeneratorPackageName, 5),
                utils_2.Utils.findGloballyInstalledVersion(undefined, constants_2.Constants.YeomanPackageName, 0, false),
            ]);
            inputs.globalSpfxPackageVersion = versions[0];
            inputs.latestSpfxPackageVersion = versions[1];
            inputs.globalYeomanPackageVersion = versions[2];
            return [
                {
                    id: constants_3.SPFxVersionOptionIds.installLocally,
                    label: versions[1] !== undefined
                        ? (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.installLocally.withVersion.label", "v" + versions[1])
                        : (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.installLocally.noVersion.label"),
                },
                {
                    id: constants_3.SPFxVersionOptionIds.globalPackage,
                    label: versions[0] !== undefined
                        ? (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.useGlobalPackage.withVersion.label", "v" + versions[0])
                        : (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.useGlobalPackage.noVersion.label"),
                    description: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.useGlobalPackage.detail", constants_2.Constants.RecommendedLowestSpfxVersion),
                },
            ];
        },
        default: constants_3.SPFxVersionOptionIds.installLocally,
        validation: {
            validFunc: (input, previousInputs) => {
                if (input === constants_3.SPFxVersionOptionIds.globalPackage) {
                    const hasPackagesInstalled = !!previousInputs &&
                        !!previousInputs.globalSpfxPackageVersion &&
                        !!previousInputs.globalYeomanPackageVersion;
                    if (!hasPackagesInstalled) {
                        return Promise.reject((0, error_1.DevEnvironmentSetupError)());
                    }
                }
                return Promise.resolve(undefined);
            },
        },
        isBoolean: true,
    };
}
exports.SPFxPackageSelectQuestion = SPFxPackageSelectQuestion;
function SPFxFrameworkQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SPFxFramework,
        cliShortName: "k",
        cliDescription: "Framework.",
        title: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.framework.title"),
        staticOptions: [
            { id: "react", label: "React" },
            { id: "minimal", label: "Minimal" },
            { id: "none", label: "None" },
        ],
        placeholder: "Select an option",
        default: "react",
    };
}
exports.SPFxFrameworkQuestion = SPFxFrameworkQuestion;
function SPFxWebpartNameQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.SPFxWebpartName,
        cliShortName: "w",
        cliDescription: "Name for SharePoint Framework Web Part.",
        title: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.webpartName"),
        default: constants_2.Constants.DEFAULT_WEBPART_NAME,
        validation: {
            validFunc: async (input, previousInputs) => {
                const schema = {
                    pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$",
                };
                const validateRes = jsonschema.validate(input, schema);
                if (validateRes.errors && validateRes.errors.length > 0) {
                    return (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.webpartName.error.notMatch", input, schema.pattern);
                }
                if (previousInputs &&
                    ((previousInputs.stage === teamsfx_api_1.Stage.addWebpart &&
                        previousInputs[constants_3.QuestionNames.SPFxFolder]) ||
                        ((previousInputs === null || previousInputs === void 0 ? void 0 : previousInputs.stage) === teamsfx_api_1.Stage.addFeature && (previousInputs === null || previousInputs === void 0 ? void 0 : previousInputs.projectPath)))) {
                    const webpartFolder = path.join(previousInputs[constants_3.QuestionNames.SPFxFolder], "src", "webparts", input);
                    if (await fs_extra_1.default.pathExists(webpartFolder)) {
                        return (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.webpartName.error.duplicate", webpartFolder);
                    }
                }
                return undefined;
            },
        },
    };
}
exports.SPFxWebpartNameQuestion = SPFxWebpartNameQuestion;
function SPFxImportFolderQuestion(hasDefaultFunc = false) {
    return {
        type: "folder",
        name: constants_3.QuestionNames.SPFxFolder,
        title: (0, localizeUtils_1.getLocalizedString)("core.spfxFolder.title"),
        cliDescription: "Directory or Path that contains the existing SharePoint Framework solution.",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.spfxFolder.placeholder"),
        default: hasDefaultFunc
            ? (inputs) => {
                if (inputs.projectPath)
                    return path.join(inputs.projectPath, "src");
                return undefined;
            }
            : undefined,
    };
}
exports.SPFxImportFolderQuestion = SPFxImportFolderQuestion;
function folderQuestion() {
    return {
        type: "folder",
        name: constants_3.QuestionNames.Folder,
        cliShortName: "f",
        title: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform)
            ? "Directory where the project folder will be created in"
            : (0, localizeUtils_1.getLocalizedString)("core.question.workspaceFolder.title"),
        cliDescription: "Directory where the project folder will be created in.",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.question.workspaceFolder.placeholder"),
        default: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform)
            ? "./"
            : path.join(os.homedir(), constants_1.ConstantString.RootFolder),
    };
}
exports.folderQuestion = folderQuestion;
async function getSolutionName(spfxFolder) {
    const yoInfoPath = path.join(spfxFolder, constants_2.Constants.YO_RC_FILE);
    if (await fs_extra_1.default.pathExists(yoInfoPath)) {
        const yoInfo = await fs_extra_1.default.readJson(yoInfoPath);
        if (yoInfo["@microsoft/generator-sharepoint"]) {
            return yoInfo["@microsoft/generator-sharepoint"][constants_2.Constants.YO_RC_SOLUTION_NAME];
        }
        else {
            return undefined;
        }
    }
    else {
        throw new error_2.FileNotFoundError(constants_2.Constants.PLUGIN_NAME, yoInfoPath, constants_2.Constants.IMPORT_HELP_LINK);
    }
}
exports.getSolutionName = getSolutionName;
function appNameQuestion() {
    const question = {
        type: "text",
        name: constants_3.QuestionNames.AppName,
        cliShortName: "n",
        title: (0, localizeUtils_1.getLocalizedString)("core.question.appName.title"),
        required: true,
        default: async (inputs) => {
            var _a, _b;
            let defaultName = undefined;
            if ((_a = inputs.teamsAppFromTdp) === null || _a === void 0 ? void 0 : _a.appName) {
                defaultName = (0, stringUtils_1.convertToAlphanumericOnly)((_b = inputs.teamsAppFromTdp) === null || _b === void 0 ? void 0 : _b.appName);
            }
            else if (inputs[constants_3.QuestionNames.SPFxSolution] == "import") {
                defaultName = await getSolutionName(inputs[constants_3.QuestionNames.SPFxFolder]);
            }
            return defaultName;
        },
        validation: {
            validFunc: async (input, previousInputs) => {
                const schema = {
                    pattern: constants_3.AppNamePattern,
                    maxLength: 30,
                };
                if (input.length === 25) {
                    // show warning notification because it may exceed the Teams app name max length after appending suffix
                    const context = (0, globalVars_1.createContext)();
                    if ((previousInputs === null || previousInputs === void 0 ? void 0 : previousInputs.platform) === teamsfx_api_1.Platform.VSCode) {
                        void context.userInteraction.showMessage("warn", (0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.lengthWarning"), false);
                    }
                    else {
                        context.logProvider.warning((0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.lengthWarning"));
                    }
                }
                const appName = input;
                const validateResult = jsonschema.validate(appName, schema);
                if (validateResult.errors && validateResult.errors.length > 0) {
                    if (validateResult.errors[0].name === "pattern") {
                        return (0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.pattern");
                    }
                    if (validateResult.errors[0].name === "maxLength") {
                        return (0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.maxlength");
                    }
                }
                if (previousInputs && previousInputs.folder) {
                    const folder = previousInputs.folder;
                    if (folder) {
                        const projectPath = path.resolve(folder, appName);
                        const exists = await fs_extra_1.default.pathExists(projectPath);
                        if (exists)
                            return (0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.pathExist", projectPath);
                    }
                }
                return undefined;
            },
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.question.appName.placeholder"),
    };
    return question;
}
exports.appNameQuestion = appNameQuestion;
function sampleSelectQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.Samples,
        cliName: "sample-name",
        cliDescription: "Specifies the app sample name.",
        cliChoiceListCommand: "teamsapp list samples",
        skipValidation: true,
        cliType: "argument",
        title: (0, localizeUtils_1.getLocalizedString)("core.SampleSelect.title"),
        staticOptions: [
            "hello-world-tab-with-backend",
            "graph-toolkit-contact-exporter",
            "bot-sso",
            "todo-list-SPFx",
            "hello-world-in-meeting",
            "todo-list-with-Azure-backend-M365",
            "NPM-search-connector-M365",
            "bot-proactive-messaging-teamsfx",
            "adaptive-card-notification",
            "incoming-webhook-notification",
            "stocks-update-notification-bot",
            "query-org-user-with-message-extension-sso",
            "team-central-dashboard",
            "graph-connector-app",
            "graph-toolkit-one-productivity-hub",
            "todo-list-with-Azure-backend",
            "share-now",
            "hello-world-teams-tab-and-outlook-add-in",
            "outlook-add-in-set-signature",
            "developer-assist-dashboard",
            "live-share-dice-roller",
            "teams-chef-bot",
            "spfx-productivity-dashboard",
            "react-retail-dashboard",
            "sso-enabled-tab-via-apim-proxy",
            "large-scale-notification",
            "graph-connector-bot",
        ],
        dynamicOptions: async () => {
            return (await samples_1.sampleProvider.SampleCollection).samples.map((sample) => {
                return {
                    id: sample.id,
                    label: sample.title,
                    description: `${sample.time} â€¢ ${sample.configuration}`,
                    detail: sample.shortDescription,
                };
            });
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.SampleSelect.placeholder"),
        buttons: [
            {
                icon: "library",
                tooltip: (0, localizeUtils_1.getLocalizedString)("core.SampleSelect.buttons.viewSamples"),
                command: "fx-extension.openSamples",
            },
        ],
    };
}
const defaultTabLocalHostUrl = "https://localhost:53000/index.html#/tab";
const tabContentUrlOptionItem = (tab) => {
    return {
        id: tab.name,
        label: tab.name,
        detail: (0, localizeUtils_1.getLocalizedString)("core.updateContentUrlOption.description", tab.contentUrl, defaultTabLocalHostUrl),
    };
};
const tabWebsiteUrlOptionItem = (tab) => {
    return {
        id: tab.name,
        label: tab.name,
        detail: (0, localizeUtils_1.getLocalizedString)("core.updateWebsiteUrlOption.description", tab.websiteUrl, defaultTabLocalHostUrl),
    };
};
function getTabWebsiteOptions(inputs) {
    const appDefinition = inputs.teamsAppFromTdp;
    if (appDefinition === null || appDefinition === void 0 ? void 0 : appDefinition.staticTabs) {
        const tabsWithWebsiteUrls = appDefinition.staticTabs.filter((o) => !!o.websiteUrl);
        if (tabsWithWebsiteUrls.length > 0) {
            return tabsWithWebsiteUrls.map((o) => tabWebsiteUrlOptionItem(o));
        }
    }
    return [];
}
exports.getTabWebsiteOptions = getTabWebsiteOptions;
function selectTabWebsiteUrlQuestion() {
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.ReplaceWebsiteUrl,
        title: (0, localizeUtils_1.getLocalizedString)("core.updateWebsiteUrlQuestion.title"),
        staticOptions: [],
        dynamicOptions: getTabWebsiteOptions,
        default: "all",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.updateUrlQuestion.placeholder"),
        forgetLastValue: true,
    };
}
exports.selectTabWebsiteUrlQuestion = selectTabWebsiteUrlQuestion;
function getTabContentUrlOptions(inputs) {
    const appDefinition = inputs.teamsAppFromTdp;
    if (appDefinition === null || appDefinition === void 0 ? void 0 : appDefinition.staticTabs) {
        const tabsWithContentUrls = appDefinition.staticTabs.filter((o) => !!o.contentUrl);
        if (tabsWithContentUrls.length > 0) {
            return tabsWithContentUrls.map((o) => tabContentUrlOptionItem(o));
        }
    }
    return [];
}
const selectTabsContentUrlQuestion = () => {
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.ReplaceContentUrl,
        title: (0, localizeUtils_1.getLocalizedString)("core.updateContentUrlQuestion.title"),
        staticOptions: [],
        dynamicOptions: getTabContentUrlOptions,
        default: "all",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.updateUrlQuestion.placeholder"),
        forgetLastValue: true,
    };
};
exports.selectTabsContentUrlQuestion = selectTabsContentUrlQuestion;
const answerToRepaceBotId = "bot";
const answerToReplaceMessageExtensionBotId = "messageExtension";
const botOptionItem = (isMessageExtension, botId) => {
    return {
        id: isMessageExtension ? answerToReplaceMessageExtensionBotId : answerToRepaceBotId,
        label: isMessageExtension
            ? (0, localizeUtils_1.getLocalizedString)("core.updateBotIdForMessageExtension.label")
            : (0, localizeUtils_1.getLocalizedString)("core.updateBotIdForBot.label"),
        detail: isMessageExtension
            ? (0, localizeUtils_1.getLocalizedString)("core.updateBotIdForMessageExtension.description", botId)
            : (0, localizeUtils_1.getLocalizedString)("core.updateBotIdForBot.description", botId),
    };
};
function getBotIdAndMeId(appDefinition) {
    const bots = appDefinition.bots;
    const messageExtensions = appDefinition.messagingExtensions;
    // can add only one bot. If existing, the length is 1.
    const botId = !!bots && bots.length > 0 ? bots[0].botId : undefined;
    // can add only one message extension. If existing, the length is 1.
    const messageExtensionId = !!messageExtensions && messageExtensions.length > 0 ? messageExtensions[0].botId : undefined;
    return [botId, messageExtensionId];
}
function getBotOptions(inputs) {
    const appDefinition = inputs.teamsAppFromTdp;
    if (!appDefinition)
        return [];
    const [botId, messageExtensionId] = getBotIdAndMeId(appDefinition);
    const options = [];
    if (botId) {
        options.push(botOptionItem(false, botId));
    }
    if (messageExtensionId) {
        options.push(botOptionItem(true, messageExtensionId));
    }
    return options;
}
function selectBotIdsQuestion() {
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.ReplaceBotIds,
        title: (0, localizeUtils_1.getLocalizedString)("core.updateBotIdsQuestion.title"),
        staticOptions: [],
        dynamicOptions: getBotOptions,
        default: "all",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.updateBotIdsQuestion.placeholder"),
        forgetLastValue: true,
    };
}
exports.selectBotIdsQuestion = selectBotIdsQuestion;
function apiSpecTypeSelectQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.OpenAPISpecType,
        title: "OpenAPI Spec Document",
        cliDescription: "The type of the API spec.",
        staticOptions: [
            {
                id: "enter-url-or-open-local-file",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.selectOpenAPISpecFromLocation.label"),
            },
            {
                id: "search-api",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.selectOpenAPISpecFromSearch.label"),
            },
        ],
        onDidSelection(itemOrId, inputs) {
            inputs[constants_3.QuestionNames.ActionType] = constants_3.ActionStartOptions.apiSpec().id;
        },
    };
}
exports.apiSpecTypeSelectQuestion = apiSpecTypeSelectQuestion;
function searchOpenAPISpecQueryQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.SearchOpenAPISpecQuery,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.searchOpenAPISpecQueryQuestion.label"),
        default: "",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.searchOpenAPISpecQueryQuestion.placeholder"),
        additionalValidationOnAccept: {
            validFunc: async (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                const searchResult = await (0, kiotaClient_1.searchOpenAPISpec)(input);
                if (searchResult.length > 0) {
                    inputs["searchResult"] = searchResult;
                }
                else {
                    return "No search result found";
                }
            },
        },
        validation: {
            validFunc: (input, inputs) => {
                if (!input || input.trim().length === 0) {
                    return "Please enter a search query.";
                }
                return undefined;
            },
        },
    };
}
exports.searchOpenAPISpecQueryQuestion = searchOpenAPISpecQueryQuestion;
function selectOpenApiSpecQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SelectOpenApiSpec,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.selectOpenAPISpecQuestion.label"),
        staticOptions: [],
        dynamicOptions: (inputs) => {
            const searchResult = inputs["searchResult"];
            if (searchResult.length > 0) {
                const options = [];
                for (const api of searchResult) {
                    options.push({
                        id: api.url,
                        label: api.key,
                        detail: api.description,
                    });
                }
                return options;
            }
            return [];
        },
    };
}
exports.selectOpenApiSpecQuestion = selectOpenApiSpecQuestion;
const maximumLengthOfDetailsErrorMessageInInputBox = 90;
function apiSpecLocationQuestion(includeExistingAPIs = true) {
    const correlationId = correlator_1.Correlator.getId(); // This is a workaround for VSCode which will lose correlation id when user accepts the value.
    const validationOnAccept = async (input, inputs) => {
        try {
            if (!inputs) {
                throw new Error("inputs is undefined"); // should never happen
            }
            const context = (0, globalVars_1.createContext)();
            const res = await (0, helper_2.listOperations)(context, input.trim(), inputs, includeExistingAPIs, false, inputs.platform === teamsfx_api_1.Platform.VSCode ? correlationId : undefined);
            if (res.isOk()) {
                inputs.supportedApisFromApiSpec = res.value;
            }
            else {
                const errors = res.error;
                if (inputs.platform === teamsfx_api_1.Platform.CLI) {
                    return errors.map((e) => e.content).join("\n");
                }
                if (errors.length === 1 &&
                    errors[0].content.length <= maximumLengthOfDetailsErrorMessageInInputBox) {
                    return errors[0].content;
                }
                else {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.multipleValidationErrors.vscode.message");
                }
            }
        }
        catch (e) {
            const error = (0, error_2.assembleError)(e);
            throw error;
        }
    };
    return {
        type: "singleFileOrText",
        name: constants_3.QuestionNames.ApiSpecLocation,
        cliShortName: "a",
        cliDescription: "OpenAPI description document location.",
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.title"),
        forgetLastValue: true,
        inputBoxConfig: {
            type: "innerText",
            title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.title"),
            placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.placeholder"),
            name: "input-api-spec-url",
            step: 2,
            validation: {
                validFunc: (input, inputs) => {
                    const result = (0, stringUtils_1.isValidHttpUrl)(input.trim())
                        ? undefined
                        : (inputs === null || inputs === void 0 ? void 0 : inputs.platform) === teamsfx_api_1.Platform.CLI
                            ? "Please enter a valid HTTP URL to access your OpenAPI description document or enter a file path of your local OpenAPI description document."
                            : (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.invalidUrl.message");
                    return Promise.resolve(result);
                },
            },
        },
        inputOptionItem: {
            id: "input",
            label: `$(cloud) ` + (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpecInputUrl.label"),
        },
        filters: {
            files: ["json", "yml", "yaml"],
        },
        validation: {
            validFunc: async (input, inputs) => {
                if (!(0, stringUtils_1.isValidHttpUrl)(input.trim()) && !(await fs_extra_1.default.pathExists(input.trim()))) {
                    return "Please enter a valid HTTP URL without authentication to access your OpenAPI description document or enter a file path of your local OpenAPI description document.";
                }
                return await validationOnAccept(input, inputs);
            },
        },
    };
}
exports.apiSpecLocationQuestion = apiSpecLocationQuestion;
function apiAuthQuestion(excludeNone = false) {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.ApiAuth,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiMessageExtensionAuth.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiMessageExtensionAuth.placeholder"),
        cliDescription: "The authentication type for the API.",
        staticOptions: constants_3.ApiAuthOptions.all(),
        dynamicOptions: (inputs) => {
            const options = excludeNone ? [] : [constants_3.ApiAuthOptions.none()];
            if (inputs[constants_3.QuestionNames.MeArchitectureType] === constants_3.MeArchitectureOptions.newApi().id) {
                options.push(constants_3.ApiAuthOptions.bearerToken(), constants_3.ApiAuthOptions.microsoftEntra());
            }
            else if (inputs[constants_3.QuestionNames.ActionType] === constants_3.ActionStartOptions.newApi().id) {
                options.push(constants_3.ApiAuthOptions.apiKey());
                options.push(constants_3.ApiAuthOptions.microsoftEntra());
                options.push(constants_3.ApiAuthOptions.oauth());
            }
            return options;
        },
        default: constants_3.ApiAuthOptions.none().id,
    };
}
exports.apiAuthQuestion = apiAuthQuestion;
function apiOperationQuestion(includeExistingAPIs = true, isAddPlugin = false) {
    // export for unit test
    let placeholder = "";
    const isPlugin = (inputs) => {
        return (isAddPlugin ||
            (!!inputs && inputs[constants_3.QuestionNames.ActionType] === constants_3.ActionStartOptions.apiSpec().id));
    };
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.ApiOperation,
        title: (inputs) => {
            return isPlugin(inputs)
                ? (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.copilotOperation.title")
                : (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.title");
        },
        cliDescription: isAddPlugin
            ? "Select operation(s) Copilot can interact with."
            : "Select operation(s) Teams can interact with.",
        cliShortName: "o",
        placeholder: (inputs) => {
            const isPlugin = inputs[constants_3.QuestionNames.ActionType] === constants_3.ActionStartOptions.apiSpec().id;
            if (!includeExistingAPIs) {
                placeholder = (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.placeholder.skipExisting");
            }
            else if (isPlugin) {
                placeholder = (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.plugin.placeholder");
            }
            else {
                placeholder = (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.apikey.placeholder");
            }
            return placeholder;
        },
        forgetLastValue: true,
        staticOptions: [],
        validation: {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                if (input.length < 1 ||
                    (input.length > 10 &&
                        inputs[constants_3.QuestionNames.CustomCopilotRag] !== constants_3.CustomCopilotRagOptions.customApi().id &&
                        inputs[constants_3.QuestionNames.ProjectType] !== ProjectTypeOptions_1.ProjectTypeOptions.copilotAgentOptionId &&
                        inputs[constants_3.QuestionNames.ActionType] !== constants_3.ActionStartOptions.apiSpec().id)) {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.invalidMessage", input.length, 10);
                }
                const operations = inputs.supportedApisFromApiSpec;
                const authNames = new Set();
                const serverUrls = new Set();
                for (const inputItem of input) {
                    const operation = operations.find((op) => op.id === inputItem);
                    if (operation) {
                        if (operation.data.authName) {
                            authNames.add(operation.data.authName);
                            serverUrls.add(operation.data.serverUrl);
                        }
                    }
                }
                if (serverUrls.size > 1) {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.multipleServer", Array.from(serverUrls).join(", "));
                }
                const seenAuthNames = new Set();
                const uniqueAuthApis = operations.filter((api) => {
                    if (!!api.data.authName &&
                        input.includes(api.id) &&
                        !seenAuthNames.has(api.data.authName)) {
                        seenAuthNames.add(api.data.authName);
                        return true;
                    }
                    return false;
                });
                inputs.apiAuthData = uniqueAuthApis.map((authApi) => authApi.data);
            },
        },
        dynamicOptions: async (inputs) => {
            if (inputs[constants_3.QuestionNames.SelectOpenApiSpec]) {
                const specUrl = inputs[constants_3.QuestionNames.SelectOpenApiSpec];
                inputs[constants_3.QuestionNames.ApiSpecLocation] = specUrl;
                const context = (0, globalVars_1.createContext)();
                // TODO: will use kiota npm package for this api
                const res = await (0, helper_2.listOperations)(context, specUrl, inputs, true, false);
                if (res.isOk()) {
                    inputs.supportedApisFromApiSpec = res.value;
                }
                else {
                    throw res.error;
                }
            }
            if (!inputs.supportedApisFromApiSpec) {
                throw new error_2.EmptyOptionError(constants_3.QuestionNames.ApiOperation, "question");
            }
            const operations = inputs.supportedApisFromApiSpec;
            return operations;
        },
    };
}
exports.apiOperationQuestion = apiOperationQuestion;
function customCopilotRagQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.CustomCopilotRag,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.customCopilotRag.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.customCopilotRag.placeholder"),
        staticOptions: constants_3.CustomCopilotRagOptions.all(),
        dynamicOptions: () => constants_3.CustomCopilotRagOptions.all(),
        default: constants_3.CustomCopilotRagOptions.customize().id,
    };
}
function customCopilotAssistantQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.CustomCopilotAssistant,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.customCopilotAssistant.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.customCopilotAssistant.placeholder"),
        staticOptions: constants_3.CustomCopilotAssistantOptions.all(),
        dynamicOptions: () => constants_3.CustomCopilotAssistantOptions.all(),
        default: constants_3.CustomCopilotAssistantOptions.new().id,
    };
}
function llmServiceQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.LLMService,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.placeholder"),
        staticOptions: [
            {
                id: "llm-service-azure-openai",
                cliName: "azure-openai",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceAzureOpenAIOption.label"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceAzureOpenAIOption.detail"),
            },
            {
                id: "llm-service-openai",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceOpenAIOption.label"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceOpenAIOption.detail"),
            },
        ],
        dynamicOptions: (inputs) => {
            const options = [];
            options.push({
                id: "llm-service-azure-openai",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceAzureOpenAIOption.label"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceAzureOpenAIOption.detail"),
            }, {
                id: "llm-service-openai",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceOpenAIOption.label"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceOpenAIOption.detail"),
            });
            return options;
        },
        skipSingleOption: true,
        default: "llm-service-azure-openai",
    };
}
function openAIKeyQuestion() {
    return {
        type: "text",
        password: true,
        name: constants_3.QuestionNames.OpenAIKey,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.openAIKey.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.openAIKey.placeholder"),
    };
}
exports.openAIKeyQuestion = openAIKeyQuestion;
function azureOpenAIKeyQuestion() {
    return {
        type: "text",
        password: true,
        name: constants_3.QuestionNames.AzureOpenAIKey,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIKey.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIKey.placeholder"),
    };
}
exports.azureOpenAIKeyQuestion = azureOpenAIKeyQuestion;
function azureOpenAIEndpointQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.AzureOpenAIEndpoint,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIEndpoint.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIEndpoint.placeholder"),
    };
}
exports.azureOpenAIEndpointQuestion = azureOpenAIEndpointQuestion;
function azureOpenAIDeploymentNameQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.AzureOpenAIDeploymentName,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIDeploymentName.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIDeploymentName.placeholder"),
    };
}
exports.azureOpenAIDeploymentNameQuestion = azureOpenAIDeploymentNameQuestion;
function openAIAssistantIdQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.OpenAIAssistantID,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.openAIAssistantID.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.openAIAssistantID.placeholder"),
    };
}
exports.openAIAssistantIdQuestion = openAIAssistantIdQuestion;
function azureOpenAIAssistantIdQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.AzureOpenAIAssistantId,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIAssistantID.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIAssistantID.placeholder"),
    };
}
exports.azureOpenAIAssistantIdQuestion = azureOpenAIAssistantIdQuestion;
function azureOpenAIEmbeddingDeploymentNameQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.AzureOpenAIEmbeddingDeploymentName,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIEmbeddingDeploymentName.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIEmbeddingDeploymentName.placeholder"),
    };
}
exports.azureOpenAIEmbeddingDeploymentNameQuestion = azureOpenAIEmbeddingDeploymentNameQuestion;
function apiPluginStartQuestion(doesProjectExists) {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.ActionType,
        title: (inputs) => {
            return inputs[constants_3.QuestionNames.Capabilities] === CapabilityOptions_1.DACapabilityOptions.declarativeAgent().id ||
                doesProjectExists
                ? (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addApiPlugin.title")
                : (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.createApiPlugin.title");
        },
        placeholder: (inputs) => {
            return inputs[constants_3.QuestionNames.Capabilities] === CapabilityOptions_1.DACapabilityOptions.declarativeAgent().id ||
                doesProjectExists
                ? (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addApiPlugin.placeholder")
                : (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.copilotExtension.placeholder");
        },
        cliDescription: "Action type.",
        staticOptions: constants_3.ActionStartOptions.staticAll(doesProjectExists),
        dynamicOptions: (inputs) => {
            return constants_3.ActionStartOptions.all(inputs, doesProjectExists);
        },
        default: constants_3.ActionStartOptions.newApi().id,
    };
}
exports.apiPluginStartQuestion = apiPluginStartQuestion;
function selectExistingPluginManifestQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SelectPluginManifest,
        title: (0, localizeUtils_1.getLocalizedString)("core.regenerateQuestion.selectPluginManifestTitle"),
        cliDescription: "Select plugin manifest file.",
        staticOptions: [],
        onDidSelection: (item, inputs) => {
            inputs[constants_3.QuestionNames.SelectPluginId] = item.data;
        },
        dynamicOptions: async (inputs) => {
            var _a, _b, _c;
            if (!inputs.projectPath) {
                throw new Error("projectPath is undefined");
            }
            const options = [];
            const manifestPath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName);
            inputs[constants_3.QuestionNames.ManifestPath] = manifestPath;
            const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
            if (manifestRes.isErr()) {
                throw manifestRes.error;
            }
            const manifest = manifestRes.value;
            const declarativeAgentPathRelativePath = (_c = (_b = (_a = manifest === null || manifest === void 0 ? void 0 : manifest.copilotAgents) === null || _a === void 0 ? void 0 : _a.declarativeAgents) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.file;
            if (!declarativeAgentPathRelativePath) {
                throw new error_2.DeclarativeAgentPathNotFoundError(manifestPath);
            }
            const declarativeAgentPath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, declarativeAgentPathRelativePath);
            const declarativeAgentJson = (await fs_extra_1.default.readJSON(declarativeAgentPath));
            const actions = declarativeAgentJson.actions;
            if (!actions || actions.length === 0) {
                throw new error_2.ActionNotFoundError(declarativeAgentPath);
            }
            for (const action of actions) {
                const actionName = action.file;
                options.push({
                    id: path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, actionName),
                    label: path.basename(actionName),
                    data: action.id,
                });
            }
            return options;
        },
    };
}
exports.selectExistingPluginManifestQuestion = selectExistingPluginManifestQuestion;
function selectOpenAPISpecFromPluginQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SelectOpenAPISpecFromPlugin,
        title: (0, localizeUtils_1.getLocalizedString)("core.regenerateQuestion.selectOpenAPISpecFromPluginTitle"),
        cliDescription: "Select OpenAPI description document file.",
        staticOptions: [],
        onDidSelection: (itemOrId, inputs) => {
            inputs[constants_3.QuestionNames.ActionType] = constants_3.DeclarativeAgentApiSpecOptionId;
        },
        dynamicOptions: async (inputs) => {
            var _a;
            const pluginPath = inputs[constants_3.QuestionNames.SelectPluginManifest];
            const options = [];
            const pluginManifest = await fs_extra_1.default.readJSON(inputs[constants_3.QuestionNames.SelectPluginManifest]);
            const specUrlMap = new Map();
            (_a = pluginManifest.runtimes) === null || _a === void 0 ? void 0 : _a.forEach((runtime) => {
                if (runtime.spec) {
                    const specPath = runtime.spec.url;
                    const functions = runtime.run_for_functions;
                    if (specUrlMap.has(specPath)) {
                        const existingValue = specUrlMap.get(specPath);
                        if (existingValue) {
                            existingValue.push(...(functions !== null && functions !== void 0 ? functions : []));
                        }
                    }
                    else {
                        specUrlMap.set(specPath, functions !== null && functions !== void 0 ? functions : []);
                    }
                }
            });
            specUrlMap.forEach((value, key) => {
                const specAbsolutePath = path.join(path.dirname(pluginPath), key);
                options.push({
                    id: specAbsolutePath,
                    label: key,
                });
            });
            if (options.length === 0) {
                throw new error_2.SpecNotFoundError(pluginPath);
            }
            return options;
        },
    };
}
exports.selectOpenAPISpecFromPluginQuestion = selectOpenAPISpecFromPluginQuestion;
function selectApiOperationForRegenerateQuestion() {
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.ApiOperation,
        title: (0, localizeUtils_1.getLocalizedString)("core.regenerateQuestion.selectApiOperationForRegenerateTitle"),
        cliDescription: "Select operation(s) Copilot can interact with.",
        cliShortName: "o",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.plugin.placeholder"),
        forgetLastValue: true,
        staticOptions: [],
        validation: {
            validFunc: (input, inputs) => {
                const operations = inputs.supportedApisFromApiSpec;
                const serverUrls = new Set();
                for (const inputItem of input) {
                    const operation = operations.find((op) => op.id === inputItem);
                    if (operation) {
                        serverUrls.add(operation.data.serverUrl);
                    }
                }
                if (serverUrls.size > 1) {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.multipleServer", Array.from(serverUrls).join(", "));
                }
            },
        },
        dynamicOptions: async (inputs) => {
            const specUrl = inputs[constants_3.QuestionNames.SelectOpenAPISpecFromPlugin] + ".original";
            if (!(await fs_extra_1.default.pathExists(specUrl))) {
                throw new error_2.OriginalSpecNotFoundError(specUrl);
            }
            inputs[constants_3.QuestionNames.ApiSpecLocation] = specUrl;
            const context = (0, globalVars_1.createContext)();
            const res = await (0, helper_2.listOperations)(context, specUrl, inputs, true, false);
            if (res.isOk()) {
                inputs.supportedApisFromApiSpec = res.value;
            }
            else {
                throw res.error;
            }
            if (!inputs.supportedApisFromApiSpec || inputs.supportedApisFromApiSpec.length === 0) {
                throw new error_2.EmptyOptionError(constants_3.QuestionNames.ApiOperation, "question");
            }
            const operations = inputs.supportedApisFromApiSpec;
            return operations;
        },
    };
}
exports.selectApiOperationForRegenerateQuestion = selectApiOperationForRegenerateQuestion;
function pluginManifestQuestion() {
    const correlationId = correlator_1.Correlator.getId();
    return {
        type: "singleFile",
        name: constants_3.QuestionNames.PluginManifestFilePath,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addExistingPlugin.pluginManifest.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addExistingPlugin.pluginManifest.placeholder"),
        cliDescription: "Plugin manifest path.",
        filters: {
            files: ["json"],
        },
        defaultFolder: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform) ? "./" : os.homedir(),
        default: (inputs) => {
            if (!inputs.projectPath) {
                return undefined;
            }
            const ttkPluginFilePath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.DefaultPluginManifestFileName);
            if (fs_extra_1.default.existsSync(ttkPluginFilePath)) {
                return ttkPluginFilePath;
            }
            return undefined;
        },
        validation: {
            validFunc: async (input) => {
                const manifestRes = await PluginManifestUtils_1.pluginManifestUtils.readPluginManifestFile(input.trim());
                if (manifestRes.isErr()) {
                    (0, telemetry_1.sendTelemetryErrorEvent)(error_2.CoreSource, (0, telemetry_1.getQuestionValidationErrorEventName)(constants_3.QuestionNames.PluginManifestFilePath), manifestRes.error, {
                        "correlation-id": correlationId,
                    });
                    return manifestRes.error.displayMessage;
                }
                else {
                    const manifest = manifestRes.value;
                    const checkRes = (0, helper_1.validateSourcePluginManifest)(manifest, constants_3.QuestionNames.PluginManifestFilePath);
                    if (checkRes.isErr()) {
                        (0, telemetry_1.sendTelemetryErrorEvent)(error_2.CoreSource, (0, telemetry_1.getQuestionValidationErrorEventName)(constants_3.QuestionNames.PluginManifestFilePath), checkRes.error, {
                            "correlation-id": correlationId,
                        });
                        return checkRes.error.displayMessage;
                    }
                }
            },
        },
    };
}
exports.pluginManifestQuestion = pluginManifestQuestion;
function pluginApiSpecQuestion() {
    const correlationId = correlator_1.Correlator.getId();
    return {
        type: "singleFile",
        name: constants_3.QuestionNames.PluginOpenApiSpecFilePath,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addExistingPlugin.apiSpec.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addExistingPlugin.openApiSpec.placeholder"),
        cliDescription: "OpenAPI description document used for your API plugin.",
        filters: {
            files: ["json", "yml", "yaml"],
        },
        defaultFolder: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform)
            ? "./"
            : path.dirname(inputs[constants_3.QuestionNames.PluginManifestFilePath]),
        validation: {
            validFunc: async (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                const filePath = input.trim();
                const ext = path.extname(filePath).toLowerCase();
                if (![".json", ".yml", ".yaml"].includes(ext)) {
                    const error = new error_2.FileNotSupportError(error_2.CoreSource, ["json", "yml", "yaml"].join(", "));
                    (0, telemetry_1.sendTelemetryErrorEvent)(error_2.CoreSource, (0, telemetry_1.getQuestionValidationErrorEventName)(constants_3.QuestionNames.PluginOpenApiSpecFilePath), error, {
                        "correlation-id": correlationId,
                    });
                    return error.displayMessage;
                }
                const validationRes = await (0, daSpecParser_1.validateOpenAPISpec)(filePath);
                const invalidSpecError = validationRes.errors.find((o) => o.type === m365_spec_parser_1.ErrorType.SpecNotValid);
                if (invalidSpecError) {
                    const error = new teamsfx_api_1.UserError(constants_1.SpecParserSource, telemetry_1.ApiSpecTelemetryPropertis.InvalidApiSpec, invalidSpecError.content, invalidSpecError.content);
                    (0, telemetry_1.sendTelemetryErrorEvent)(error_2.CoreSource, (0, telemetry_1.getQuestionValidationErrorEventName)(constants_3.QuestionNames.PluginOpenApiSpecFilePath), error, {
                        "correlation-id": correlationId,
                        [telemetry_1.ApiSpecTelemetryPropertis.SpecNotValidDetails]: invalidSpecError.content,
                    });
                }
                return invalidSpecError === null || invalidSpecError === void 0 ? void 0 : invalidSpecError.content;
            },
        },
    };
}
exports.pluginApiSpecQuestion = pluginApiSpecQuestion;
function addKnowledgeStartQuestion(doesProjectExists) {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.KnowledgeSource,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addKnowledge.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addKnowledge.placeholder"),
        cliDescription: "Knowledge source.",
        staticOptions: constants_3.KnowledgeSourceOptions.all(),
        default: constants_3.KnowledgeSourceOptions.webSearch().id,
        required: true,
        dynamicOptions: (inputs) => {
            return constants_3.KnowledgeSourceOptions.allWithFeatureFlags();
        },
    };
}
exports.addKnowledgeStartQuestion = addKnowledgeStartQuestion;
function oneDriveSharePointItemQuestion() {
    const validationOnAccept = async (input, inputs) => {
        try {
            if (!inputs) {
                throw new Error("inputs is undefined"); // should never happen
            }
            const context = (0, globalVars_1.createContext)();
            const res = await (0, helper_1.getODSPItemInfo)(context, input.trim());
            if (res.isOk()) {
                inputs.oneDriveSharePointItem = res.value;
            }
            else {
                return res.error.displayMessage;
            }
        }
        catch (e) {
            const error = (0, error_2.assembleError)(e);
            throw error;
        }
    };
    return {
        type: "text",
        name: constants_3.QuestionNames.OneDriveSharePointURL,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.oneDriveSharePointItem.title"),
        forgetLastValue: true,
        additionalValidationOnAccept: {
            validFunc: async (input, inputs) => {
                if (!(0, stringUtils_1.isValidHttpUrl)(input.trim())) {
                    return "Please input a valid URL";
                }
                return await validationOnAccept(input.trim(), inputs);
            },
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.oneDriveSharePointItem.placeholder"),
    };
}
exports.oneDriveSharePointItemQuestion = oneDriveSharePointItemQuestion;
function oneDriveSharePointItemConfirmQuestion() {
    return {
        name: constants_3.QuestionNames.OneDriveSharePointContent,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.oneDriveSharePointItem.title"),
        type: "singleSelect",
        staticOptions: [],
        dynamicOptions: (inputs) => {
            const icon = inputs.oneDriveSharePointItem[0].itemType === constant_1.OneDriveSharePointItemType.Folder
                ? "$(folder)"
                : "$(file)";
            return [
                {
                    id: inputs.oneDriveSharePointItem[0].id,
                    label: `${icon} ${inputs.oneDriveSharePointItem[0].name}`,
                },
            ];
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.oneDriveSharePointItem.confirm"),
        forgetLastValue: true,
    };
}
exports.oneDriveSharePointItemConfirmQuestion = oneDriveSharePointItemConfirmQuestion;
function GCItemQuestion() {
    const options = [constants_3.GCSelectOptions.list(), constants_3.GCSelectOptions.input()];
    return {
        name: constants_3.QuestionNames.GCContent,
        title: (0, localizeUtils_1.getLocalizedString)("core.GCSelectQuestion.title"),
        staticOptions: options,
        type: "singleSelect",
    };
}
exports.GCItemQuestion = GCItemQuestion;
function GCListQuestion() {
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.GCList,
        title: (0, localizeUtils_1.getLocalizedString)("core.GCListQuestion.title"),
        staticOptions: [],
        dynamicOptions: helper_1.getGraphConnectors,
        default: [],
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.GCListQuestion.placeholder"),
        forgetLastValue: true,
        validation: {
            validFunc: async (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                if (inputs[constants_3.QuestionNames.KnowledgeSource] == constants_3.KnowledgeSourceOptions.graphConnector().id &&
                    inputs[constants_3.QuestionNames.GCContent] == constants_3.GCSelectOptions.list().id &&
                    input.length < 1) {
                    return Promise.resolve((0, localizeUtils_1.getLocalizedString)("core.GCListQuestion.invalidMessage", input.length));
                }
            },
        },
    };
}
exports.GCListQuestion = GCListQuestion;
function GCInputQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.GCInput,
        title: (0, localizeUtils_1.getLocalizedString)("core.GCInputQuestion.title"),
        cliDescription: "a connection ID for Copilot connector",
        forgetLastValue: true,
        validation: {
            validFunc: (input, inputs) => {
                if (!input || input.trim().length === 0) {
                    return "Please enter a connection ID for Copilot connector.";
                }
            },
        },
    };
}
exports.GCInputQuestion = GCInputQuestion;
function webContentQuestion() {
    return {
        name: constants_3.QuestionNames.WebContent,
        title: (0, localizeUtils_1.getLocalizedString)("core.addKnowledgeQuestion.webContent.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.addKnowledgeQuestion.webContent.placeholder"),
        type: "text",
        cliDescription: "An absolute URL to a site to be searched for content.",
        additionalValidationOnAccept: {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                if (!(0, stringUtils_1.isValidHttpUrl)(input.trim())) {
                    return (0, localizeUtils_1.getLocalizedString)("core.addKnowledgeQuestion.invalidWebContent.message");
                }
                else {
                    inputs.webSearchUrl = input;
                }
                return;
            },
        },
    };
}
exports.webContentQuestion = webContentQuestion;
function searchTypeQuestion() {
    return {
        name: constants_3.QuestionNames.SearchType,
        title: (0, localizeUtils_1.getLocalizedString)("core.addKnowledgeQuestion.searchType.title"),
        staticOptions: constants_3.KnowledgeSearchTypeOptions.all(),
        type: "singleSelect",
        required: true,
        default: constants_3.KnowledgeSearchTypeOptions.url().id,
        dynamicOptions: (inputs) => {
            const options = [constants_3.KnowledgeSearchTypeOptions.url()];
            if (inputs[constants_3.QuestionNames.KnowledgeSource] === constants_3.KnowledgeSourceOptions.webSearch().id) {
                options.push(constants_3.KnowledgeSearchTypeOptions.allWeb());
            }
            else if (inputs[constants_3.QuestionNames.KnowledgeSource] === constants_3.KnowledgeSourceOptions.oneDriveSharePoint().id) {
                options.push(constants_3.KnowledgeSearchTypeOptions.allOneDriveSharepoint());
            }
            return options;
        },
    };
}
exports.searchTypeQuestion = searchTypeQuestion;
function GCNameQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.GCName,
        title: (0, localizeUtils_1.getLocalizedString)("core.GCNameQuestion.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.GCNameQuestion.placeholder"),
        cliDescription: "a name for Copilot connector",
        forgetLastValue: true,
        additionalValidationOnAccept: {
            validFunc: (input, inputs) => {
                inputs = (0, utils_3.ensureInputs)(inputs);
                inputs[constants_3.QuestionNames.ProgrammingLanguage] = constants_3.ProgrammingLanguage.TS;
                // Set template name and app name for Copilot connector Template
                if (inputs[constants_3.QuestionNames.ProjectType] !== ProjectTypeOptions_1.ProjectTypeOptions.copilotAgentOptionId) {
                    inputs[constants_3.QuestionNames.TemplateName] = templateNames_1.TemplateNames.GraphConnector;
                    inputs[constants_3.QuestionNames.AppName] = input;
                }
                return;
            },
        },
        validation: {
            validFunc: (input, inputs) => {
                if (!input || input.trim().length === 0) {
                    return "Please enter a Copilot connector name.";
                }
                inputs = (0, utils_3.ensureInputs)(inputs);
                if (inputs[constants_3.QuestionNames.ProjectType] !== ProjectTypeOptions_1.ProjectTypeOptions.copilotAgentOptionId) {
                    // Copilot connector Template will use the name as app name, which has a minimum length of 2.
                    if (input.trim().length < 2) {
                        return "Please enter a Copilot connector name with minimum two characters.";
                    }
                }
                return undefined;
            },
        },
    };
}
exports.GCNameQuestion = GCNameQuestion;
function GCConnectionIdQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.GCConnectionId,
        title: (0, localizeUtils_1.getLocalizedString)("core.GCConnectionIdQuestion.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.GCConnectionIdQuestion.placeholder"),
        cliDescription: "a connection id for Copilot connector",
        forgetLastValue: true,
        validation: {
            validFunc: (input, inputs) => {
                // Developer-provided unique ID
                // Must be between 3 and 32 characters in length
                // Must only contain alphanumeric characters
                // Cannot begin with Microsoft or some disallowed id values
                // https://learn.microsoft.com/en-us/graph/api/resources/externalconnectors-externalconnection?view=graph-rest-1.0#properties
                if (!input || input.trim().length < 3) {
                    return (0, localizeUtils_1.getLocalizedString)("core.GCConnectionIdQuestion.validation.minlength");
                }
                if (input.trim().length > 32) {
                    return (0, localizeUtils_1.getLocalizedString)("core.GCConnectionIdQuestion.validation.maxlength");
                }
                if (!/^[a-zA-Z0-9]+$/.test(input)) {
                    return (0, localizeUtils_1.getLocalizedString)("core.GCConnectionIdQuestion.validation.pattern");
                }
                const disallowedConnectorIds = [
                    "Microsoft",
                    "None",
                    "Directory",
                    "Exchange",
                    "ExchangeArchive",
                    "LinkedIn",
                    "Mailbox",
                    "OneDriveBusiness",
                    "SharePoint",
                    "Teams",
                    "Yammer",
                    "Connectors",
                    "TaskFabric",
                    "PowerBI",
                    "Assistant",
                    "TopicEngine",
                    "MSFT_All_Connectors",
                ];
                // Check if the input starts with any of the beginner strings and find the first match
                const matchedBeginner = disallowedConnectorIds.find((item) => input.toLowerCase().startsWith(item.toLocaleLowerCase()));
                if (matchedBeginner) {
                    return (0, localizeUtils_1.getLocalizedString)("core.GCConnectionIdQuestion.validation.specialBeginner", matchedBeginner);
                }
                return undefined;
            },
        },
    };
}
exports.GCConnectionIdQuestion = GCConnectionIdQuestion;
function createSampleProjectQuestionNode() {
    return {
        data: sampleSelectQuestion(),
        children: [
            {
                data: folderQuestion(),
            },
        ],
    };
}
exports.createSampleProjectQuestionNode = createSampleProjectQuestionNode;
//# sourceMappingURL=create.js.map