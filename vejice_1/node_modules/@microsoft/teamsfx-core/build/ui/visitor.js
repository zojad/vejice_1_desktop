"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.findValue = exports.traverse = exports.questionVisitor = exports.singleSelectCallback = exports.loadOptions = exports.getSingleOption = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const error_1 = require("../error");
const validationUtils_1 = require("./validationUtils");
async function isAutoSkipSelect(q, inputs) {
    let skipSingle = false;
    if (q.type === "singleSelect" || q.type === "multiSelect") {
        if (q.skipSingleOption !== undefined) {
            if (typeof q.skipSingleOption === "function") {
                skipSingle = await q.skipSingleOption(inputs);
            }
            else {
                skipSingle = q.skipSingleOption;
            }
        }
    }
    return skipSingle;
}
function getSingleOption(q, option) {
    if (!option)
        option = q.staticOptions;
    const optionIsString = typeof option[0] === "string";
    let returnResult;
    if (optionIsString)
        returnResult = option[0];
    else {
        if (q.returnObject === true)
            returnResult = option[0];
        else
            returnResult = option[0].id;
    }
    if (q.type === "singleSelect")
        return returnResult;
    else
        return [returnResult];
}
exports.getSingleOption = getSingleOption;
async function getCallFuncValue(inputs, raw) {
    if (raw && typeof raw === "function") {
        return await raw(inputs);
    }
    return raw;
}
async function loadOptions(question, inputs) {
    let options = question.staticOptions;
    if (question.dynamicOptions) {
        options = await question.dynamicOptions(inputs);
    }
    return options;
}
exports.loadOptions = loadOptions;
async function singleSelectCallback(question, answer, inputs, options) {
    if (!question.onDidSelection)
        return;
    if (typeof answer !== "string") {
        await question.onDidSelection(answer, inputs);
    }
    else {
        const selected = options.find((o) => {
            if (typeof o === "string")
                return o === answer;
            return o.id === answer;
        });
        if (selected) {
            await question.onDidSelection(selected, inputs);
        }
    }
}
exports.singleSelectCallback = singleSelectCallback;
/**
 * ask question when visiting the question tree
 * @param question
 * @param core
 * @param inputs
 */
const questionVisitor = async function (question, ui, inputs, step, totalSteps) {
    var _a;
    if (inputs[question.name] !== undefined) {
        //if answer is preset, validate it and quick return the preset answer
        const res = await validationUtils_1.validationUtils.validateInputs(question, inputs[question.name], inputs);
        if (res)
            return (0, teamsfx_api_1.err)(new error_1.InputValidationError(question.name, res, "questionVisitor"));
        if (question.type === "singleSelect" && question.onDidSelection) {
            const options = await loadOptions(question, inputs);
            await singleSelectCallback(question, inputs[question.name], inputs, options);
        }
        return (0, teamsfx_api_1.ok)({ type: "skip", result: inputs[question.name] });
    }
    if (inputs.nonInteractive) {
        // if no preset answer and non-interactive mode
        // first priority: use single option as value
        if (question.type === "singleSelect" || question.type === "multiSelect") {
            const skipSingle = await isAutoSkipSelect(question, inputs);
            if (skipSingle) {
                const options = await loadOptions(question, inputs);
                if (options.length === 0) {
                    return (0, teamsfx_api_1.err)(new error_1.EmptyOptionError(question.name, "questionVisitor"));
                }
                if (options.length === 1) {
                    const value = getSingleOption(question, options);
                    if (value) {
                        if (question.type === "singleSelect") {
                            await singleSelectCallback(question, inputs[question.name], inputs, options);
                        }
                        return (0, teamsfx_api_1.ok)({ type: "skip", result: value });
                    }
                }
            }
        }
        // second priority: use default as value
        if (question.default) {
            const value = (await getCallFuncValue(inputs, question.default));
            if (value) {
                const validateRes = await validationUtils_1.validationUtils.validateInputs(question, value, inputs);
                if (validateRes) {
                    return (0, teamsfx_api_1.err)(new error_1.InputValidationError(question.name, validateRes, "questionVisitor"));
                }
                else {
                    if (question.type === "singleSelect") {
                        const options = await loadOptions(question, inputs);
                        await singleSelectCallback(question, value, inputs, options);
                    }
                    return (0, teamsfx_api_1.ok)({ type: "skip", result: value });
                }
            }
        }
        if (question.required)
            return (0, teamsfx_api_1.err)(new error_1.MissingRequiredInputError(question.name, "questionVisitor"));
        else
            return (0, teamsfx_api_1.ok)({ type: "skip", result: undefined });
    }
    //no preset answer and interactive mode, call UI
    const title = (await getCallFuncValue(inputs, question.title));
    let defaultValue = undefined;
    if (question.forgetLastValue !== true && question.value)
        defaultValue = question.value;
    else {
        if (question.default) {
            if (typeof question.default === "function") {
                defaultValue = async () => {
                    return await question.default(inputs);
                };
            }
            else {
                defaultValue = question.default;
            }
        }
    }
    const placeholder = (await getCallFuncValue(inputs, question.placeholder));
    const prompt = (await getCallFuncValue(inputs, question.prompt));
    if (question.type === "text") {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        const additionalValidationOnAcceptFunc = question.additionalValidationOnAccept
            ? (0, validationUtils_1.getValidationFunction)(question.additionalValidationOnAccept, inputs)
            : undefined;
        return await ui.inputText({
            name: question.name,
            title: title,
            password: question.password,
            default: defaultValue,
            placeholder: placeholder,
            prompt: prompt,
            validation: validationFunc,
            step: step,
            totalSteps: totalSteps,
            additionalValidationOnAccept: additionalValidationOnAcceptFunc,
        });
    }
    else if (question.type === "singleSelect" || question.type === "multiSelect") {
        const skipSingle = await isAutoSkipSelect(question, inputs);
        let options = undefined;
        if (question.dynamicOptions) {
            options = async () => {
                return question.dynamicOptions(inputs);
            };
        }
        else {
            if (!question.staticOptions || question.staticOptions.length === 0) {
                return (0, teamsfx_api_1.err)(new error_1.EmptyOptionError(question.name, "questionVisitor"));
            }
            if (skipSingle && question.staticOptions.length === 1) {
                // quick return for static options with only one item
                const returnResult = getSingleOption(question, question.staticOptions);
                if (question.type === "singleSelect" && question.onDidSelection) {
                    let selected = returnResult;
                    if (typeof selected === "string") {
                        selected = question.staticOptions[0];
                    }
                    await question.onDidSelection(selected, inputs);
                }
                return (0, teamsfx_api_1.ok)({ type: "skip", result: returnResult });
            }
            options = question.staticOptions;
        }
        if (question.type === "singleSelect") {
            const validationFunc = question.validation
                ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
                : undefined;
            const res = await ui.selectOption({
                name: question.name,
                title: title,
                options: options,
                returnObject: question.returnObject,
                default: defaultValue,
                placeholder: placeholder,
                prompt: prompt,
                step: step,
                totalSteps: totalSteps,
                buttons: question.buttons,
                validation: validationFunc,
                skipSingleOption: skipSingle,
            });
            if (res.isOk() && res.value.type === "success") {
                let selected = res.value.result;
                if (typeof selected === "string") {
                    const options = res.value.options;
                    if (options && options.length > 0 && typeof options[0] !== "string") {
                        selected = options.find((o) => o.id === selected);
                    }
                }
                await ((_a = question.onDidSelection) === null || _a === void 0 ? void 0 : _a.call(question, selected, inputs));
            }
            return res;
        }
        else {
            const validationFunc = question.validation
                ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
                : undefined;
            return await ui.selectOptions({
                name: question.name,
                title: title,
                options: options,
                returnObject: question.returnObject,
                default: defaultValue,
                placeholder: placeholder,
                prompt: prompt,
                onDidChangeSelection: question.onDidChangeSelection,
                step: step,
                totalSteps: totalSteps,
                validation: validationFunc,
                skipSingleOption: skipSingle,
            });
        }
    }
    else if (question.type === "multiFile") {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        return await ui.selectFiles({
            name: question.name,
            title: title,
            placeholder: placeholder,
            prompt: prompt,
            default: defaultValue,
            step: step,
            totalSteps: totalSteps,
            validation: validationFunc,
        });
    }
    else if (question.type === "singleFile") {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        let defaultFolder;
        if (question.defaultFolder) {
            if (typeof question.defaultFolder === "function") {
                defaultFolder = async () => {
                    return await question.defaultFolder(inputs);
                };
            }
            else {
                defaultFolder = question.defaultFolder;
            }
        }
        return await ui.selectFile({
            name: question.name,
            title: title,
            placeholder: placeholder,
            prompt: prompt,
            default: defaultValue,
            step: step,
            totalSteps: totalSteps,
            validation: validationFunc,
            filters: question.filters,
            innerStep: question.innerStep,
            innerTotalStep: question.innerTotalStep,
            defaultFolder,
        });
    }
    else if (question.type === "folder") {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        return await ui.selectFolder({
            name: question.name,
            title: title,
            placeholder: placeholder,
            prompt: prompt,
            default: defaultValue,
            step: step,
            totalSteps: totalSteps,
            validation: validationFunc,
        });
    }
    else if (question.type === "singleFileOrText" && !!ui.selectFileOrInput) {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        const inputValidationFunc = question.inputBoxConfig.validation
            ? (0, validationUtils_1.getValidationFunction)(question.inputBoxConfig.validation, inputs)
            : undefined;
        const innerTitle = (await getCallFuncValue(inputs, question.inputBoxConfig.title));
        const innerPlaceholder = (await getCallFuncValue(inputs, question.inputBoxConfig.placeholder));
        const innerPrompt = (await getCallFuncValue(inputs, question.inputBoxConfig.prompt));
        const res = await ui.selectFileOrInput({
            name: question.name,
            title: title,
            placeholder: placeholder,
            prompt: prompt,
            inputOptionItem: question.inputOptionItem,
            inputBoxConfig: {
                name: question.inputBoxConfig.name,
                title: innerTitle,
                placeholder: innerPlaceholder,
                prompt: innerPrompt,
                validation: inputValidationFunc,
                step: question.inputBoxConfig.step,
            },
            filters: question.filters,
            step: step,
            totalSteps: totalSteps,
            validation: validationFunc,
        });
        return res;
    }
    else if (question.type === "confirm" && ui.confirm) {
        const res = await ui.confirm({
            name: question.name,
            title: title,
            default: defaultValue,
            step: step,
            totalSteps: totalSteps,
        });
        return res;
    }
    return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError("API", "UnsupportedNodeType", `Unsupported question node type:${JSON.stringify(question)}`, `Unsupported question node type:${JSON.stringify(question)}`));
};
exports.questionVisitor = questionVisitor;
async function traverse(root, inputs, ui, telemetryReporter, visitor = exports.questionVisitor) {
    // The reason to clone is that we don't want to change the original inputs if user cancel the process
    let currentInput = (0, lodash_1.cloneDeep)(inputs);
    const parentMap = new Map();
    const historyStacks = [];
    const historyInputs = [];
    let stack = [];
    stack.push(root);
    let step = 1; // step number means the number of nodes that is really visited by UI, except cases for: group node, skip node and node with condition failure
    while (stack.length > 0) {
        // get the last node but not pop it right now
        const node = stack[stack.length - 1];
        let conditionPass = true;
        // check condition
        if (node.condition) {
            let parentValue = undefined;
            const parent = parentMap.get(node);
            if (parent) {
                parentValue = findValue(parent, parentMap);
            }
            const validRes = await (0, validationUtils_1.validate)(node.condition, parentValue, currentInput);
            if (validRes !== undefined) {
                conditionPass = false;
            }
        }
        node.conditionResult = conditionPass;
        if (conditionPass) {
            if (node.data.type !== "group") {
                const question = node.data;
                let res;
                try {
                    question.value = undefined;
                    question.valueType = undefined;
                    res = await visitor(question, ui, currentInput, step, undefined);
                    sendTelemetryEvent(telemetryReporter, res, question, currentInput);
                }
                catch (e) {
                    return (0, teamsfx_api_1.err)((0, error_1.assembleError)(e));
                }
                if (res.isErr()) {
                    // Cancel or Error
                    return (0, teamsfx_api_1.err)(res.error);
                }
                const inputResult = res.value;
                if (inputResult.type === "back") {
                    if (historyStacks.length === 0) {
                        return (0, teamsfx_api_1.err)(new error_1.UserCancelError());
                    }
                    stack = historyStacks.pop();
                    currentInput = historyInputs.pop();
                    step--;
                    continue;
                }
                else {
                    // go forward: success or skip
                    question.value = inputResult.result;
                    question.valueType = inputResult.type;
                    const historyInput = (0, lodash_1.cloneDeep)(currentInput);
                    currentInput[question.name] = question.value;
                    if (question.valueType === "success") {
                        const clonedStack = [...stack];
                        historyStacks.push(clonedStack);
                        historyInputs.push(historyInput);
                        step++;
                    }
                }
            }
        }
        stack.pop();
        //check and push children into stack from end to start
        if (node.conditionResult && node.children && node.children.length > 0) {
            for (let i = node.children.length - 1; i >= 0; --i) {
                const child = node.children[i];
                if (child) {
                    parentMap.set(child, node);
                    stack.push(child);
                }
            }
        }
    }
    (0, lodash_1.assign)(inputs, currentInput);
    return (0, teamsfx_api_1.ok)(undefined);
}
exports.traverse = traverse;
function findValue(curr, parentMap) {
    if (curr.data.type !== "group") {
        // need to convert OptionItem value into id for validation
        if (curr.data.type === "singleSelect") {
            const sq = curr.data;
            if (sq.value && typeof sq.value !== "string" && sq.value.id) {
                return sq.value.id;
            }
        }
        else if (curr.data.type === "multiSelect") {
            const mq = curr.data;
            if (mq.value && typeof mq.value[0] !== "string") {
                return mq.value.map((i) => i.id);
            }
        }
        return curr.data.value;
    }
    const parent = parentMap.get(curr);
    if (parent) {
        return findValue(parent, parentMap);
    }
    return undefined;
}
exports.findValue = findValue;
function sendTelemetryEvent(telemetryReporter, qvres, question, inputs) {
    var _a;
    if (qvres.isErr()) {
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(teamsfx_api_1.TelemetryEvent.askQuestion, {
            [teamsfx_api_1.TelemetryProperty.answerType]: qvres.error.name,
            [teamsfx_api_1.TelemetryProperty.question]: question.name,
            [teamsfx_api_1.TelemetryProperty.platform]: inputs.platform,
            [teamsfx_api_1.TelemetryProperty.stage]: inputs.stage ? inputs.stage : "",
        });
    }
    else {
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(teamsfx_api_1.TelemetryEvent.askQuestion, {
            [teamsfx_api_1.TelemetryProperty.answerType]: qvres.value.type,
            [teamsfx_api_1.TelemetryProperty.question]: question.name,
            [teamsfx_api_1.TelemetryProperty.answer]: question.type == "singleSelect" || question.type == "multiSelect"
                ? (_a = qvres.value.result) === null || _a === void 0 ? void 0 : _a.toString()
                : "",
            [teamsfx_api_1.TelemetryProperty.platform]: inputs.platform,
            [teamsfx_api_1.TelemetryProperty.stage]: inputs.stage ? inputs.stage : "",
        });
    }
}
//# sourceMappingURL=visitor.js.map