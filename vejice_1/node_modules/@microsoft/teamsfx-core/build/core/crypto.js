"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalCrypto = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const cryptr_1 = tslib_1.__importDefault(require("cryptr"));
class LocalCrypto {
    constructor(projectId) {
        this.prefix = "crypto_";
        this.cryptr = new cryptr_1.default(projectId + "_teamsfx");
        this.fixedCryptr = new cryptr_1.default("teamsfx_global_key");
    }
    encrypt(plaintext) {
        return (0, teamsfx_api_1.ok)(this.prefix + this.fixedCryptr.encrypt(plaintext));
    }
    decrypt(ciphertext) {
        if (!ciphertext.startsWith(this.prefix)) {
            // legacy raw secret string
            return (0, teamsfx_api_1.ok)(ciphertext);
        }
        const encryptedData = ciphertext.substr(this.prefix.length);
        try {
            return (0, teamsfx_api_1.ok)(this.fixedCryptr.decrypt(encryptedData));
        }
        catch (e) {
            try {
                return (0, teamsfx_api_1.ok)(this.cryptr.decrypt(encryptedData));
            }
            catch (e2) {
                return (0, teamsfx_api_1.err)(new teamsfx_api_1.SystemError("Core", "DecryptionError", "Cipher text is broken"));
            }
        }
    }
}
exports.LocalCrypto = LocalCrypto;
//# sourceMappingURL=crypto.js.map