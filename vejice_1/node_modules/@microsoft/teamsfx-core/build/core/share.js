"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeShareAccess = exports.addSharedUsers = exports.shareWithTenant = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const graphClient_1 = require("../client/graphClient");
const globalVars_1 = require("../common/globalVars");
const localizeUtils_1 = require("../common/localizeUtils");
require("../component/driver/index");
require("../component/driver/script/scriptDriver");
require("../component/feature/sso");
const interface_1 = require("../component/m365/interface");
const packageService_1 = require("../component/m365/packageService");
const common_1 = require("../error/common");
const collaborator_1 = require("./collaborator");
async function shareWithTenant(mosToken, sharedTitleId) {
    var _a;
    // share with tenant users
    const res = await packageService_1.PackageService.GetSharedInstance().shareWithTenant(mosToken, sharedTitleId);
    if (res.isErr()) {
        return (0, teamsfx_api_1.err)(res.error);
    }
    const msg = (0, localizeUtils_1.getLocalizedString)("core.common.shareWithTenant.success");
    (_a = globalVars_1.TOOLS.ui) === null || _a === void 0 ? void 0 : _a.showMessage("info", msg, false);
    return (0, teamsfx_api_1.ok)(undefined);
}
exports.shareWithTenant = shareWithTenant;
async function addSharedUsers(mosToken, sharedTitleId, emails) {
    var _a;
    const tokenProvider = globalVars_1.TOOLS.tokenProvider.m365TokenProvider;
    const entities = new Set();
    const existingEntities = await packageService_1.PackageService.GetSharedInstance().getSharedUsers(mosToken, sharedTitleId);
    if (existingEntities.isErr()) {
        return (0, teamsfx_api_1.err)(existingEntities.error);
    }
    // merge existing entities with new entities
    for (const entity of existingEntities.value) {
        entities.add({
            entityId: entity.entityId,
            entityType: entity.entityType,
        });
    }
    const graphClient = new graphClient_1.GraphClient(tokenProvider);
    for (const email of emails) {
        const userInfo = await collaborator_1.CollaborationUtil.getUserInfo(tokenProvider, email);
        if (!userInfo) {
            const groupInfo = await graphClient.getGroupInfo(email);
            if (!groupInfo) {
                return (0, teamsfx_api_1.err)(new common_1.InputValidationError("shareWithUser", `Invalid user or group: ${email}`));
            }
            entities.add({
                entityId: groupInfo.id,
                entityType: interface_1.M365EntityType.Group,
            });
        }
        else {
            entities.add({
                entityId: userInfo.aadId,
                entityType: interface_1.M365EntityType.User,
            });
        }
    }
    // Call Builder API to change shared scope
    const res = await packageService_1.PackageService.GetSharedInstance().shareWithUsers(mosToken, Array.from(entities), sharedTitleId);
    if (res.isErr()) {
        return (0, teamsfx_api_1.err)(res.error);
    }
    const msg = (0, localizeUtils_1.getLocalizedString)("core.common.shareWithUser.success", emails);
    (_a = globalVars_1.TOOLS.ui) === null || _a === void 0 ? void 0 : _a.showMessage("info", msg, false);
    return (0, teamsfx_api_1.ok)(undefined);
}
exports.addSharedUsers = addSharedUsers;
async function removeShareAccess(mosToken, sharedTitleId, emails) {
    var _a;
    const tokenProvider = globalVars_1.TOOLS.tokenProvider.m365TokenProvider;
    const entities = new Set();
    const existingEntities = await packageService_1.PackageService.GetSharedInstance().getSharedUsers(mosToken, sharedTitleId);
    if (existingEntities.isErr()) {
        return (0, teamsfx_api_1.err)(existingEntities.error);
    }
    // remove users from shared access
    const graphClient = new graphClient_1.GraphClient(tokenProvider);
    for (const email of emails) {
        const userInfo = await collaborator_1.CollaborationUtil.getUserInfo(tokenProvider, email);
        if (!userInfo) {
            const groupInfo = await graphClient.getGroupInfo(email);
            if (!groupInfo) {
                return (0, teamsfx_api_1.err)(new common_1.InputValidationError("shareWithUser", `Invalid user or group: ${email}`));
            }
            entities.add(groupInfo.id);
        }
        else {
            entities.add(userInfo.aadId);
        }
    }
    const remainingEntities = Array.from(existingEntities.value).filter((entity) => !entities.has(entity.entityId));
    if (remainingEntities.length === 0) {
        // no users left, call Builder API to unshare
        const res = await packageService_1.PackageService.GetSharedInstance().unshare(mosToken, sharedTitleId);
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
    }
    else {
        // Call Builder API to change shared scope
        const res = await packageService_1.PackageService.GetSharedInstance().shareWithUsers(mosToken, Array.from(remainingEntities), sharedTitleId);
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
    }
    const msg = (0, localizeUtils_1.getLocalizedString)("core.common.removeShareAccess.success", emails);
    (_a = globalVars_1.TOOLS.ui) === null || _a === void 0 ? void 0 : _a.showMessage("info", msg, false);
    return (0, teamsfx_api_1.ok)(undefined);
}
exports.removeShareAccess = removeShareAccess;
//# sourceMappingURL=share.js.map